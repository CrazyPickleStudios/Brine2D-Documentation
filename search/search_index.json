{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Brine2D Game Engine","text":"<p>What's New in v0.8.0-beta</p> <p>Texture atlasing, 2D spatial audio, advanced particles with textures, rotation, trails, and blend modes!</p> <p> See What's New</p>"},{"location":"#modern-2d-game-development-with-net-elegance","title":"Modern 2D game development with .NET elegance","text":"<p>Brine2D is a modern .NET 10 engine built on SDL3, inspired by the architecture and developer experience of ASP.NET. If you've built ASP.NET Core applications, the development model will feel immediately familiar.</p> <ul> <li> <p> Get Started in Minutes</p> <p>Familiar patterns mean minimal learning curve for .NET developers</p> <p> Quick Start</p> </li> <li> <p> Learn the Basics</p> <p>Comprehensive guides covering every aspect of Brine2D</p> <p> Tutorials</p> </li> <li> <p> API Reference</p> <p>Complete API documentation for all Brine2D packages</p> <p> API Docs</p> </li> <li> <p> View on GitHub</p> <p>Open source and MIT licensed</p> <p> GitHub Repository</p> </li> </ul>"},{"location":"#why-brine2d","title":"Why Brine2D?","text":""},{"location":"#convention-over-configuration","title":"Convention Over Configuration","text":"<p>Just like ASP.NET, Brine2D provides sensible defaults that just work. Focus on building your game, not fighting with configuration.</p>"},{"location":"#first-class-dependency-injection","title":"First-Class Dependency Injection","text":"<p>Built on Microsoft's DI container, Brine2D makes testable, maintainable code the default\u2014not the exception.</p> <pre><code>using Brine2D.Core;\nusing Brine2D.Input;\nusing Brine2D.Rendering;\nusing Microsoft.Extensions.Logging;\n\npublic class GameScene : Scene\n{\n    // Constructor injection - just like ASP.NET controllers\n    public GameScene(IRenderer renderer, IInputService input, ILogger&lt;GameScene&gt; logger) : base(logger)\n    {\n        // Dependencies automatically injected!\n    }\n}</code></pre>"},{"location":"#familiar-developer-experience","title":"Familiar Developer Experience","text":"ASP.NET Core Brine2D What It Means <code>WebApplicationBuilder</code> <code>GameApplicationBuilder</code> Configure your game with the same patterns Controllers Scenes Organize game logic into manageable units Middleware Pipeline System Pipelines Automatic execution via lifecycle hooks <code>appsettings.json</code> <code>gamesettings.json</code> JSON configuration with hot reload <code>ILogger&lt;T&gt;</code> <code>ILogger&lt;T&gt;</code> Structured logging everywhere Entity Framework Scene Management Transitions, loading screens"},{"location":"#production-ready-architecture","title":"Production-Ready Architecture","text":"<ul> <li>Modular by design - Mix and match only what you need</li> <li>Clean separation of concerns - Abstractions over implementations</li> <li>Testable - Mock any service, test any component</li> <li>Cross-platform - Windows, macOS, Linux support via SDL3</li> </ul>"},{"location":"#see-it-in-action","title":"See It In Action","text":"<p>Here's a complete game in ~30 lines of code:</p> <pre><code>using Brine2D.Core;\nusing Brine2D.Engine;\nusing Brine2D.Hosting;\nusing Brine2D.Input;\nusing Brine2D.Input.SDL;\nusing Brine2D.Rendering;\nusing Brine2D.Rendering.SDL;\nusing Microsoft.Extensions.Logging;\n\n// Create builder (like ASP.NET's WebApplication.CreateBuilder)\nvar builder = GameApplication.CreateBuilder(args);\n\n// Configure services\nbuilder.Services.AddSDL3Rendering(options =&gt;\n{\n    options.WindowTitle = \"My Game\";\n    options.WindowWidth = 1280;\n    options.WindowHeight = 720;\n});\n\nbuilder.Services.AddSDL3Input();\nbuilder.Services.AddScene&lt;GameScene&gt;();\n\n// Build and run\nvar game = builder.Build();\n\nawait game.RunAsync&lt;GameScene&gt;();\n\n// Define your scene (like an ASP.NET controller)\npublic class GameScene : Scene\n{\n    private readonly IInputService _input;\n    private readonly IRenderer _renderer;\n    private readonly IGameContext _gameContext;\n\n    public GameScene\n    (\n        IRenderer renderer,\n        IInputService input,\n        IGameContext gameContext,\n        ILogger&lt;GameScene&gt; logger\n    ) : base(logger)\n    {\n        _renderer = renderer;\n        _input = input;\n        _gameContext = gameContext;\n    }\n\n    protected override void OnRender(GameTime gameTime)\n    {\n        // Frame management happens automatically!\n        _renderer.DrawText(\"Hello, Brine2D!\", 100, 100, Color.White);\n    }\n\n    protected override void OnUpdate(GameTime gameTime)\n    {\n        if (_input.IsKeyPressed(Keys.Escape))\n        {\n            _gameContext.RequestExit();\n        }\n    }\n}</code></pre> <p>That's it! A complete game window with input handling and rendering.</p>"},{"location":"#core-features","title":"Core Features","text":""},{"location":"#modern-gpu-rendering","title":"Modern GPU Rendering","text":"<ul> <li>Hardware-accelerated via SDL3 GPU (Vulkan/Metal/D3D12)</li> <li>Texture atlasing with runtime sprite packing</li> <li>Sprite sheets and animations</li> <li>Camera system with zoom and rotation</li> <li>Line drawing with configurable thickness</li> </ul>"},{"location":"#hybrid-entity-component-system","title":"Hybrid Entity Component System","text":"<ul> <li>Components are classes that can contain logic</li> <li>Optional systems for performance optimization</li> <li>Composition over inheritance for flexible entities</li> <li>ASP.NET-style system pipelines with automatic execution</li> </ul>"},{"location":"#advanced-query-system","title":"Advanced Query System","text":"<ul> <li>Fluent API for complex entity searches</li> <li>Cached queries for zero-allocation performance</li> <li>Spatial queries (within radius/bounds)</li> <li>Multiple filter conditions</li> </ul>"},{"location":"#scene-transitions","title":"Scene Transitions","text":"<ul> <li>Smooth fade transitions between scenes</li> <li>Custom loading screens with progress bars</li> <li>Async scene loading</li> <li>Scene chaining support</li> </ul>"},{"location":"#flexible-input-system","title":"Flexible Input System","text":"<ul> <li>Keyboard, mouse, and gamepad support</li> <li>Input layers (like middleware for input)</li> <li>Event-driven and polling APIs</li> </ul>"},{"location":"#2d-spatial-audio-system","title":"2D Spatial Audio System","text":"<ul> <li>Distance-based volume attenuation</li> <li>Stereo panning based on position</li> <li>Configurable falloff curves (linear, quadratic, custom)</li> <li>ECS integration with audio sources and listeners</li> </ul>"},{"location":"#advanced-particle-system","title":"Advanced Particle System","text":"<ul> <li>Object pooling for zero-allocation performance</li> <li>Particle textures with custom sprites</li> <li>Rotation, trails, and blend modes</li> <li>7 emitter shapes (point, circle, ring, box, cone, line, burst)</li> </ul>"},{"location":"#collision-detection","title":"Collision Detection","text":"<ul> <li>Box and circle colliders</li> <li>Spatial partitioning for performance</li> <li>Physics response (bounce, slide, push)</li> </ul>"},{"location":"#tilemap-support","title":"Tilemap Support","text":"<ul> <li>Tiled (.tmj) file format</li> <li>Automatic collision generation</li> <li>Layer rendering</li> </ul>"},{"location":"#complete-ui-framework","title":"Complete UI Framework","text":"<ul> <li>15+ production-ready components</li> <li>Buttons, sliders, text inputs, dialogs, tabs</li> <li>Scroll views, tooltips, dropdowns</li> <li>Input layer management</li> </ul>"},{"location":"#project-structure","title":"Project Structure","text":"<p>Brine2D follows a clean, modular architecture:</p> <pre><code>Brine2D/ \n    \u251c\u2500\u2500 Brine2D.Core         # Core abstractions (IScene, ITexture, etc.)\n    \u251c\u2500\u2500 Brine2D.Engine        # Game loop, scene management, transitions\n    \u251c\u2500\u2500 Brine2D.Hosting       # ASP.NET-style hosting model \n    \u251c\u2500\u2500 Brine2D.ECS           # Entity Component System \n    \u251c\u2500\u2500 Brine2D.Rendering     # Rendering abstractions \n    \u251c\u2500\u2500 Brine2D.Rendering.SDL # SDL3 rendering implementation \n    \u251c\u2500\u2500 Brine2D.Rendering.ECS # ECS rendering systems \n    \u251c\u2500\u2500 Brine2D.Input         # Input abstractions \n    \u251c\u2500\u2500 Brine2D.Input.SDL     # SDL3 input implementation \n    \u251c\u2500\u2500 Brine2D.Input.ECS     # ECS input systems \n    \u251c\u2500\u2500 Brine2D.Audio         # Audio abstractions \n    \u251c\u2500\u2500 Brine2D.Audio.SDL     # SDL3 audio implementation \n    \u251c\u2500\u2500 Brine2D.Audio.ECS     # ECS audio systems \n    \u2514\u2500\u2500 Brine2D.UI            # Complete UI framework</code></pre> <p>Each package is focused, testable, and can be swapped with custom implementations.</p>"},{"location":"#whats-new-in-080-beta","title":"What's New in 0.8.0-beta","text":"<p>Brine2D 0.8.0-beta delivers production-ready audio and visual effects:</p> <ul> <li>Texture Atlasing - Runtime sprite packing reduces draw calls by 90-99%</li> <li>2D Spatial Audio - Distance attenuation and stereo panning bring your world to life</li> <li>Advanced Particles - Textures, rotation, trails, blend modes, and 7 emitter shapes</li> <li>Audio Callbacks - Proper track lifecycle management via SDL3_mixer</li> <li>Rotation Support - SpriteBatcher now respects sprite rotation</li> <li>8+ Interactive Demos - New demos for atlasing, spatial audio, and enhanced particles</li> </ul> <p>Read the full changelog</p>"},{"location":"#who-is-this-for","title":"Who Is This For?","text":""},{"location":"#aspnet-developers","title":"ASP.NET Developers","text":"<p>You already know the patterns. Now build games with them.</p>"},{"location":"#game-developers","title":"Game Developers","text":"<p>Build games on a modern, maintainable .NET architecture.</p>"},{"location":"#students-educators","title":"Students &amp; Educators","text":"<p>Learn game development with familiar .NET patterns.</p>"},{"location":"#enterprise-teams","title":"Enterprise Teams","text":"<p>Build internal tools and games with maintainable code.</p>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>.NET 10 SDK or later</li> <li>SDL3 (included via SDL3-CS NuGet)</li> <li>Windows, macOS, or Linux</li> </ul>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li> <p> 5-Minute Quickstart</p> <p>Create your first game in minutes</p> <p> Get Started</p> </li> <li> <p> Tutorials</p> <p>Step-by-step guides for common scenarios</p> <p> Learn More</p> </li> <li> <p> Concepts</p> <p>Deep dive into Brine2D's architecture</p> <p> Read Docs</p> </li> <li> <p> FeatureDemos</p> <p>Interactive demos showcasing all major features</p> <p> Browse Demos</p> </li> </ul>"},{"location":"#community-support","title":"Community &amp; Support","text":"<ul> <li>GitHub: CrazyPickleStudios/Brine2D</li> <li>Issues: Report bugs or request features</li> <li>Discussions: Ask questions and share ideas</li> <li>License: MIT - Use it anywhere, even commercially</li> </ul> <p>Ready to build games the ASP.NET way?</p> <p>Get Started  View Demos </p>"},{"location":"concepts/","title":"Samples","text":"<p>Learn by example! The Brine2D samples demonstrate real-world usage of the engine's features. Each sample is a complete, runnable project that showcases specific functionality.</p>"},{"location":"concepts/#featuredemos","title":"FeatureDemos","text":"<p>Location: <code>samples/FeatureDemos/</code> Difficulty: Beginner to Advanced Topics Covered: ECS Queries, Particles, Texture Atlasing, Spatial Audio, Collision, Scene Transitions, UI, Manual Control</p> <p>The FeatureDemos project is an interactive showcase of Brine2D's major features. Run the project to see a menu-driven demo selector where you can explore each feature independently.</p> <pre><code>graph TD\n    A[\"FeatureDemos Project\"] --&gt; B[\"MainMenuScene\"]\n    B --&gt; C[\"Query System Demo\"]\n    B --&gt; D[\"Particle System Demo\"]\n    B --&gt; E[\"Texture Atlas Demo\"]\n    B --&gt; F[\"Spatial Audio Demo\"]\n    B --&gt; G[\"Collision Demo\"]\n    B --&gt; H[\"Scene Transitions Demo\"]\n    B --&gt; I[\"UI Components Demo\"]\n    B --&gt; J[\"Manual Control Demo\"]\n\n    C --&gt; K[\"Fluent Query API\"]\n    C --&gt; L[\"Cached Queries\"]\n    C --&gt; M[\"Complex Filters\"]\n\n    D --&gt; N[\"Textures &amp; Rotation\"]\n    D --&gt; O[\"Trails &amp; Blend Modes\"]\n    D --&gt; P[\"7 Emitter Shapes\"]\n\n    E --&gt; Q[\"Runtime Packing\"]\n    E --&gt; R[\"Bin Packing Algorithm\"]\n    E --&gt; S[\"Draw Call Reduction\"]\n\n    F --&gt; T[\"Distance Attenuation\"]\n    F --&gt; U[\"Stereo Panning\"]\n    F --&gt; V[\"Real-Time Visualization\"]\n\n    G --&gt; W[\"AABB Colliders\"]\n    G --&gt; X[\"Circle Colliders\"]\n    G --&gt; Y[\"Physics Response\"]\n\n    H --&gt; Z[\"FadeTransition\"]\n    H --&gt; AA[\"Loading Screens\"]\n    H --&gt; AB[\"Scene Chaining\"]\n\n    I --&gt; AC[\"Complete UI Library\"]\n    I --&gt; AD[\"Tooltips &amp; Dialogs\"]\n    I --&gt; AE[\"Input Layers\"]\n\n    J --&gt; AF[\"Lifecycle Hooks\"]\n    J --&gt; AG[\"Manual Pipelines\"]\n    J --&gt; AH[\"Power User Features\"]\n\n    style A fill:#1e3a5f,stroke:#569cd6,stroke-width:2px,color:#fff\n    style B fill:#2d5016,stroke:#4ec9b0,stroke-width:2px,color:#fff\n    style C fill:#4a2d4a,stroke:#c586c0,stroke-width:2px,color:#fff\n    style D fill:#4a2d4a,stroke:#c586c0,stroke-width:2px,color:#fff\n    style E fill:#4a2d4a,stroke:#c586c0,stroke-width:2px,color:#fff\n    style F fill:#4a2d4a,stroke:#c586c0,stroke-width:2px,color:#fff\n    style G fill:#4a2d4a,stroke:#c586c0,stroke-width:2px,color:#fff\n    style H fill:#4a2d4a,stroke:#c586c0,stroke-width:2px,color:#fff\n    style I fill:#4a2d4a,stroke:#c586c0,stroke-width:2px,color:#fff\n    style J fill:#4a2d4a,stroke:#c586c0,stroke-width:2px,color:#fff</code></pre>"},{"location":"concepts/#demo-scenes","title":"Demo Scenes","text":"Demo Description Key Features Category Query System Advanced entity queries Fluent API, cached queries, complex filters ECS Particle System Advanced particle effects Textures, rotation, trails, blend modes, 7 shapes ECS Texture Atlas Runtime sprite packing Bin packing, draw call reduction, performance Rendering Spatial Audio 2D positional audio Distance attenuation, stereo panning, visualization Audio Collision Detection Physics and collision AABB/circle colliders, bounce, slide, push Collision Scene Transitions Smooth scene changes FadeTransition, loading screens, async loading Transitions UI Components Complete UI showcase All 15+ components, tooltips, dialogs, tabs UI Manual Control Power user features Opt-out of automatic execution, custom pipelines Advanced"},{"location":"concepts/#running-the-demos","title":"Running the Demos","text":""},{"location":"concepts/#prerequisites","title":"Prerequisites","text":"<ul> <li>.NET 10 SDK</li> <li>Visual Studio 2022 or VS Code</li> <li>SDL3 (auto-installed via NuGet)</li> </ul>"},{"location":"concepts/#option-1-run-from-visual-studio","title":"Option 1: Run from Visual Studio","text":"<ol> <li>Open <code>Brine2D.sln</code> in Visual Studio</li> <li>Set <code>FeatureDemos</code> as startup project</li> <li>Press F5 to run</li> <li>Select a demo from the menu</li> </ol>"},{"location":"concepts/#option-2-run-from-command-line","title":"Option 2: Run from Command Line","text":"<pre><code>cd samples/FeatureDemos\ndotnet run</code></pre>"},{"location":"concepts/#navigation","title":"Navigation","text":"<ul> <li>Use number keys (1-8) to select a demo</li> <li>ESC returns to menu from any demo</li> <li>F1-F5 toggle debug options in some demos</li> </ul>"},{"location":"concepts/#demo-deep-dive","title":"Demo Deep Dive","text":""},{"location":"concepts/#1-query-system-demo","title":"1. Query System Demo","text":"<p>What it demonstrates: - Fluent query API for complex entity searches - Cached queries for performance - Multiple filter conditions (<code>With</code>, <code>Without</code>, <code>Where</code>) - Real-time entity statistics</p> <p>Controls: - SPACE - Spawn entities - C - Clear entities - ESC - Return to menu</p> <p>Key Code:</p> <pre><code>// Find low-health enemies near the player\nvar weakEnemies = _world.Query()\n    .With&lt;HealthComponent&gt;()\n    .With&lt;TransformComponent&gt;()\n    .Without&lt;DeadComponent&gt;()\n    .WithTag(\"Enemy\")\n    .Where(e =&gt; \n    {\n        var health = e.GetComponent&lt;HealthComponent&gt;();\n        var transform = e.GetComponent&lt;TransformComponent&gt;();\n        var distance = Vector2.Distance(transform.Position, playerPos);\n\n        return health.CurrentHealth &lt; 50 &amp;&amp; distance &lt; 200f;\n    })\n    .Execute();\n\n// Cached queries (no allocation!)\nvar movingEntities = _world.CreateCachedQuery&lt;TransformComponent, VelocityComponent&gt;();\nforeach (var (transform, velocity) in movingEntities)\n{\n    transform.Position += velocity.Velocity * deltaTime;\n}</code></pre>"},{"location":"concepts/#2-particle-system-demo","title":"2. Particle System Demo","text":"<p>What it demonstrates: - NEW: Particle textures with custom sprites - NEW: Rotation (start, end, rotation speed) - NEW: Trail effects with configurable length - NEW: Blend modes (additive, alpha, none) - NEW: 7 emitter shapes (point, circle, ring, box, cone, line, burst) - Object pooling for 10,000+ particles at 60 FPS - Performance monitoring</p> <p>Controls: - 1-7 - Change emitter shape - T - Toggle particle textures - R - Toggle rotation - L - Toggle trails - B - Cycle blend modes - SPACE - Toggle emission - ESC - Return to menu</p> <p>Key Code:</p> <pre><code>// Create advanced particle emitter\nvar emitter = entity.AddComponent&lt;ParticleEmitterComponent&gt;();\n\n// NEW: Particle textures\nemitter.TexturePath = \"assets/particles/fire.png\";\nemitter.TextureScaleMode = TextureScaleMode.Nearest;\n\n// NEW: Rotation\nemitter.StartRotation = 0f;\nemitter.EndRotation = MathF.PI * 2;\nemitter.RotationSpeed = 2f;\n\n// NEW: Trails\nemitter.TrailEnabled = true;\nemitter.TrailLength = 10;\nemitter.TrailColor = new Color(255, 100, 0, 128);\n\n// NEW: Blend modes\nemitter.BlendMode = BlendMode.Additive; // Fire/explosions\n\n// NEW: Emitter shapes\nemitter.EmitterShape = EmitterShape.Cone;\nemitter.ConeAngle = MathF.PI / 4;\n\n// Standard properties\nemitter.EmissionRate = 100f;\nemitter.MaxParticles = 500;\nemitter.ParticleLifetime = 2f;\nemitter.StartColor = new Color(255, 200, 0, 255);\nemitter.EndColor = new Color(255, 50, 0, 0);</code></pre>"},{"location":"concepts/#3-texture-atlas-demo-new","title":"3. Texture Atlas Demo (NEW)","text":"<p>What it demonstrates: - Runtime texture packing with intelligent bin packing - Massive draw call reduction (90-99%) - Before/after performance comparison - Visual atlas preview - Real-time draw call monitoring</p> <p>Controls: - SPACE - Toggle atlas usage - 1-3 - Change sprite count (100/500/1000) - F3 - Toggle performance overlay - A - Show atlas texture - ESC - Return to menu</p> <p>Performance Impact:</p> Sprite Count Without Atlas With Atlas Draw Call Reduction 100 sprites 10-15 calls 1 call 90-93% 500 sprites 40-50 calls 1-2 calls 96-98% 1000 sprites 80-100 calls 1-2 calls 98-99% <p>Key Code:</p> <pre><code>// Load individual textures\nvar textures = new List&lt;ITexture&gt;();\nfor (int i = 0; i &lt; 10; i++)\n{\n    textures.Add(await _textureLoader.LoadTextureAsync($\"assets/sprite{i}.png\"));\n}\n\n// Build atlas at runtime\nvar atlas = await AtlasBuilder.BuildAtlasAsync(\n    _renderer,\n    _textureLoader,\n    textures,\n    padding: 2,      // Prevent texture bleeding\n    maxSize: 2048    // Max atlas dimension\n);\n\n// Draw using atlas (automatic batching)\nvar region = atlas.GetRegion(textures[0]);\n_renderer.DrawTexture(\n    atlas.AtlasTexture,\n    region.SourceRect.X, region.SourceRect.Y,\n    region.SourceRect.Width, region.SourceRect.Height,\n    x, y, width, height\n);\n\n// Result: All sprites drawn in 1-2 draw calls!\nLogger.LogInfo($\"Draw calls reduced from {textures.Count} to {atlas.RegionCount}\");</code></pre> <p>Visual Feedback: - Shows before/after FPS comparison - Real-time draw call counter - Visual atlas texture preview - Bin packing efficiency percentage</p>"},{"location":"concepts/#4-spatial-audio-demo-new","title":"4. Spatial Audio Demo (NEW)","text":"<p>What it demonstrates: - 2D spatial audio with distance-based volume attenuation - Stereo panning based on horizontal position - Multiple falloff curves (linear, quadratic, custom) - Real-time audio visualization - ECS integration with audio sources and listeners</p> <p>Controls: - WASD - Move player (audio listener) - 1-3 - Toggle sound sources - SPACE - Trigger one-shot explosion sound - +/- - Adjust master volume - ESC - Return to menu</p> <p>Audio Sources: - Left (Beep) - Continuous looping sound, linear falloff - Right (Explosion) - One-shot triggered sound, quadratic falloff - Top (Ambient) - Background ambience, partial stereo</p> <p>Visual Feedback: - Distance circles (min/max audio range) - Connection lines showing distance - Real-time volume/pan values - Color-coded audio sources</p> <p>Key Code:</p> <pre><code>// Create audio listener (player)\nvar player = _world.CreateEntity(\"Player\");\nvar listener = player.AddComponent&lt;AudioListenerComponent&gt;();\nlistener.GlobalSpatialVolume = 1.0f;\n\n// Create spatial audio source\nvar enemy = _world.CreateEntity(\"Enemy\");\nvar audioSource = enemy.AddComponent&lt;AudioSourceComponent&gt;();\naudioSource.SoundEffect = enemySound;\naudioSource.EnableSpatialAudio = true;\n\n// Configure distance attenuation\naudioSource.MinDistance = 100f;  // Full volume within 100 pixels\naudioSource.MaxDistance = 500f;  // Silent beyond 500 pixels\naudioSource.RolloffFactor = 1.0f;  // 1.0 = linear, 2.0 = quadratic\n\n// Configure stereo panning\naudioSource.SpatialBlend = 1.0f;  // 0.0 = mono, 1.0 = full stereo\n\n// Start playing\naudioSource.Loop = true;\naudioSource.LoopCount = -1;\naudioSource.PlayOnEnable = true;\n\n// AudioSystem automatically updates spatial audio every frame!\n// Volume and panning adjust as entities move</code></pre> <p>Distance Attenuation: <pre><code>Linear (RolloffFactor = 1.0):\nVolume = 1.0 at MinDistance, 0.0 at MaxDistance\n\nQuadratic (RolloffFactor = 2.0):\nDrops quickly near source, gradually far away</code></pre></p> <p>Stereo Panning: <pre><code>SpatialBlend = 0.0: Mono (center)\nSpatialBlend = 0.5: Partial stereo\nSpatialBlend = 1.0: Full stereo (clear left/right)</code></pre></p>"},{"location":"concepts/#5-collision-detection-demo","title":"5. Collision Detection Demo","text":"<p>What it demonstrates: - AABB (box) and circle colliders - Collision detection with <code>CollisionSystem</code> - Physics response: bounce, slide, push - Dynamic vs static objects - Trigger colliders (collectibles) - Debug visualization</p> <p>Controls: - WASD - Move player - R - Kick ball (when nearby) - F1 - Toggle collider visualization - F2 - Toggle velocity vectors - SPACE - Reset scene - ESC - Return to menu</p> <p>Key Code:</p> <pre><code>// Player slides along walls\nvar newPosition = _playerPosition + moveVector;\n_playerCollider.Position = newPosition;\n\nvar collisions = _collisionSystem.GetCollisions(_playerCollider);\nif (collisions.Any(c =&gt; _walls.Contains(c)))\n{\n    // Try sliding along X axis\n    var slideX = _playerPosition + new Vector2(moveVector.X, 0);\n    _playerCollider.Position = slideX;\n\n    if (!_collisionSystem.GetCollisions(_playerCollider).Any())\n    {\n        _playerPosition = slideX;\n    }\n}\n\n// Ball bounces with physics\n_ballVelocity = CollisionResponse.Bounce(_ballVelocity, penetration, 0.7f);</code></pre>"},{"location":"concepts/#6-scene-transitions-demo","title":"6. Scene Transitions Demo","text":"<p>What it demonstrates: - <code>FadeTransition</code> between scenes - Custom loading screens with progress bars - Async scene loading - Scene chaining (A \u2192 B \u2192 C \u2192 A) - Transition customization (duration, color)</p> <p>Controls: - ENTER - Go to next scene - Number keys - Jump to specific scene - ESC - Return to menu</p> <p>Key Code:</p> <pre><code>// Fade transition\nawait _sceneManager.LoadSceneAsync&lt;SceneB&gt;(\n    new FadeTransition(duration: 0.5f, color: Color.Black)\n);\n\n// Custom loading screen\npublic class CustomLoadingScreen : LoadingScene\n{\n    protected override void OnRender(GameTime gameTime)\n    {\n        _renderer.DrawText($\"Loading... {Progress:P0}\", 500, 300, Color.White);\n        _renderer.DrawRectangleFilled(400, 350, Progress * 400, 20, Color.Green);\n    }\n}\n\nawait _sceneManager.LoadSceneAsync&lt;GameScene&gt;(\n    loadingScreen: new CustomLoadingScreen(),\n    transition: new FadeTransition(0.5f, Color.Black)\n);</code></pre>"},{"location":"concepts/#7-ui-components-demo","title":"7. UI Components Demo","text":"<p>What it demonstrates: - Complete UI library - All 15+ components - Buttons, labels, text inputs - Sliders, checkboxes, radio buttons - Progress bars, dropdowns - Tab containers, scroll views - Dialogs with multiple buttons - Tooltips on hover - Input layer management</p> <p>Controls: - Mouse - Interact with all UI elements - TAB - Navigate between inputs - ESC - Return to menu</p> <p>Components Showcased:</p> Component Demo Feature <code>UILabel</code> Title, status messages <code>UIButton</code> Click counter, actions <code>UITextInput</code> Name entry with placeholder <code>UISlider</code> Volume control (0-100) <code>UIProgressBar</code> Health bar with +/- buttons <code>UIDropdown</code> Graphics quality selector <code>UICheckbox</code> Sound/VSync toggles <code>UIRadioButton</code> Difficulty selection <code>UITabContainer</code> Settings organization <code>UIScrollView</code> 25-item scrollable list <code>UIDialog</code> Confirmation popups <code>UITooltip</code> Hover help text <code>UIPanel</code> Visual grouping <p>Key Code:</p> <pre><code>// Button with event\nvar button = new UIButton(\"Click Me!\", pos, size);\nbutton.OnClick += () =&gt; Logger.LogInformation(\"Clicked!\");\n_uiCanvas.Add(button);\n\n// Slider with value display\nvar slider = new UISlider(pos, size)\n{\n    MinValue = 0f,\n    MaxValue = 100f,\n    Value = 75f,\n    ShowValue = true,\n    Tooltip = new UITooltip(\"Adjust volume\")\n};\nslider.OnValueChanged += (value) =&gt; Logger.LogDebug(\"Volume: {Volume}\", value);\n_uiCanvas.Add(slider);\n\n// Dialog with multiple buttons\nvar dialog = new UIDialog(\"Confirm\", \"Are you sure?\", new Vector2(400, 250));\ndialog.AddButton(\"Yes\", () =&gt; dialog.Visible = false);\ndialog.AddButton(\"No\", () =&gt; dialog.Visible = false);\n_uiCanvas.Add(dialog);</code></pre>"},{"location":"concepts/#8-manual-control-demo","title":"8. Manual Control Demo","text":"<p>What it demonstrates: - Opt-out of automatic execution - Manual pipeline control - Manual frame management - When and why to use manual control - Power user scenarios (fixed timestep, conditional execution)</p> <p>Controls: - ESC - Return to menu</p> <p>Key Code:</p> <pre><code>public class ManualControlScene : Scene\n{\n    public override bool EnableLifecycleHooks =&gt; false; // Disable automatic execution\n    public override bool EnableAutomaticFrameManagement =&gt; false; // Full manual control\n\n    protected override void OnUpdate(GameTime gameTime)\n    {\n        // You control when systems run\n        _updatePipeline.Execute(gameTime);\n        _world.Update(gameTime);\n    }\n\n    protected override void OnRender(GameTime gameTime)\n    {\n        // You control frame management\n        _renderer.Clear(Color.Black);\n        _renderer.BeginFrame();\n\n        _renderPipeline.Execute(_renderer);\n\n        _renderer.EndFrame();\n    }\n}</code></pre> <p>See Lifecycle Hooks Guide for full documentation.</p>"},{"location":"concepts/#project-structure","title":"Project Structure","text":"<pre><code>FeatureDemos/\n\u251c\u2500\u2500 Scenes/\n\u2502   \u251c\u2500\u2500 MainMenuScene.cs               # Interactive demo selector\n\u2502   \u251c\u2500\u2500 DemoSceneBase.cs               # Shared base class\n\u2502   \u251c\u2500\u2500 ECS/\n\u2502   \u2502   \u251c\u2500\u2500 QueryDemoScene.cs          # Query system showcase\n\u2502   \u2502   \u2514\u2500\u2500 ParticleDemoScene.cs       # Particle effects (enhanced v0.8.0)\n\u2502   \u251c\u2500\u2500 Rendering/\n\u2502   \u2502   \u2514\u2500\u2500 TextureAtlasDemoScene.cs   # NEW: Texture atlas demo\n\u2502   \u251c\u2500\u2500 Audio/\n\u2502   \u2502   \u2514\u2500\u2500 SpatialAudioDemoScene.cs   # NEW: Spatial audio demo\n\u2502   \u251c\u2500\u2500 Collision/\n\u2502   \u2502   \u2514\u2500\u2500 CollisionDemoScene.cs      # Physics demo\n\u2502   \u251c\u2500\u2500 Transitions/\n\u2502   \u2502   \u251c\u2500\u2500 TransitionDemoScene.cs     # Transition showcase\n\u2502   \u2502   \u251c\u2500\u2500 SceneA.cs                  # Chain scene A\n\u2502   \u2502   \u251c\u2500\u2500 SceneB.cs                  # Chain scene B\n\u2502   \u2502   \u2514\u2500\u2500 SceneC.cs                  # Chain scene C\n\u2502   \u251c\u2500\u2500 UI/\n\u2502   \u2502   \u2514\u2500\u2500 UIDemoScene.cs             # Complete UI showcase\n\u2502   \u2514\u2500\u2500 Advanced/\n\u2502       \u2514\u2500\u2500 ManualControlScene.cs      # Power user demo\n\u251c\u2500\u2500 Program.cs                          # Entry point\n\u251c\u2500\u2500 gamesettings.json                   # Configuration\n\u2514\u2500\u2500 FeatureDemos.csproj                 # Project file</code></pre>"},{"location":"concepts/#configuration","title":"Configuration","text":"<pre><code>{\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Information\",\n      \"Brine2D\": \"Debug\"\n    }\n  },\n  \"Rendering\": {\n    \"WindowTitle\": \"Brine2D Feature Demos\",\n    \"WindowWidth\": 1280,\n    \"WindowHeight\": 720,\n    \"VSync\": true,\n    \"Backend\": \"GPU\"\n  }\n}</code></pre>"},{"location":"concepts/#dependency-injection-setup","title":"Dependency Injection Setup","text":"<p>FeatureDemos demonstrates complete service configuration:</p> <pre><code>var builder = GameApplication.CreateBuilder(args);\n\n// Core services\nbuilder.Services.AddSDL3Rendering(options =&gt;\n{\n    builder.Configuration.GetSection(\"Rendering\").Bind(options);\n});\nbuilder.Services.AddInputLayerManager().AddSDL3Input();\nbuilder.Services.AddSDL3Audio();\n\n// ECS and systems\nbuilder.Services.AddCollisionSystem();\nbuilder.Services.AddUICanvas();\n\n// Register all demo scenes\nbuilder.Services.AddScene&lt;MainMenuScene&gt;();\nbuilder.Services.AddScene&lt;QueryDemoScene&gt;();\nbuilder.Services.AddScene&lt;ParticleDemoScene&gt;();\nbuilder.Services.AddScene&lt;TextureAtlasDemoScene&gt;();  // NEW\nbuilder.Services.AddScene&lt;SpatialAudioDemoScene&gt;();  // NEW\nbuilder.Services.AddScene&lt;CollisionDemoScene&gt;();\nbuilder.Services.AddScene&lt;TransitionDemoScene&gt;();\nbuilder.Services.AddScene&lt;UIDemoScene&gt;();\nbuilder.Services.AddScene&lt;ManualControlScene&gt;();\n\nvar game = builder.Build();\nawait game.RunAsync&lt;MainMenuScene&gt;();</code></pre>"},{"location":"concepts/#learning-path","title":"Learning Path","text":"<p>We recommend exploring the demos in this order:</p> <ol> <li>Query System - Understand ECS queries (if using ECS)</li> <li>Texture Atlas - Learn performance optimization with sprite packing</li> <li>Particle System - Master advanced visual effects</li> <li>Spatial Audio - Add immersive positional sound</li> <li>Collision Detection - Learn physics and collision response</li> <li>UI Components - Master the UI framework</li> <li>Scene Transitions - Build polished scene changes</li> <li>Manual Control - Advanced power user techniques</li> </ol>"},{"location":"concepts/#using-demos-as-templates","title":"Using Demos as Templates","text":"<p>The demo code is production-ready and designed to be copied:</p> <ol> <li>Copy a scene class - Use as a starting point</li> <li>Modify for your game - Change colors, sizes, behaviors</li> <li>Extract patterns - Query builders, UI layouts, collision response, audio setups</li> <li>Build on top - Extend with your own features</li> </ol>"},{"location":"concepts/#troubleshooting","title":"Troubleshooting","text":""},{"location":"concepts/#menu-doesnt-appear","title":"Menu doesn't appear?","text":"<ul> <li>Check that <code>MainMenuScene</code> is registered</li> <li>Verify <code>game.RunAsync&lt;MainMenuScene&gt;()</code> is called</li> </ul>"},{"location":"concepts/#demos-run-slowly","title":"Demos run slowly?","text":"<ul> <li>Press F3 to check FPS and draw calls</li> <li>Ensure VSync is enabled in <code>gamesettings.json</code></li> <li>Verify GPU backend is being used (not Legacy)</li> </ul>"},{"location":"concepts/#texture-atlas-demo-shows-no-improvement","title":"Texture Atlas Demo shows no improvement?","text":"<ul> <li>Make sure multiple unique textures are being used</li> <li>Check that sprites aren't all using the same texture</li> <li>Verify atlas is actually being created (check logs)</li> </ul>"},{"location":"concepts/#spatial-audio-demo-is-silent","title":"Spatial Audio Demo is silent?","text":"<ul> <li>Ensure sound files exist in <code>assets/sounds/</code> folder</li> <li>Check master volume (use +/- keys)</li> <li>Verify audio source <code>IsEnabled = true</code></li> <li>Move player close to sound sources</li> </ul>"},{"location":"concepts/#particles-dont-show-textures","title":"Particles don't show textures?","text":"<ul> <li>Check that <code>TexturePath</code> is set on emitter</li> <li>Verify texture files exist in <code>assets/particles/</code></li> <li>Ensure <code>TextureScaleMode</code> is set appropriately</li> </ul>"},{"location":"concepts/#performance-tips","title":"Performance Tips","text":""},{"location":"concepts/#texture-atlas-demo","title":"Texture Atlas Demo","text":"<ul> <li>Keep atlas size \u2264 2048x2048 for compatibility</li> <li>Use 2-4px padding between sprites</li> <li>Pack sprites that render together</li> </ul>"},{"location":"concepts/#spatial-audio-demo","title":"Spatial Audio Demo","text":"<ul> <li>Disable spatial audio for UI/music sounds</li> <li>Use appropriate <code>MaxDistance</code> values</li> <li>Limit concurrent spatial audio sources to &lt; 50</li> </ul>"},{"location":"concepts/#particle-system-demo","title":"Particle System Demo","text":"<ul> <li>Keep <code>MaxParticles</code> \u2264 500 per emitter</li> <li>Use trails sparingly (they multiply particle count)</li> <li>Pack particle textures into an atlas</li> </ul>"},{"location":"concepts/#see-also","title":"See Also","text":"<ul> <li>Guides - Detailed feature documentation</li> <li>Tutorials - Step-by-step learning</li> <li>API Reference - Complete API docs</li> <li>What's New - v0.8.0-beta features</li> </ul> <p>Ready to explore? Run the demos and start building your own games with Brine2D!</p>"},{"location":"concepts/architecture/","title":"Architecture","text":"<p>Brine2D follows a layered, modular architecture inspired by ASP.NET Core. This design promotes separation of concerns, testability, and extensibility.</p>"},{"location":"concepts/architecture/#architectural-overview","title":"Architectural Overview","text":"<pre><code>graph TB\n    subgraph \"Application Layer\"\n        APP[\"GameApplication\"]\n        BUILDER[\"GameApplicationBuilder\"]\n    end\n\n    subgraph \"Engine Layer\"\n        ENGINE[\"GameEngine\"]\n        LOOP[\"GameLoop\"]\n        SCENEMGR[\"SceneManager\"]\n        CONTEXT[\"GameContext\"]\n    end\n\n    subgraph \"Core Abstractions\"\n        ISCENE[\"IScene\"]\n        IRENDERER[\"IRenderer\"]\n        IINPUT[\"IInputService\"]\n        IAUDIO[\"IAudioService\"]\n    end\n\n    subgraph \"SDL3 Implementations\"\n        SDL_RENDER[\"SDL3Renderer / SDL3GPURenderer\"]\n        SDL_INPUT[\"SDL3InputService\"]\n        SDL_AUDIO[\"SDL3AudioService\"]\n    end\n\n    subgraph \"ECS Layer\"\n        ECS[\"EntityWorld\"]\n        SYSTEMS[\"Systems (Rendering, Audio, etc.)\"]\n    end\n\n    subgraph \"Game Systems\"\n        COLLISION[\"CollisionSystem\"]\n        ANIMATION[\"SpriteAnimator\"]\n        TILEMAP[\"TilemapRenderer\"]\n        UI[\"UICanvas\"]\n    end\n\n    subgraph \"Your Game\"\n        SCENES[\"MenuScene, GameScene, etc.\"]\n    end\n\n    APP --&gt; ENGINE\n    BUILDER --&gt; APP\n    ENGINE --&gt; LOOP\n    ENGINE --&gt; SCENEMGR\n    ENGINE --&gt; CONTEXT\n\n    SCENEMGR --&gt; ISCENE\n    ISCENE --&gt; SCENES\n\n    ENGINE --&gt; IRENDERER\n    ENGINE --&gt; IINPUT\n    ENGINE --&gt; IAUDIO\n\n    IRENDERER --&gt; SDL_RENDER\n    IINPUT --&gt; SDL_INPUT\n    IAUDIO --&gt; SDL_AUDIO\n\n    SCENES --&gt; ECS\n    ECS --&gt; SYSTEMS\n\n    SCENES --&gt; COLLISION\n    SCENES --&gt; ANIMATION\n    SCENES --&gt; TILEMAP\n    SCENES --&gt; UI\n\n    style APP fill:#1e3a5f,stroke:#569cd6,stroke-width:2px,color:#fff\n    style BUILDER fill:#1e3a5f,stroke:#569cd6,stroke-width:2px,color:#fff\n    style ENGINE fill:#2d5016,stroke:#4ec9b0,stroke-width:2px,color:#fff\n    style LOOP fill:#2d5016,stroke:#4ec9b0,stroke-width:2px,color:#fff\n    style SCENEMGR fill:#2d5016,stroke:#4ec9b0,stroke-width:2px,color:#fff\n    style CONTEXT fill:#2d5016,stroke:#4ec9b0,stroke-width:2px,color:#fff\n    style ISCENE fill:#3d3d2a,stroke:#dcdcaa,stroke-width:2px,color:#fff\n    style IRENDERER fill:#3d3d2a,stroke:#dcdcaa,stroke-width:2px,color:#fff\n    style IINPUT fill:#3d3d2a,stroke:#dcdcaa,stroke-width:2px,color:#fff\n    style IAUDIO fill:#3d3d2a,stroke:#dcdcaa,stroke-width:2px,color:#fff\n    style SDL_RENDER fill:#4a2d4a,stroke:#c586c0,stroke-width:2px,color:#fff\n    style SDL_INPUT fill:#4a2d4a,stroke:#c586c0,stroke-width:2px,color:#fff\n    style SDL_AUDIO fill:#4a2d4a,stroke:#c586c0,stroke-width:2px,color:#fff\n    style ECS fill:#3d4a1f,stroke:#b5ce78,stroke-width:2px,color:#fff\n    style SYSTEMS fill:#3d4a1f,stroke:#b5ce78,stroke-width:2px,color:#fff\n    style COLLISION fill:#4a3d1f,stroke:#ce9178,stroke-width:2px,color:#fff\n    style ANIMATION fill:#4a3d1f,stroke:#ce9178,stroke-width:2px,color:#fff\n    style TILEMAP fill:#4a3d1f,stroke:#ce9178,stroke-width:2px,color:#fff\n    style UI fill:#4a3d1f,stroke:#ce9178,stroke-width:2px,color:#fff\n    style SCENES fill:#264f78,stroke:#4fc1ff,stroke-width:2px,color:#fff</code></pre>"},{"location":"concepts/architecture/#module-structure","title":"Module Structure","text":"<p>Brine2D is organized into distinct modules, each with a specific responsibility:</p>"},{"location":"concepts/architecture/#core-modules","title":"Core Modules","text":"Module Purpose Key Types Brine2D.Core Core abstractions and interfaces <code>IScene</code>, <code>GameTime</code>, <code>EventBus</code> Brine2D.Engine Game loop and scene management <code>GameEngine</code>, <code>GameLoop</code>, <code>SceneManager</code> Brine2D.Hosting Application hosting (ASP.NET-like) <code>GameApplication</code>, <code>GameApplicationBuilder</code>"},{"location":"concepts/architecture/#ecs-modules","title":"ECS Modules","text":"Module Purpose Key Types Brine2D.ECS Entity Component System <code>EntityWorld</code>, <code>Entity</code>, <code>Component</code>, <code>ISystem</code> Brine2D.Rendering.ECS ECS rendering systems <code>SpriteRenderingSystem</code>, <code>ParticleSystem</code>, <code>CameraSystem</code> Brine2D.Input.ECS ECS input systems <code>PlayerControllerSystem</code> Brine2D.Audio.ECS ECS audio systems <code>AudioSystem</code>, <code>AudioSourceComponent</code>, <code>AudioListenerComponent</code>"},{"location":"concepts/architecture/#rendering-modules","title":"Rendering Modules","text":"Module Purpose Key Types Brine2D.Rendering Rendering abstractions and utilities <code>IRenderer</code>, <code>ICamera</code>, <code>Color</code>, <code>TextureAtlas</code>, <code>AtlasBuilder</code> Brine2D.Rendering.SDL SDL3 rendering implementation <code>SDL3Renderer</code>, <code>SDL3GPURenderer</code>, <code>SDL3TextureLoader</code>, <code>SpriteBatcher</code> Brine2D.Rendering.ECS ECS rendering systems <code>SpriteRenderingSystem</code>, <code>ParticleSystem</code>"},{"location":"concepts/architecture/#input-modules","title":"Input Modules","text":"Module Purpose Key Types Brine2D.Input Input abstractions <code>IInputService</code>, <code>Keys</code>, <code>MouseButton</code>, <code>InputLayerManager</code> Brine2D.Input.SDL SDL3 input implementation <code>SDL3InputService</code>"},{"location":"concepts/architecture/#audio-modules","title":"Audio Modules","text":"Module Purpose Key Types Brine2D.Audio Audio abstractions <code>IAudioService</code>, <code>ISoundEffect</code>, <code>IMusic</code> Brine2D.Audio.SDL SDL3_mixer implementation <code>SDL3AudioService</code> Brine2D.Audio.ECS ECS audio systems <code>AudioSystem</code>, <code>AudioSourceComponent</code>, <code>AudioListenerComponent</code>"},{"location":"concepts/architecture/#game-systems-modules","title":"Game Systems Modules","text":"Module Purpose Key Types Brine2D.Core.Collision Collision detection system <code>CollisionSystem</code>, <code>BoxCollider</code>, <code>CircleCollider</code> Brine2D.Core.Animation Animation system <code>SpriteAnimator</code>, <code>AnimationClip</code> Brine2D.Core.Tilemap Tilemap rendering <code>Tilemap</code>, <code>TilemapRenderer</code>, <code>TmjLoader</code> Brine2D.UI UI framework <code>UICanvas</code>, <code>UIButton</code>, <code>UISlider</code>, <code>UITextInput</code>"},{"location":"concepts/architecture/#dependency-flow","title":"Dependency Flow","text":"<pre><code>graph LR\n    subgraph \"Abstractions (Interfaces)\"\n        CORE[\"Brine2D.Core\"]\n        RENDERING[\"Brine2D.Rendering\"]\n        INPUT[\"Brine2D.Input\"]\n        AUDIO[\"Brine2D.Audio\"]\n        ECS[\"Brine2D.ECS\"]\n    end\n\n    subgraph \"Implementations\"\n        SDL_RENDER[\"Brine2D.Rendering.SDL\"]\n        SDL_INPUT[\"Brine2D.Input.SDL\"]\n        SDL_AUDIO[\"Brine2D.Audio.SDL\"]\n    end\n\n    subgraph \"ECS Bridges\"\n        RENDER_ECS[\"Brine2D.Rendering.ECS\"]\n        INPUT_ECS[\"Brine2D.Input.ECS\"]\n        AUDIO_ECS[\"Brine2D.Audio.ECS\"]\n    end\n\n    subgraph \"Application\"\n        HOSTING[\"Brine2D.Hosting\"]\n        ENGINE[\"Brine2D.Engine\"]\n        GAME[\"Your Game\"]\n    end\n\n    SDL_RENDER --&gt; RENDERING\n    SDL_INPUT --&gt; INPUT\n    SDL_AUDIO --&gt; AUDIO\n\n    RENDER_ECS --&gt; RENDERING\n    RENDER_ECS --&gt; ECS\n    INPUT_ECS --&gt; INPUT\n    INPUT_ECS --&gt; ECS\n    AUDIO_ECS --&gt; AUDIO\n    AUDIO_ECS --&gt; ECS\n\n    ENGINE --&gt; CORE\n    HOSTING --&gt; ENGINE\n    HOSTING --&gt; RENDERING\n    HOSTING --&gt; INPUT\n    HOSTING --&gt; AUDIO\n\n    GAME --&gt; HOSTING\n    GAME --&gt; CORE\n    GAME --&gt; RENDERING\n    GAME --&gt; INPUT\n    GAME --&gt; AUDIO\n    GAME --&gt; ECS\n\n    style CORE fill:#3d3d2a,stroke:#dcdcaa,stroke-width:2px,color:#fff\n    style RENDERING fill:#3d3d2a,stroke:#dcdcaa,stroke-width:2px,color:#fff\n    style INPUT fill:#3d3d2a,stroke:#dcdcaa,stroke-width:2px,color:#fff\n    style AUDIO fill:#3d3d2a,stroke:#dcdcaa,stroke-width:2px,color:#fff\n    style ECS fill:#3d3d2a,stroke:#dcdcaa,stroke-width:2px,color:#fff\n    style SDL_RENDER fill:#4a2d4a,stroke:#c586c0,stroke-width:2px,color:#fff\n    style SDL_INPUT fill:#4a2d4a,stroke:#c586c0,stroke-width:2px,color:#fff\n    style SDL_AUDIO fill:#4a2d4a,stroke:#c586c0,stroke-width:2px,color:#fff\n    style RENDER_ECS fill:#3d4a1f,stroke:#b5ce78,stroke-width:2px,color:#fff\n    style INPUT_ECS fill:#3d4a1f,stroke:#b5ce78,stroke-width:2px,color:#fff\n    style AUDIO_ECS fill:#3d4a1f,stroke:#b5ce78,stroke-width:2px,color:#fff\n    style HOSTING fill:#1e3a5f,stroke:#569cd6,stroke-width:2px,color:#fff\n    style ENGINE fill:#2d5016,stroke:#4ec9b0,stroke-width:2px,color:#fff\n    style GAME fill:#264f78,stroke:#4fc1ff,stroke-width:2px,color:#fff</code></pre> <p>Key Principle: Abstractions (interfaces) never depend on implementations. Implementations depend on abstractions. This enables pluggable backends (SDL3, MonoGame, custom implementations).</p>"},{"location":"concepts/architecture/#layer-responsibilities","title":"Layer Responsibilities","text":""},{"location":"concepts/architecture/#1-application-layer-brine2dhosting","title":"1. Application Layer (<code>Brine2D.Hosting</code>)","text":"<p>Responsibility: Bootstrap and host the game application</p> <p>Key Classes: - <code>GameApplication</code> - Main application host - <code>GameApplicationBuilder</code> - Fluent API for configuration</p> <p>Pattern: Builder Pattern (like ASP.NET's <code>WebApplicationBuilder</code>)</p> <pre><code>var builder = GameApplication.CreateBuilder(args);\n\n// Configure services\nbuilder.Services.AddSDL3Rendering();\nbuilder.Services.AddSDL3Input();\nbuilder.Services.AddScene&lt;GameScene&gt;();\n\n// Build and run\nvar game = builder.Build();\nawait game.RunAsync&lt;GameScene&gt;();</code></pre>"},{"location":"concepts/architecture/#2-engine-layer-brine2dengine","title":"2. Engine Layer (<code>Brine2D.Engine</code>)","text":"<p>Responsibility: Coordinate game systems and manage the game loop</p> <p>Key Classes: - <code>GameEngine</code> - Initializes and coordinates subsystems - <code>GameLoop</code> - Manages update/render cycles - <code>SceneManager</code> - Loads and manages scenes - <code>GameContext</code> - Shared game state</p> <p>Pattern: Mediator Pattern (coordinates subsystems)</p> <pre><code>public class GameEngine : IGameEngine\n{\n    public async Task InitializeAsync(CancellationToken cancellationToken)\n    {\n        // Initialize renderer\n        var renderer = _serviceProvider.GetService&lt;IRenderer&gt;();\n        await renderer?.InitializeAsync(cancellationToken);\n\n        // Initialize other subsystems...\n    }\n}</code></pre>"},{"location":"concepts/architecture/#3-core-layer-brine2dcore","title":"3. Core Layer (<code>Brine2D.Core</code>)","text":"<p>Responsibility: Define core abstractions and shared types</p> <p>Key Interfaces: - <code>IScene</code> - Game scene abstraction - <code>IGameLoop</code> - Game loop contract - <code>IGameContext</code> - Shared game state - <code>ISceneManager</code> - Scene management</p> <p>Key Types: - <code>EventBus</code> - Global event system (moved from ECS in v0.7.0)</p> <p>Pattern: Interface Segregation (small, focused interfaces)</p> <pre><code>public interface IScene\n{\n    void Initialize();\n    Task LoadAsync(CancellationToken cancellationToken);\n    void Update(GameTime gameTime);\n    void Render(GameTime gameTime);\n    Task UnloadAsync(CancellationToken cancellationToken);\n}</code></pre>"},{"location":"concepts/architecture/#4-rendering-layer","title":"4. Rendering Layer","text":""},{"location":"concepts/architecture/#abstractions-brine2drendering","title":"Abstractions (<code>Brine2D.Rendering</code>)","text":"<p>Key Interfaces: - <code>IRenderer</code> - Rendering operations - <code>ITextureLoader</code> - Texture management - <code>ICamera</code> - Camera abstraction - <code>IFontLoader</code> - Font loading</p> <p>Key Types (Data &amp; Utilities): - <code>Color</code> - RGBA color struct - <code>Camera2D</code> - 2D camera with zoom/rotation - <code>RenderingOptions</code> - Configuration options - <code>TextureAtlas</code> - Runtime sprite packing utility (NEW in v0.8.0) - <code>AtlasBuilder</code> - Intelligent bin packing algorithm (NEW in v0.8.0)</p>"},{"location":"concepts/architecture/#implementation-brine2drenderingsdl","title":"Implementation (<code>Brine2D.Rendering.SDL</code>)","text":"<p>Key Classes: - <code>SDL3Renderer</code> - Legacy SDL3 renderer - <code>SDL3GPURenderer</code> - Modern GPU renderer - <code>SDL3TextureLoader</code> - SDL3 texture loading - <code>SDL3FontLoader</code> - SDL3_ttf font loading - <code>SpriteBatcher</code> - Sprite batching utility with rotation support (Enhanced in v0.8.0)</p> <p>Pattern: Strategy Pattern (swappable renderers)</p> <pre><code>// Choose renderer at startup\nbuilder.Services.AddSDL3Rendering(options =&gt;\n{\n    options.Backend = GraphicsBackend.GPU; // or LegacyRenderer\n});</code></pre> <p>Rendering Utilities:</p> <p>The rendering layer includes utilities that optimize rendering performance:</p> <ul> <li>SpriteBatcher - Groups sprites by texture to reduce draw calls</li> <li>TextureAtlas - Packs multiple textures into one to eliminate texture switching</li> <li>AtlasBuilder - Intelligently arranges sprites using bin packing algorithm</li> </ul> <pre><code>// Using texture atlas for performance\nvar atlas = await AtlasBuilder.BuildAtlasAsync(\n    _renderer,\n    _textureLoader,\n    textures,\n    padding: 2,\n    maxSize: 2048\n);\n\n// Result: 100 sprites \u2192 1 draw call (90-99% reduction)</code></pre>"},{"location":"concepts/architecture/#ecs-bridge-brine2drenderingecs","title":"ECS Bridge (<code>Brine2D.Rendering.ECS</code>)","text":"<p>Key Systems: - <code>SpriteRenderingSystem</code> - Renders sprite components - <code>ParticleSystem</code> - Advanced particle effects (Enhanced in v0.8.0) - <code>CameraSystem</code> - Camera follow behavior</p> <p>New in v0.8.0: - Particle textures with custom sprites - Rotation (start, end, rotation speed) - Trail effects with configurable length - Blend modes (additive, alpha, none) - 7 emitter shapes (point, circle, ring, box, cone, line, burst)</p>"},{"location":"concepts/architecture/#5-input-layer","title":"5. Input Layer","text":""},{"location":"concepts/architecture/#abstractions-brine2dinput","title":"Abstractions (<code>Brine2D.Input</code>)","text":"<p>Key Interfaces: - <code>IInputService</code> - Input polling - <code>IInputLayer</code> - Layer-based input routing</p> <p>Key Types: - <code>Keys</code> - Keyboard key enum - <code>MouseButton</code> - Mouse button enum - <code>GamepadButton</code> - Gamepad button enum - <code>InputLayerManager</code> - Prioritized input processing</p>"},{"location":"concepts/architecture/#implementation-brine2dinputsdl","title":"Implementation (<code>Brine2D.Input.SDL</code>)","text":"<p>Key Classes: - <code>SDL3InputService</code> - SDL3 input polling</p> <p>Pattern: Observer Pattern (input events) + Priority Chain (input layers)</p> <pre><code>// Input layers (like middleware)\n_inputLayerManager.RegisterLayer(_uiCanvas);    // Priority 1000 (high)\n_inputLayerManager.RegisterLayer(_gameLayer);   // Priority 0 (low)\n\n// UI consumes input first, game gets remainder\n_inputLayerManager.ProcessInput();</code></pre>"},{"location":"concepts/architecture/#6-audio-layer","title":"6. Audio Layer","text":""},{"location":"concepts/architecture/#abstractions-brine2daudio","title":"Abstractions (<code>Brine2D.Audio</code>)","text":"<p>Key Interfaces: - <code>IAudioService</code> - Audio playback - <code>ISoundEffect</code> - Short sounds - <code>IMusic</code> - Background music</p>"},{"location":"concepts/architecture/#implementation-brine2daudiosdl","title":"Implementation (<code>Brine2D.Audio.SDL</code>)","text":"<p>Key Classes: - <code>SDL3AudioService</code> - SDL3_mixer implementation with track callbacks (Enhanced in v0.8.0)</p> <p>Pattern: Facade Pattern (simplifies SDL3_mixer)</p> <pre><code>// Simple API for audio\nawait _audio.LoadSoundAsync(\"jump.wav\");\n_audio.PlaySound(jumpSound);\n\nawait _audio.LoadMusicAsync(\"background.mp3\");\n_audio.PlayMusic(music, loops: -1);</code></pre>"},{"location":"concepts/architecture/#ecs-bridge-brine2daudioecs-new-in-v080","title":"ECS Bridge (<code>Brine2D.Audio.ECS</code>) (NEW in v0.8.0)","text":"<p>Key Components: - <code>AudioListenerComponent</code> - Spatial audio listener (player/camera) - <code>AudioSourceComponent</code> - Positioned audio sources</p> <p>Key Systems: - <code>AudioSystem</code> - Updates spatial audio every frame</p> <p>Features: - Distance-based volume attenuation - Stereo panning based on position - Configurable falloff curves (linear, quadratic, custom) - Real-time spatial audio updates</p> <pre><code>// Create audio listener (player)\nvar player = _world.CreateEntity(\"Player\");\nvar listener = player.AddComponent&lt;AudioListenerComponent&gt;();\nlistener.GlobalSpatialVolume = 1.0f;\n\n// Create spatial audio source\nvar enemy = _world.CreateEntity(\"Enemy\");\nvar audioSource = enemy.AddComponent&lt;AudioSourceComponent&gt;();\naudioSource.SoundEffect = enemySound;\naudioSource.EnableSpatialAudio = true;\naudioSource.MinDistance = 100f;\naudioSource.MaxDistance = 500f;\naudioSource.RolloffFactor = 1.0f;\naudioSource.SpatialBlend = 1.0f;\naudioSource.PlayOnEnable = true;</code></pre>"},{"location":"concepts/architecture/#7-game-systems-layer","title":"7. Game Systems Layer","text":"<p>Game systems manage game logic and state. Unlike rendering utilities (which optimize performance), game systems implement gameplay features.</p> <p>UI System (<code>Brine2D.UI</code>): - <code>UICanvas</code> - Container for UI components - <code>UIButton</code>, <code>UISlider</code>, <code>UITextInput</code>, etc. - Interactive components - Input layer integration for event handling</p> <p>Collision System (<code>Brine2D.Core.Collision</code>): - <code>CollisionSystem</code> - Manages collision shapes and detection - <code>BoxCollider</code>, <code>CircleCollider</code> - Collision shapes - Optional spatial partitioning for performance</p> <p>Animation System (<code>Brine2D.Core.Animation</code>): - <code>SpriteAnimator</code> - Plays frame-based animations - <code>AnimationClip</code> - Frame sequences - <code>SpriteFrame</code> - Individual animation frames</p> <p>Tilemap System (<code>Brine2D.Core.Tilemap</code>): - <code>Tilemap</code> - Tile-based level data - <code>TilemapRenderer</code> - Renders tilemaps efficiently - <code>TmjLoader</code> - Loads Tiled JSON format</p>"},{"location":"concepts/architecture/#design-patterns-used","title":"Design Patterns Used","text":"Pattern Where Used Purpose Builder <code>GameApplicationBuilder</code> Fluent API for configuration Dependency Injection Everywhere Loose coupling, testability Strategy <code>IRenderer</code> implementations Swappable rendering backends Facade Audio, Input services Simplify complex SDL3 APIs Observer Input events, animations, EventBus Event-driven behavior Component UI system, ECS Composable elements Mediator <code>GameEngine</code> Coordinate subsystems Template Method <code>Scene</code> base class Lifecycle hooks Chain of Responsibility Input layers Prioritized input handling Object Pool Particle system Zero-allocation particle reuse Bin Packing <code>AtlasBuilder</code> Optimal texture packing (NEW)"},{"location":"concepts/architecture/#data-flow","title":"Data Flow","text":""},{"location":"concepts/architecture/#initialization-flow","title":"Initialization Flow","text":"<pre><code>sequenceDiagram\n    participant U as User Code\n    participant B as GameApplicationBuilder\n    participant G as GameApplication\n    participant E as GameEngine\n    participant R as IRenderer\n    participant S as SceneManager\n\n    U-&gt;&gt;B: CreateBuilder(args)\n    U-&gt;&gt;B: Services.AddSDL3Rendering()\n    U-&gt;&gt;B: Services.AddScene&lt;GameScene&gt;()\n    U-&gt;&gt;B: Build()\n    B-&gt;&gt;G: new GameApplication(host)\n\n    U-&gt;&gt;G: RunAsync&lt;GameScene&gt;()\n    G-&gt;&gt;E: InitializeAsync()\n    E-&gt;&gt;R: InitializeAsync()\n    R-&gt;&gt;E: Initialized\n\n    G-&gt;&gt;S: LoadSceneAsync&lt;GameScene&gt;()\n    S-&gt;&gt;S: Resolve GameScene from DI\n    S-&gt;&gt;S: scene.Initialize()\n    S-&gt;&gt;S: scene.LoadAsync()\n\n    G-&gt;&gt;G: Start Game Loop</code></pre>"},{"location":"concepts/architecture/#game-loop-flow","title":"Game Loop Flow","text":"<pre><code>sequenceDiagram\n    participant GL as GameLoop\n    participant IN as InputService\n    participant ILM as InputLayerManager\n    participant SM as SceneManager\n    participant SC as Scene\n    participant ECS as EntityWorld\n    participant AS as AudioSystem\n    participant R as IRenderer\n\n    loop Every Frame\n        GL-&gt;&gt;IN: Update()\n        IN-&gt;&gt;GL: Input Polled\n\n        GL-&gt;&gt;ILM: ProcessInput()\n        ILM-&gt;&gt;ILM: UI layer consumes?\n        ILM-&gt;&gt;GL: Input ready\n\n        GL-&gt;&gt;SM: Update(gameTime)\n        SM-&gt;&gt;SC: OnUpdate(gameTime)\n        SC-&gt;&gt;ECS: Update systems\n        ECS-&gt;&gt;AS: Update spatial audio\n        AS-&gt;&gt;ECS: Audio updated\n        SC-&gt;&gt;SC: Game logic\n        SC-&gt;&gt;SM: Done\n\n        GL-&gt;&gt;SM: Render(gameTime)\n        SM-&gt;&gt;SC: OnRender(gameTime)\n        SC-&gt;&gt;R: Draw calls\n        R-&gt;&gt;R: Present frame\n        R-&gt;&gt;SC: Rendered\n\n        GL-&gt;&gt;GL: Frame limiting\n    end</code></pre>"},{"location":"concepts/architecture/#extension-points","title":"Extension Points","text":"<p>Brine2D is designed to be extended in several ways:</p>"},{"location":"concepts/architecture/#1-custom-scenes","title":"1. Custom Scenes","text":"<pre><code>public class MyScene : Scene\n{\n    // Override lifecycle methods\n    protected override void OnInitialize() { }\n    protected override Task OnLoadAsync(CancellationToken ct) { }\n    protected override void OnUpdate(GameTime gt) { }\n    protected override void OnRender(GameTime gt) { }\n}</code></pre>"},{"location":"concepts/architecture/#2-custom-systems","title":"2. Custom Systems","text":"<pre><code>// Create your own game system\npublic class WeatherSystem\n{\n    private float _rainIntensity;\n\n    public void Update(float deltaTime)\n    {\n        // Weather logic\n    }\n\n    public void Render(IRenderer renderer)\n    {\n        // Render rain particles\n    }\n}\n\n// Register with DI\nbuilder.Services.AddSingleton&lt;WeatherSystem&gt;();\n\n// Inject into scene\npublic class GameScene : Scene\n{\n    private readonly WeatherSystem _weather;\n\n    public GameScene(WeatherSystem weather, ...) \n    {\n        _weather = weather;\n    }\n}</code></pre>"},{"location":"concepts/architecture/#3-custom-renderers","title":"3. Custom Renderers","text":"<pre><code>// Implement IRenderer\npublic class CustomRenderer : IRenderer\n{\n    // Implement all methods...\n}\n\n// Register\nbuilder.Services.AddSingleton&lt;IRenderer, CustomRenderer&gt;();</code></pre>"},{"location":"concepts/architecture/#4-custom-input-layers","title":"4. Custom Input Layers","text":"<pre><code>// Implement IInputLayer\npublic class DebugInputLayer : IInputLayer\n{\n    public int Priority =&gt; 500; // Between UI and game\n\n    public bool ProcessKeyboardInput(IInputService input)\n    {\n        if (input.IsKeyPressed(Keys.F1))\n        {\n            ToggleDebugMode();\n            return true; // Consume input\n        }\n        return false;\n    }\n}\n\n// Register\n_inputLayerManager.RegisterLayer(debugLayer);</code></pre>"},{"location":"concepts/architecture/#5-custom-audio-components-new-in-v080","title":"5. Custom Audio Components (NEW in v0.8.0)","text":"<pre><code>// Extend AudioSourceComponent for custom behavior\npublic class DynamicAudioComponent : Component\n{\n    private AudioSourceComponent? _audioSource;\n\n    protected internal override void OnInitialize()\n    {\n        _audioSource = Entity?.GetComponent&lt;AudioSourceComponent&gt;();\n    }\n\n    protected internal override void OnUpdate(GameTime gameTime)\n    {\n        // Custom audio behavior (e.g., adjust volume based on health)\n        if (_audioSource != null)\n        {\n            var health = Entity?.GetComponent&lt;HealthComponent&gt;();\n            _audioSource.Volume = health != null ? health.Percentage : 1.0f;\n        }\n    }\n}</code></pre>"},{"location":"concepts/architecture/#performance-considerations","title":"Performance Considerations","text":""},{"location":"concepts/architecture/#memory-management","title":"Memory Management","text":"<ul> <li>Object pooling - Particle system reuses particles (zero allocation)</li> <li>Scoped lifetimes - <code>CollisionSystem</code>, <code>UICanvas</code> are scoped per scene</li> <li>Singleton services - <code>IRenderer</code>, <code>IInputService</code> are singletons</li> <li>Struct types - <code>Color</code>, <code>GameTime</code>, <code>Vector2</code> are value types</li> <li>Texture atlasing - Combines textures to reduce memory and draw calls (NEW in v0.8.0)</li> </ul>"},{"location":"concepts/architecture/#frame-budget","title":"Frame Budget","text":"<p>At 60 FPS, each frame has ~16.67ms:</p> Phase Typical Budget Input &lt;1ms Update (Game Logic) ~8ms Update (ECS Systems) ~2ms Render ~5ms Frame limiting ~1-2ms"},{"location":"concepts/architecture/#optimization-techniques","title":"Optimization Techniques","text":"<p>Rendering Optimizations: - Texture atlasing - <code>AtlasBuilder</code> combines textures (90-99% draw call reduction) (NEW) - Sprite batching - <code>SpriteBatcher</code> groups draw calls by texture - Culling - Only render visible objects (camera frustum)</p> <p>Game Systems Optimizations: - Spatial partitioning - <code>CollisionSystem</code> supports grid partitioning - Object pooling - Particle system uses <code>ObjectPool&lt;T&gt;</code> - Cached queries - ECS queries with zero allocation</p> <p>General: - Async loading - Load assets without blocking the game loop</p>"},{"location":"concepts/architecture/#configuration","title":"Configuration","text":"<p>Configuration flows through <code>IOptions&lt;T&gt;</code> pattern (ASP.NET style):</p> <pre><code>// gamesettings.json\n{\n  \"Rendering\": {\n    \"WindowTitle\": \"My Game\",\n    \"WindowWidth\": 1280,\n    \"WindowHeight\": 720,\n    \"VSync\": true,\n    \"Backend\": \"GPU\"\n  }\n}\n\n// Bind to options\nbuilder.Services.AddSDL3Rendering(options =&gt;\n{\n    builder.Configuration.GetSection(\"Rendering\").Bind(options);\n});\n\n// Access in code\npublic class MyScene : Scene\n{\n    private readonly RenderingOptions _options;\n\n    public MyScene(IOptions&lt;RenderingOptions&gt; options, ...)\n    {\n        _options = options.Value;\n    }\n}</code></pre>"},{"location":"concepts/architecture/#thread-safety","title":"Thread Safety","text":"<ul> <li>Main thread only - SDL3 requires all operations on the main thread</li> <li>Async loading - Use <code>Task.Run()</code> for CPU-bound work, return to main thread for SDL calls</li> <li>No parallelism - Game loop is single-threaded by design</li> <li>Audio callbacks - SDL3_mixer callbacks are thread-safe (Enhanced in v0.8.0)</li> </ul> <pre><code>protected override async Task OnLoadAsync(CancellationToken ct)\n{\n    // CPU-bound work (parsing JSON)\n    var data = await Task.Run(() =&gt; LoadHeavyData(), ct);\n\n    // SDL work (texture creation) - back on main thread\n    _texture = await _textureLoader.LoadTextureAsync(\"sprite.png\", ct);\n}</code></pre>"},{"location":"concepts/architecture/#whats-new-in-v080","title":"What's New in v0.8.0","text":""},{"location":"concepts/architecture/#rendering-utilities","title":"Rendering Utilities","text":"<ul> <li>TextureAtlas - Runtime sprite packing for massive draw call reduction</li> <li>AtlasBuilder - Intelligent bin packing algorithm (90-99% fewer draw calls)</li> <li>SpriteBatcher enhancements - Rotation support and better batching</li> </ul>"},{"location":"concepts/architecture/#spatial-audio-ecs","title":"Spatial Audio (ECS)","text":"<ul> <li>AudioListenerComponent - Spatial audio listener</li> <li>AudioSourceComponent - Positioned audio sources with distance attenuation</li> <li>AudioSystem - Real-time spatial audio updates with stereo panning</li> </ul>"},{"location":"concepts/architecture/#enhanced-particle-system-ecs","title":"Enhanced Particle System (ECS)","text":"<ul> <li>Particle textures - Custom sprite textures instead of circles</li> <li>Rotation - Start, end, and rotation speed properties</li> <li>Trails - Motion trails with configurable length</li> <li>Blend modes - Additive, alpha, and none</li> <li>7 emitter shapes - Point, circle, ring, box, cone, line, burst</li> </ul>"},{"location":"concepts/architecture/#audio-improvements","title":"Audio Improvements","text":"<ul> <li>Track callbacks - SDL3_mixer callbacks for proper lifecycle</li> <li>Thread-safe - Improved callback handling</li> </ul>"},{"location":"concepts/architecture/#conceptual-distinctions","title":"Conceptual Distinctions","text":"<p>Understanding the difference between rendering utilities and game systems helps clarify Brine2D's architecture:</p>"},{"location":"concepts/architecture/#rendering-utilities-performance","title":"Rendering Utilities (Performance)","text":"<ul> <li>Purpose: Optimize rendering performance</li> <li>Examples: <code>SpriteBatcher</code>, <code>TextureAtlas</code>, <code>AtlasBuilder</code></li> <li>Location: <code>Brine2D.Rendering</code> / <code>Brine2D.Rendering.SDL</code></li> <li>Focus: Draw call reduction, batching, memory optimization</li> </ul>"},{"location":"concepts/architecture/#game-systems-logic-state","title":"Game Systems (Logic &amp; State)","text":"<ul> <li>Purpose: Implement gameplay features and manage state</li> <li>Examples: <code>CollisionSystem</code>, <code>UICanvas</code>, <code>SpriteAnimator</code>, <code>TilemapRenderer</code></li> <li>Location: <code>Brine2D.Core.*</code> / <code>Brine2D.UI</code></li> <li>Focus: Game logic, user interaction, entity management</li> </ul>"},{"location":"concepts/architecture/#next-steps","title":"Next Steps","text":"<ul> <li>Dependency Injection - Master the DI container</li> <li>Builder Pattern - Learn <code>GameApplicationBuilder</code></li> <li>Scene Management - Organize your game</li> <li>Game Loop - Understand frame processing</li> <li>Entity Component System - ECS architecture</li> </ul>"},{"location":"concepts/architecture/#summary","title":"Summary","text":"<p>Brine2D's architecture is: - \u2705 Modular - Clear separation of concerns - \u2705 Extensible - Plugin your own implementations - \u2705 Testable - Dependency injection everywhere - \u2705 Familiar - ASP.NET patterns throughout - \u2705 Performant - Designed for real-time games with modern optimizations - \u2705 Production-Ready - Texture atlasing, spatial audio, advanced particles (v0.8.0)</p> <p>Ready to dive deeper? Explore Dependency Injection next!</p>"},{"location":"concepts/builder-pattern/","title":"Builder Pattern","text":"<p>The Builder Pattern in Brine2D provides a fluent, ASP.NET-style API for configuring your game. If you've used <code>WebApplicationBuilder</code>, you'll feel right at home!</p>"},{"location":"concepts/builder-pattern/#overview","title":"Overview","text":"<pre><code>graph LR\n    A[\"GameApplication.CreateBuilder()\"] --&gt; B[\"GameApplicationBuilder\"]\n    B --&gt; C[\"Configure Services\"]\n    B --&gt; D[\"Configure Logging\"]\n    B --&gt; E[\"Configure Configuration\"]\n    C --&gt; F[\"builder.Build()\"]\n    D --&gt; F\n    E --&gt; F\n    F --&gt; G[\"GameApplication\"]\n    G --&gt; H[\"game.RunAsync&amp;lt;Scene&amp;gt;()\"]\n\n    style A fill:#1e3a5f,stroke:#569cd6,stroke-width:2px,color:#fff\nstyle B fill:#2d5016,stroke:#4ec9b0,stroke-width:2px,color:#fff\nstyle C fill:#3d3d2a,stroke:#dcdcaa,stroke-width:2px,color:#fff\nstyle D fill:#3d3d2a,stroke:#dcdcaa,stroke-width:2px,color:#fff\nstyle E fill:#3d3d2a,stroke:#dcdcaa,stroke-width:2px,color:#fff\nstyle F fill:#4a2d4a,stroke:#c586c0,stroke-width:2px,color:#fff\nstyle G fill:#4a3d1f,stroke:#ce9178,stroke-width:2px,color:#fff\nstyle H fill:#264f78,stroke:#4fc1ff,stroke-width:2px,color:#fff</code></pre>"},{"location":"concepts/builder-pattern/#basic-usage","title":"Basic Usage","text":""},{"location":"concepts/builder-pattern/#minimal-setup","title":"Minimal Setup","text":"<pre><code>using Brine2D.Hosting;\n\n// Step 1: Create builder\nvar builder = GameApplication.CreateBuilder(args);\n\n// Step 2: Configure services\nbuilder.Services.AddSDL3Rendering();\nbuilder.Services.AddSDL3Input();\nbuilder.Services.AddScene&lt;GameScene&gt;();\n\n// Step 3: Build application\nvar game = builder.Build();\n\n// Step 4: Run\nawait game.RunAsync&lt;GameScene&gt;();</code></pre> <p>That's it! Four simple steps to a working game.</p>"},{"location":"concepts/builder-pattern/#gameapplicationbuilder","title":"GameApplicationBuilder","text":"<p>The builder wraps <code>HostApplicationBuilder</code> (from <code>Microsoft.Extensions.Hosting</code>) and adds game-specific defaults.</p>"},{"location":"concepts/builder-pattern/#constructor-internal","title":"Constructor (Internal)","text":"<pre><code>internal GameApplicationBuilder(string[] args)\n{\n    _hostBuilder = Host.CreateApplicationBuilder(args);\n\n    // 1. Configure default settings\n    Configuration.AddJsonFile(\"gamesettings.json\", optional: true, reloadOnChange: true);\n    Configuration.AddJsonFile($\"gamesettings.{Environment}.json\", optional: true, reloadOnChange: true);\n\n    // 2. Add core engine services\n    Services.AddBrineEngine();\n\n    // 3. Add default logging\n    Logging.AddConsole();\n    Logging.SetMinimumLevel(LogLevel.Information);\n}</code></pre> <p>What it does: 1. \u2705 Loads <code>gamesettings.json</code> automatically 2. \u2705 Registers core engine services (GameLoop, SceneManager, etc.) 3. \u2705 Sets up console logging 4. \u2705 Supports environment-specific configs</p>"},{"location":"concepts/builder-pattern/#builder-properties","title":"Builder Properties","text":""},{"location":"concepts/builder-pattern/#1-services-iservicecollection","title":"1. Services (IServiceCollection)","text":"<p>Purpose: Register services for dependency injection</p> <pre><code>public IServiceCollection Services =&gt; _hostBuilder.Services;</code></pre> <p>Usage:</p> <pre><code>// Register singleton services\nbuilder.Services.AddSDL3Rendering();\nbuilder.Services.AddSDL3Input();\nbuilder.Services.AddSDL3Audio();\n\n// Register scoped services (per-scene)\nbuilder.Services.AddCollisionSystem();\nbuilder.Services.AddUICanvas();\n\n// Register transient services (scenes)\nbuilder.Services.AddScene&lt;MenuScene&gt;();\nbuilder.Services.AddScene&lt;GameScene&gt;();</code></pre> <p>See also: Dependency Injection</p>"},{"location":"concepts/builder-pattern/#2-configuration-configurationmanager","title":"2. Configuration (ConfigurationManager)","text":"<p>Purpose: Access configuration from JSON files, environment variables, command-line args</p> <pre><code>public ConfigurationManager Configuration =&gt; _hostBuilder.Configuration;</code></pre> <p>Usage:</p> <pre><code>// Read configuration values\nvar windowTitle = builder.Configuration[\"Rendering:WindowTitle\"];\nvar windowWidth = builder.Configuration.GetValue&lt;int&gt;(\"Rendering:WindowWidth\");\n\n// Bind configuration to options\nbuilder.Services.Configure&lt;RenderingOptions&gt;(\n    builder.Configuration.GetSection(\"Rendering\"));\n\n// Add custom configuration sources\nbuilder.Configuration.AddJsonFile(\"custom-settings.json\");\nbuilder.Configuration.AddEnvironmentVariables(\"MYGAME_\");</code></pre> <p>Configuration hierarchy: 1. <code>gamesettings.json</code> (base settings) 2. <code>gamesettings.{Environment}.json</code> (environment-specific) 3. Environment variables 4. Command-line arguments (highest priority)</p>"},{"location":"concepts/builder-pattern/#3-logging-iloggingbuilder","title":"3. Logging (ILoggingBuilder)","text":"<p>Purpose: Configure logging providers and levels</p> <pre><code>public ILoggingBuilder Logging =&gt; _hostBuilder.Logging;</code></pre> <p>Usage:</p> <pre><code>// Set minimum log level\nbuilder.Logging.SetMinimumLevel(LogLevel.Debug);\n\n// Clear default providers\nbuilder.Logging.ClearProviders();\n\n// Add specific providers\nbuilder.Logging.AddConsole();\nbuilder.Logging.AddDebug();\n\n// Filter by category\nbuilder.Logging.AddFilter(\"Brine2D\", LogLevel.Trace);\nbuilder.Logging.AddFilter(\"Microsoft\", LogLevel.Warning);</code></pre> <p>Log levels:</p> Level When to Use <code>Trace</code> Extremely detailed (every frame) <code>Debug</code> Debugging during development <code>Information</code> Default - general info <code>Warning</code> Potential issues <code>Error</code> Errors that need attention <code>Critical</code> Fatal errors"},{"location":"concepts/builder-pattern/#4-environment-ihostenvironment","title":"4. Environment (IHostEnvironment)","text":"<p>Purpose: Detect runtime environment (Development, Production, etc.)</p> <pre><code>public IHostEnvironment Environment =&gt; _hostBuilder.Environment;</code></pre> <p>Usage:</p> <pre><code>if (builder.Environment.IsDevelopment())\n{\n    // Enable debug features\n    builder.Logging.SetMinimumLevel(LogLevel.Debug);\n    builder.Services.AddDeveloperTools();\n}\n\nif (builder.Environment.IsProduction())\n{\n    // Optimize for release\n    builder.Logging.SetMinimumLevel(LogLevel.Warning);\n}\n\n// Get environment name\nvar envName = builder.Environment.EnvironmentName; // \"Development\", \"Production\", etc.</code></pre> <p>Set environment:</p> <pre><code># Command line\nDOTNET_ENVIRONMENT=Development dotnet run\n\n# Or in launchSettings.json (Visual Studio)\n\"environmentVariables\": {\n  \"DOTNET_ENVIRONMENT\": \"Development\"\n}</code></pre>"},{"location":"concepts/builder-pattern/#build-method","title":"Build Method","text":"<p>Purpose: Creates the final <code>GameApplication</code> instance</p> <pre><code>public GameApplication Build()\n{\n    var host = _hostBuilder.Build();\n    return new GameApplication(host);\n}</code></pre> <p>What it does: 1. Finalizes service registrations 2. Builds the DI container 3. Creates the <code>IHost</code> instance 4. Wraps it in <code>GameApplication</code></p> <p>After <code>Build()</code>, you cannot modify the builder!</p> <pre><code>var game = builder.Build();\n\n// \u274c Too late! Container is sealed\nbuilder.Services.AddScene&lt;NewScene&gt;(); // Throws exception</code></pre>"},{"location":"concepts/builder-pattern/#common-configuration-patterns","title":"Common Configuration Patterns","text":""},{"location":"concepts/builder-pattern/#pattern-1-service-registration","title":"Pattern 1: Service Registration","text":"<pre><code>var builder = GameApplication.CreateBuilder(args);\n\n// Chain service registrations\nbuilder.Services\n    .AddInputLayerManager()\n    .AddSDL3Input();\n\nbuilder.Services.AddSDL3Audio();\n\nbuilder.Services.AddSDL3Rendering(options =&gt;\n{\n    options.WindowTitle = \"My Game\";\n    options.WindowWidth = 1920;\n    options.WindowHeight = 1080;\n    options.VSync = true;\n});\n\n// Scoped services\nbuilder.Services.AddCollisionSystem();\nbuilder.Services.AddUICanvas();\n\n// Scenes\nbuilder.Services.AddScene&lt;MenuScene&gt;();\nbuilder.Services.AddScene&lt;GameScene&gt;();\nbuilder.Services.AddScene&lt;PauseScene&gt;();</code></pre>"},{"location":"concepts/builder-pattern/#pattern-2-configuration-binding","title":"Pattern 2: Configuration Binding","text":"<pre><code>// gamesettings.json\n{\n  \"Rendering\": {\n    \"WindowTitle\": \"My Game\",\n    \"WindowWidth\": 1280,\n    \"WindowHeight\": 720,\n    \"VSync\": true,\n    \"Backend\": \"GPU\"\n  }\n}\n\n// Program.cs\nbuilder.Services.AddSDL3Rendering(options =&gt;\n{\n    // Bind from config section\n    builder.Configuration.GetSection(\"Rendering\").Bind(options);\n\n    // Override specific values\n    options.WindowTitle = \"My Awesome Game\"; // Overrides JSON value\n});</code></pre>"},{"location":"concepts/builder-pattern/#pattern-3-environment-specific-configuration","title":"Pattern 3: Environment-Specific Configuration","text":"<pre><code>var builder = GameApplication.CreateBuilder(args);\n\nif (builder.Environment.IsDevelopment())\n{\n    // Development-only services\n    builder.Services.AddSingleton&lt;IDebugOverlay, DebugOverlay&gt;();\n\n    // Verbose logging\n    builder.Logging.SetMinimumLevel(LogLevel.Debug);\n\n    // Enable hot reload (if supported)\n    builder.Configuration.AddJsonFile(\"gamesettings.Development.json\", \n        optional: true, \n        reloadOnChange: true);\n}\nelse\n{\n    // Production optimizations\n    builder.Logging.SetMinimumLevel(LogLevel.Warning);\n\n    // Disable debug features\n    builder.Services.Configure&lt;RenderingOptions&gt;(o =&gt; o.VSync = true);\n}</code></pre> <p>File structure:</p> <pre><code>MyGame/\n\u251c\u2500\u2500 gamesettings.json                 # Base config (all environments)\n\u251c\u2500\u2500 gamesettings.Development.json     # Dev overrides\n\u251c\u2500\u2500 gamesettings.Production.json      # Prod overrides\n\u2514\u2500\u2500 Program.cs</code></pre>"},{"location":"concepts/builder-pattern/#pattern-4-custom-extension-methods","title":"Pattern 4: Custom Extension Methods","text":"<p>Create your own fluent API:</p> <pre><code>// MyGameExtensions.cs\npublic static class MyGameExtensions\n{\n    public static IServiceCollection AddMyGame(\n        this IServiceCollection services,\n        IConfiguration configuration)\n    {\n        // Register all game-specific services\n        services.AddInputLayerManager().AddSDL3Input();\n        services.AddSDL3Audio();\n\n        services.AddSDL3Rendering(options =&gt;\n        {\n            configuration.GetSection(\"Rendering\").Bind(options);\n        });\n\n        services.AddCollisionSystem();\n        services.AddUICanvas();\n\n        // Custom systems\n        services.AddSingleton&lt;IEnemyFactory, EnemyFactory&gt;();\n        services.AddScoped&lt;ILevelManager, LevelManager&gt;();\n\n        return services;\n    }\n}\n\n// Program.cs - Now super clean!\nvar builder = GameApplication.CreateBuilder(args);\nbuilder.Services.AddMyGame(builder.Configuration);\nbuilder.Services.AddScene&lt;GameScene&gt;();\n\nvar game = builder.Build();\nawait game.RunAsync&lt;GameScene&gt;();</code></pre>"},{"location":"concepts/builder-pattern/#complete-example","title":"Complete Example","text":"<p>Here's a real-world configuration:</p> <pre><code>using Brine2D.Audio.SDL;\nusing Brine2D.Core.Collision;\nusing Brine2D.Core.Tilemap;\nusing Brine2D.Hosting;\nusing Brine2D.Input;\nusing Brine2D.Input.SDL;\nusing Brine2D.Rendering.SDL;\nusing Brine2D.UI;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Logging;\nusing MyGame;\n\n// ========================================\n// STEP 1: Create Builder\n// ========================================\nvar builder = GameApplication.CreateBuilder(args);\n\n// ========================================\n// STEP 2: Configure Logging\n// ========================================\nbuilder.Logging.ClearProviders();\nbuilder.Logging.AddConsole();\n\nif (builder.Environment.IsDevelopment())\n{\n    builder.Logging.SetMinimumLevel(LogLevel.Debug);\n    builder.Logging.AddFilter(\"Brine2D\", LogLevel.Trace);\n}\nelse\n{\n    builder.Logging.SetMinimumLevel(LogLevel.Information);\n}\n\n// ========================================\n// STEP 3: Configure Services\n// ========================================\n\n// Input\nbuilder.Services\n    .AddInputLayerManager()\n    .AddSDL3Input();\n\n// Audio\nbuilder.Services.AddSDL3Audio();\n\n// Rendering\nbuilder.Services.AddSDL3Rendering(options =&gt;\n{\n    // Bind from gamesettings.json\n    builder.Configuration.GetSection(\"Rendering\").Bind(options);\n\n    // Override if needed\n    if (builder.Environment.IsDevelopment())\n    {\n        options.WindowTitle += \" [DEV]\";\n    }\n});\n\n// Game Systems (Scoped)\nbuilder.Services.AddCollisionSystem();\nbuilder.Services.AddUICanvas();\nbuilder.Services.AddTilemapServices();\nbuilder.Services.AddTilemapRenderer();\n\n// Custom Systems\nbuilder.Services.AddSingleton&lt;IEnemyFactory, EnemyFactory&gt;();\nbuilder.Services.AddScoped&lt;ILevelManager, LevelManager&gt;();\nbuilder.Services.AddTransient&lt;IParticleSystem, ParticleSystem&gt;();\n\n// Scenes\nbuilder.Services.AddScene&lt;MenuScene&gt;();\nbuilder.Services.AddScene&lt;GameScene&gt;();\nbuilder.Services.AddScene&lt;PauseScene&gt;();\nbuilder.Services.AddScene&lt;GameOverScene&gt;();\n\n// ========================================\n// STEP 4: Build Application\n// ========================================\nvar game = builder.Build();\n\n// ========================================\n// STEP 5: Run\n// ========================================\nawait game.RunAsync&lt;MenuScene&gt;();</code></pre> <p>```json gamesettings.json {   \"Logging\": {     \"LogLevel\": {       \"Default\": \"Information\",       \"Brine2D\": \"Debug\",       \"Microsoft\": \"Warning\"     }   },   \"Rendering\": {     \"WindowTitle\": \"My Awesome Game\",     \"WindowWidth\": 1920,     \"WindowHeight\": 1080,     \"VSync\": true,     \"Fullscreen\": false,     \"Backend\": \"GPU\",     \"PreferredGPUDriver\": \"vulkan\"   },   \"Audio\": {     \"MasterVolume\": 0.8,     \"MusicVolume\": 0.6,     \"SoundVolume\": 1.0   } } <pre><code>\n---\n\n## ASP.NET Comparison\n\n| ASP.NET | Brine2D | Purpose |\n|---------|---------|---------|\n| `WebApplication.CreateBuilder()` | `GameApplication.CreateBuilder()` | Create builder |\n| `builder.Services` | `builder.Services` | Register services |\n| `builder.Configuration` | `builder.Configuration` | Access configuration |\n| `builder.Logging` | `builder.Logging` | Configure logging |\n| `builder.Environment` | `builder.Environment` | Detect environment |\n| `appsettings.json` | `gamesettings.json` | Configuration file |\n| `builder.Build()` | `builder.Build()` | Create application |\n| `app.Run()` | `game.RunAsync&lt;Scene&gt;()` | Start application |\n\n**Nearly identical API!**\n\n---\n\n## Advanced Scenarios\n\n### Custom Configuration Sources\n\n```csharp\nbuilder.Configuration.AddJsonFile(\"levels.json\");\nbuilder.Configuration.AddXmlFile(\"achievements.xml\");\nbuilder.Configuration.AddIniFile(\"controls.ini\");\n\n// Environment variables with prefix\nbuilder.Configuration.AddEnvironmentVariables(\"MYGAME_\");\n\n// Command-line arguments\n// Example: dotnet run --WindowWidth=1920 --WindowHeight=1080\nbuilder.Configuration.AddCommandLine(args);</code></pre></p> <p>Priority (highest to lowest): 1. Command-line arguments 2. Environment variables 3. JSON files (last added wins)</p>"},{"location":"concepts/builder-pattern/#multiple-configuration-files","title":"Multiple Configuration Files","text":"<pre><code>builder.Configuration\n    .AddJsonFile(\"gamesettings.json\", optional: false, reloadOnChange: true)\n    .AddJsonFile($\"gamesettings.{builder.Environment.EnvironmentName}.json\", optional: true, reloadOnChange: true)\n    .AddJsonFile(\"player-prefs.json\", optional: true, reloadOnChange: true)\n    .AddJsonFile(\"achievements.json\", optional: true, reloadOnChange: true);</code></pre>"},{"location":"concepts/builder-pattern/#conditional-service-registration","title":"Conditional Service Registration","text":"<pre><code>// Platform-specific services\nif (OperatingSystem.IsWindows())\n{\n    builder.Services.AddSingleton&lt;IPlatformService, WindowsPlatformService&gt;();\n}\nelse if (OperatingSystem.IsLinux())\n{\n    builder.Services.AddSingleton&lt;IPlatformService, LinuxPlatformService&gt;();\n}\n\n// GPU backend selection\nvar backend = builder.Configuration[\"Rendering:Backend\"];\nif (backend == \"GPU\")\n{\n    builder.Services.AddSDL3GPURendering();\n}\nelse\n{\n    builder.Services.AddSDL3LegacyRendering();\n}</code></pre>"},{"location":"concepts/builder-pattern/#validation","title":"Validation","text":"<p>Validate configuration at startup:</p> <pre><code>var renderingOptions = new RenderingOptions();\nbuilder.Configuration.GetSection(\"Rendering\").Bind(renderingOptions);\n\nif (renderingOptions.WindowWidth &lt; 640)\n    throw new InvalidOperationException(\"Window width must be at least 640\");\n\nif (renderingOptions.WindowHeight &lt; 480)\n    throw new InvalidOperationException(\"Window height must be at least 480\");</code></pre>"},{"location":"concepts/builder-pattern/#best-practices","title":"Best Practices","text":""},{"location":"concepts/builder-pattern/#do","title":"DO","text":"<ol> <li> <p>Use environment-specific configs <pre><code>gamesettings.Development.json\ngamesettings.Production.json</code></pre></p> </li> <li> <p>Group related services in extension methods <pre><code>builder.Services.AddMyGameSystems(builder.Configuration);</code></pre></p> </li> <li> <p>Bind configuration to options classes <pre><code>builder.Services.Configure&lt;RenderingOptions&gt;(\n    builder.Configuration.GetSection(\"Rendering\"));</code></pre></p> </li> <li> <p>Use fluent API for readability <pre><code>builder.Services\n    .AddInputLayerManager()\n    .AddSDL3Input();</code></pre></p> </li> </ol>"},{"location":"concepts/builder-pattern/#dont","title":"DON'T","text":"<ol> <li> <p>Don't modify builder after Build() <pre><code>var game = builder.Build();\nbuilder.Services.AddScene&lt;NewScene&gt;(); // \u274c Throws!</code></pre></p> </li> <li> <p>Don't register services in scenes <pre><code>// \u274c Wrong place!\nprotected override void OnInitialize()\n{\n    builder.Services.AddSingleton&lt;IService, Service&gt;();\n}</code></pre></p> </li> <li> <p>Don't hard-code configuration <pre><code>// \u274c Bad\noptions.WindowWidth = 1280;\n\n// \u2705 Good\nbuilder.Configuration.GetSection(\"Rendering\").Bind(options);</code></pre></p> </li> </ol>"},{"location":"concepts/builder-pattern/#troubleshooting","title":"Troubleshooting","text":""},{"location":"concepts/builder-pattern/#service-not-found-error","title":"\"Service not found\" error","text":"<pre><code>System.InvalidOperationException: No service for type 'IRenderer' has been registered.</code></pre> <p>Solution: Register the service before <code>Build()</code>:</p> <pre><code>builder.Services.AddSDL3Rendering(); // Must be before Build()\nvar game = builder.Build();</code></pre>"},{"location":"concepts/builder-pattern/#configuration-not-loading","title":"Configuration not loading","text":"<p>Problem: <code>gamesettings.json</code> not found</p> <p>Solution: Ensure it's copied to output:</p> <pre><code>&lt;ItemGroup&gt;\n  &lt;None Update=\"gamesettings.json\"&gt;\n    &lt;CopyToOutputDirectory&gt;PreserveNewest&lt;/CopyToOutputDirectory&gt;\n  &lt;/None&gt;\n&lt;/ItemGroup&gt;</code></pre>"},{"location":"concepts/builder-pattern/#environment-not-detected","title":"Environment not detected","text":"<p>Problem: Always runs in Production mode</p> <p>Solution: Set <code>DOTNET_ENVIRONMENT</code> variable:</p> <pre><code># PowerShell\n$env:DOTNET_ENVIRONMENT=\"Development\"\n\n# Bash\nexport DOTNET_ENVIRONMENT=Development\n\n# Or in launchSettings.json\n\"environmentVariables\": {\n  \"DOTNET_ENVIRONMENT\": \"Development\"\n}</code></pre>"},{"location":"concepts/builder-pattern/#summary","title":"Summary","text":"Concept Description CreateBuilder() Factory method to create builder Services Register services for DI Configuration Access JSON/env/args config Logging Configure log providers and levels Environment Detect Development/Production Build() Finalize and create GameApplication"},{"location":"concepts/builder-pattern/#next-steps","title":"Next Steps","text":"<ul> <li>Dependency Injection - Master service registration</li> <li>Configuration - Deep dive into configuration</li> <li>Scene Management - Learn scene lifecycle</li> <li>Logging - Advanced logging techniques</li> </ul> <p>The builder pattern makes configuration clean, discoverable, and maintainable!</p>"},{"location":"concepts/dependency-injection/","title":"Dependency Injection","text":"<p>Brine2D uses Microsoft.Extensions.DependencyInjection - the same DI container as ASP.NET Core. If you've built web apps with ASP.NET, this will feel like home.</p>"},{"location":"concepts/dependency-injection/#why-dependency-injection","title":"Why Dependency Injection?","text":"<pre><code>graph LR\n    A[\"Loose Coupling\"] --&gt; D[\"Benefits\"]\n    B[\"Testability\"] --&gt; D\n    C[\"Maintainability\"] --&gt; D\n    E[\"Flexibility\"] --&gt; D\n    D --&gt; F[\"Better Code\"]\n\n    style A fill:#2d5016,stroke:#4ec9b0,stroke-width:2px,color:#fff\n    style B fill:#4a3d1f,stroke:#ce9178,stroke-width:2px,color:#fff\n    style C fill:#4a2d4a,stroke:#c586c0,stroke-width:2px,color:#fff\n    style E fill:#3d3d2a,stroke:#dcdcaa,stroke-width:2px,color:#fff\n    style D fill:#1e3a5f,stroke:#569cd6,stroke-width:2px,color:#fff\n    style F fill:#264f78,stroke:#4fc1ff,stroke-width:2px,color:#fff</code></pre> <p>Benefits:</p> <ul> <li>\u2705 Testability - Easily mock dependencies in tests</li> <li>\u2705 Loose Coupling - Classes don't create their dependencies</li> <li>\u2705 Flexibility - Swap implementations without changing code</li> <li>\u2705 Maintainability - Clear dependency relationships</li> </ul>"},{"location":"concepts/dependency-injection/#basic-concepts","title":"Basic Concepts","text":""},{"location":"concepts/dependency-injection/#services-and-lifetimes","title":"Services and Lifetimes","text":"<p>Brine2D supports three service lifetimes:</p> Lifetime Description When to Use Example Singleton One instance for entire app Expensive to create, stateless <code>IRenderer</code>, <code>IInputService</code>, <code>IAudioService</code> Scoped One instance per scene/scope Scene-specific state <code>CollisionSystem</code>, <code>UICanvas</code> Transient New instance every time Lightweight, no state Scenes, temporary objects <pre><code>graph TD\n    subgraph APP[\"Application Lifetime\"]\n        SINGLETON[\"Singleton Services&lt;br/&gt;(IRenderer, IInputService)\"]\n    end\n\n    subgraph S1[\"Scene 1 Lifetime\"]\n        SCOPED1[\"Scoped Services&lt;br/&gt;(CollisionSystem, UICanvas)\"]\n        TRANSIENT1[\"Transient&lt;br/&gt;(MenuScene)\"]\n    end\n\n    subgraph S2[\"Scene 2 Lifetime\"]\n        SCOPED2[\"Scoped Services&lt;br/&gt;(CollisionSystem, UICanvas)\"]\n        TRANSIENT2[\"Transient&lt;br/&gt;(GameScene)\"]\n    end\n\n    SINGLETON --&gt; SCOPED1\n    SINGLETON --&gt; SCOPED2\n    SCOPED1 --&gt; TRANSIENT1\n    SCOPED2 --&gt; TRANSIENT2\n\n    style SINGLETON fill:#2d5016,stroke:#4ec9b0,stroke-width:3px,color:#fff\n    style SCOPED1 fill:#1e3a5f,stroke:#569cd6,stroke-width:2px,color:#fff\n    style SCOPED2 fill:#1e3a5f,stroke:#569cd6,stroke-width:2px,color:#fff\n    style TRANSIENT1 fill:#3d3d2a,stroke:#dcdcaa,stroke-width:2px,color:#fff\n    style TRANSIENT2 fill:#3d3d2a,stroke:#dcdcaa,stroke-width:2px,color:#fff\n    style APP fill:#1a2332,stroke:#4ec9b0,stroke-width:2px,color:#fff\n    style S1 fill:#1a2332,stroke:#569cd6,stroke-width:2px,color:#fff\n    style S2 fill:#1a2332,stroke:#569cd6,stroke-width:2px,color:#fff</code></pre>"},{"location":"concepts/dependency-injection/#registration-patterns","title":"Registration Patterns","text":""},{"location":"concepts/dependency-injection/#1-engine-services-singleton","title":"1. Engine Services (Singleton)","text":"<p>Core engine services live for the entire application:</p> <pre><code>// In GameApplicationBuilder (automatic)\nservices.TryAddSingleton&lt;IGameEngine, GameEngine&gt;();\nservices.TryAddSingleton&lt;IGameLoop, GameLoop&gt;();\nservices.TryAddSingleton&lt;IGameContext, GameContext&gt;();\nservices.TryAddSingleton&lt;ISceneManager, SceneManager&gt;();</code></pre> <p>Why Singleton? - Created once at startup - Shared across all scenes - Manage global game state</p>"},{"location":"concepts/dependency-injection/#2-rendering-services-singleton","title":"2. Rendering Services (Singleton)","text":"<p>Rendering is expensive to initialize and provides both GPU and legacy renderer options:</p> <pre><code>// In your Program.cs\nbuilder.Services.AddSDL3Rendering(options =&gt;\n{\n    options.WindowTitle = \"My Game\";\n    options.WindowWidth = 1280;\n    options.WindowHeight = 720;\n    options.Backend = GraphicsBackend.GPU;  // GPU, LegacyRenderer, or Auto\n});\n\n// What it registers (internally):\nservices.TryAddSingleton&lt;IFontLoader, SDL3FontLoader&gt;();\nservices.TryAddSingleton&lt;IRenderer&gt;(/* backend-specific implementation */);\nservices.TryAddSingleton&lt;ITextureContext&gt;(/* from renderer */);\nservices.TryAddSingleton&lt;ITextureLoader, SDL3TextureLoader&gt;();</code></pre> <p>Implementation:</p> <pre><code>public static IServiceCollection AddSDL3Rendering(\n    this IServiceCollection services,\n    Action&lt;RenderingOptions&gt;? configureOptions = null)\n{\n    if (configureOptions != null)\n    {\n        services.Configure(configureOptions);\n    }\n\n    services.TryAddSingleton&lt;IFontLoader, SDL3FontLoader&gt;();\n\n    // Choose renderer based on backend configuration\n    services.TryAddSingleton&lt;IRenderer&gt;(provider =&gt;\n    {\n        var options = provider.GetRequiredService&lt;IOptions&lt;RenderingOptions&gt;&gt;();\n        var loggerFactory = provider.GetRequiredService&lt;ILoggerFactory&gt;();\n        var fontLoader = provider.GetService&lt;IFontLoader&gt;();\n        var eventBus = provider.GetService&lt;EventBus&gt;();  // Optional EventBus for window events\n\n        return options.Value.Backend switch\n        {\n            GraphicsBackend.GPU =&gt; new SDL3GPURenderer(\n                provider.GetRequiredService&lt;ILogger&lt;SDL3GPURenderer&gt;&gt;(),\n                loggerFactory,\n                options,\n                fontLoader,\n                eventBus),\n            GraphicsBackend.LegacyRenderer =&gt; new SDL3Renderer(\n                provider.GetRequiredService&lt;ILogger&lt;SDL3Renderer&gt;&gt;(),\n                loggerFactory,\n                options,\n                fontLoader,\n                eventBus),\n            GraphicsBackend.Auto =&gt; new SDL3GPURenderer(\n                provider.GetRequiredService&lt;ILogger&lt;SDL3GPURenderer&gt;&gt;(),\n                loggerFactory,\n                options,\n                fontLoader,\n                eventBus),  // Defaults to GPU\n            _ =&gt; throw new NotSupportedException($\"Backend {options.Value.Backend} not supported\")\n        };\n    });\n\n    services.TryAddSingleton&lt;ITextureContext&gt;(provider =&gt; \n        (ITextureContext)provider.GetRequiredService&lt;IRenderer&gt;());\n    services.TryAddSingleton&lt;ITextureLoader, SDL3TextureLoader&gt;();\n\n    return services;\n}</code></pre> <p>What's new in v0.7.0: - Renderer selection based on <code>GraphicsBackend</code> enum (<code>GPU</code>, <code>LegacyRenderer</code>, <code>Auto</code>) - Both renderers accept optional <code>EventBus</code> for window events like <code>WindowResizedEvent</code> - GPU renderer is the new default - modern shader-based rendering with Vulkan/Metal/D3D11/D3D12 support - Legacy renderer remains available for compatibility with older systems - Configure preferred GPU driver via <code>options.PreferredGPUDriver</code> (optional)</p> <p>Why Singleton? - Window and graphics device initialization is expensive - Shared rendering context across all scenes - Manages global rendering state and frame buffers</p>"},{"location":"concepts/dependency-injection/#3-input-services-singleton","title":"3. Input Services (Singleton)","text":"<p>Input state is global:</p> <pre><code>// In your Program.cs\nbuilder.Services.AddInputLayerManager().AddSDL3Input();\n\n// What it registers:\nservices.AddSingleton&lt;InputLayerManager&gt;();\nservices.TryAddSingleton&lt;IInputService, SDL3InputService&gt;();</code></pre> <p>Chaining pattern (like ASP.NET middleware):</p> <pre><code>builder.Services\n    .AddInputLayerManager()  // Returns IServiceCollection\n    .AddSDL3Input();          // Chains off the return value</code></pre>"},{"location":"concepts/dependency-injection/#4-audio-services-singleton","title":"4. Audio Services (Singleton)","text":"<p>Audio mixer is shared:</p> <pre><code>builder.Services.AddSDL3Audio();\n\n// Registers:\nservices.TryAddSingleton&lt;IAudioService, SDL3AudioService&gt;();</code></pre>"},{"location":"concepts/dependency-injection/#5-game-systems-scoped","title":"5. Game Systems (Scoped)","text":"<p>Scene-specific systems:</p> <pre><code>// Collision system - one per scene\nbuilder.Services.AddCollisionSystem();\n// Registers: services.AddScoped&lt;CollisionSystem&gt;();\n\n// UI canvas - one per scene\nbuilder.Services.AddUICanvas();\n// Registers: services.AddScoped&lt;UICanvas&gt;();</code></pre> <p>Why Scoped? - Each scene gets its own instance - Scene changes = new instances - Prevents state leaking between scenes</p>"},{"location":"concepts/dependency-injection/#6-scenes-transient","title":"6. Scenes (Transient)","text":"<p>Scenes are created fresh each time:</p> <pre><code>builder.Services.AddScene&lt;MenuScene&gt;();\nbuilder.Services.AddScene&lt;GameScene&gt;();\nbuilder.Services.AddScene&lt;PauseScene&gt;();\n\n// Implementation:\npublic static IServiceCollection AddScene&lt;TScene&gt;(this IServiceCollection services)\n    where TScene : class, IScene\n{\n    services.TryAddTransient&lt;TScene&gt;();\n    return services;\n}</code></pre> <p>Why Transient? - Scenes shouldn't persist state across loads - Each load is a fresh start - Clean slate for each scene transition</p>"},{"location":"concepts/dependency-injection/#constructor-injection","title":"Constructor Injection","text":""},{"location":"concepts/dependency-injection/#basic-pattern","title":"Basic Pattern","text":"<pre><code>public class GameScene : Scene\n{\n    private readonly IRenderer _renderer;\n    private readonly IInputService _input;\n    private readonly IGameContext _gameContext;\n\n    // Constructor injection - DI fills these automatically\n    public GameScene(\n        IRenderer renderer,\n        IInputService input,\n        IGameContext gameContext,\n        ILogger&lt;GameScene&gt; logger\n    ) : base(logger)\n    {\n        _renderer = renderer;\n        _input = input;\n        _gameContext = gameContext;\n    }\n}</code></pre> <p>DI Container resolves: 1. <code>GameScene</code> requested 2. Looks at constructor parameters 3. Resolves <code>IRenderer</code> \u2192 <code>SDL3GPURenderer</code> or <code>SDL3Renderer</code> based on backend (singleton) 4. Resolves <code>IInputService</code> \u2192 <code>SDL3InputService</code> (singleton) 5. Resolves <code>IGameContext</code> \u2192 <code>GameContext</code> (singleton) 6. Resolves <code>ILogger&lt;GameScene&gt;</code> \u2192 logging framework 7. Creates <code>GameScene</code> with all dependencies</p>"},{"location":"concepts/dependency-injection/#advanced-injection","title":"Advanced Injection","text":"<pre><code>public class CollisionDemoScene : Scene\n{\n    private readonly IRenderer _renderer;\n    private readonly IInputService _input;\n    private readonly ITextureLoader _textureLoader;\n    private readonly ILoggerFactory _loggerFactory;\n    private readonly CollisionSystem _collisionSystem;\n    private readonly UICanvas _uiCanvas;\n    private readonly InputLayerManager _inputLayerManager;\n    private readonly IFontLoader _fontLoader;\n\n    public CollisionDemoScene(\n        IRenderer renderer,\n        IInputService input,\n        ITextureLoader textureLoader,\n        ILoggerFactory loggerFactory,\n        CollisionSystem collisionSystem,\n        UICanvas uiCanvas,\n        InputLayerManager inputLayerManager,\n        IFontLoader fontLoader,\n        ILogger&lt;CollisionDemoScene&gt; logger\n    ) : base(logger)\n    {\n        _renderer = renderer;\n        _input = input;\n        _textureLoader = textureLoader;\n        _loggerFactory = loggerFactory;\n        _collisionSystem = collisionSystem;\n        _uiCanvas = uiCanvas;\n        _inputLayerManager = inputLayerManager;\n        _fontLoader = fontLoader;\n    }\n}</code></pre> <p>Mixing lifetimes: - Singletons: <code>IRenderer</code>, <code>IInputService</code>, <code>ITextureLoader</code>, <code>InputLayerManager</code>, <code>IFontLoader</code> - Scoped: <code>CollisionSystem</code>, <code>UICanvas</code> - Scene-specific: <code>ILogger&lt;CollisionDemoScene&gt;</code></p>"},{"location":"concepts/dependency-injection/#extension-method-pattern","title":"Extension Method Pattern","text":"<p>Brine2D uses extension methods for service registration (ASP.NET style):</p>"},{"location":"concepts/dependency-injection/#creating-your-own","title":"Creating Your Own","text":"<pre><code>// 1. Define interface\npublic interface IParticleSystem\n{\n    void Update(float deltaTime);\n    void Render(IRenderer renderer);\n}\n\n// 2. Implement\npublic class ParticleSystem : IParticleSystem\n{\n    private readonly ILogger&lt;ParticleSystem&gt; _logger;\n\n    public ParticleSystem(ILogger&lt;ParticleSystem&gt; logger)\n    {\n        _logger = logger;\n    }\n\n    public void Update(float deltaTime) { }\n    public void Render(IRenderer renderer) { }\n}\n\n// 3. Create extension method\npublic static class ParticleServiceCollectionExtensions\n{\n    public static IServiceCollection AddParticleSystem(\n        this IServiceCollection services)\n    {\n        services.AddSingleton&lt;IParticleSystem, ParticleSystem&gt;();\n        return services;\n    }\n}\n\n// 4. Use in Program.cs\nbuilder.Services.AddParticleSystem();</code></pre>"},{"location":"concepts/dependency-injection/#configuration-binding","title":"Configuration Binding","text":"<p>Bind configuration options (like ASP.NET):</p>"},{"location":"concepts/dependency-injection/#1-define-options-class","title":"1. Define Options Class","text":"<pre><code>public class ParticleOptions\n{\n    public int MaxParticles { get; set; } = 1000;\n    public float DefaultLifetime { get; set; } = 5.0f;\n    public bool EnableGPUAcceleration { get; set; } = true;\n}</code></pre>"},{"location":"concepts/dependency-injection/#2-add-to-gamesettingsjson","title":"2. Add to gamesettings.json","text":"<pre><code>{\n  \"Particles\": {\n    \"MaxParticles\": 5000,\n    \"DefaultLifetime\": 3.0,\n    \"EnableGPUAcceleration\": true\n  }\n}</code></pre>"},{"location":"concepts/dependency-injection/#3-register-with-configuration","title":"3. Register with Configuration","text":"<pre><code>public static IServiceCollection AddParticleSystem(\n    this IServiceCollection services,\n    Action&lt;ParticleOptions&gt;? configureOptions = null)\n{\n    // Allow configuration via delegate\n    if (configureOptions != null)\n    {\n        services.Configure(configureOptions);\n    }\n\n    services.AddSingleton&lt;IParticleSystem, ParticleSystem&gt;();\n    return services;\n}</code></pre>"},{"location":"concepts/dependency-injection/#4-use-options","title":"4. Use Options","text":"<pre><code>public class ParticleSystem : IParticleSystem\n{\n    private readonly ParticleOptions _options;\n\n    public ParticleSystem(IOptions&lt;ParticleOptions&gt; options)\n    {\n        _options = options.Value;\n    }\n}</code></pre>"},{"location":"concepts/dependency-injection/#5-register-in-programcs","title":"5. Register in Program.cs","text":"<pre><code>// Option 1: Bind from config\nbuilder.Services.AddParticleSystem();\nbuilder.Configuration.GetSection(\"Particles\").Bind(\n    builder.Services.BuildServiceProvider()\n        .GetRequiredService&lt;IOptions&lt;ParticleOptions&gt;&gt;().Value);\n\n// Option 2: Configure inline\nbuilder.Services.AddParticleSystem(options =&gt;\n{\n    options.MaxParticles = 5000;\n    options.DefaultLifetime = 3.0f;\n});\n\n// Option 3: Bind from config section (best practice)\nbuilder.Services.Configure&lt;ParticleOptions&gt;(\n    builder.Configuration.GetSection(\"Particles\"));</code></pre>"},{"location":"concepts/dependency-injection/#service-resolution","title":"Service Resolution","text":""},{"location":"concepts/dependency-injection/#manual-resolution-rare","title":"Manual Resolution (Rare)","text":"<p>Sometimes you need to manually resolve services:</p> <pre><code>public class GameEngine : IGameEngine\n{\n    private readonly IServiceProvider _serviceProvider;\n\n    public GameEngine(IServiceProvider serviceProvider)\n    {\n        _serviceProvider = serviceProvider;\n    }\n\n    public async Task InitializeAsync(CancellationToken ct)\n    {\n        // Resolve optional dependency\n        var renderer = _serviceProvider.GetService&lt;IRenderer&gt;();\n        if (renderer != null)\n        {\n            await renderer.InitializeAsync(ct);\n        }\n    }\n}</code></pre> <p>Methods: - <code>GetService&lt;T&gt;()</code> - Returns null if not found - <code>GetRequiredService&lt;T&gt;()</code> - Throws if not found - <code>GetServices&lt;T&gt;()</code> - Gets all registered implementations</p>"},{"location":"concepts/dependency-injection/#scoping-and-scene-transitions","title":"Scoping and Scene Transitions","text":""},{"location":"concepts/dependency-injection/#how-scoping-works","title":"How Scoping Works","text":"<pre><code>public class SceneManager : ISceneManager\n{\n    private readonly IServiceProvider _serviceProvider;\n\n    public async Task LoadSceneAsync&lt;TScene&gt;(CancellationToken ct)\n        where TScene : IScene\n    {\n        // Unload current scene (disposes scoped services)\n        if (CurrentScene != null)\n        {\n            await CurrentScene.UnloadAsync(ct);\n        }\n\n        // Create NEW scene (creates NEW scoped services)\n        var scene = _serviceProvider.GetRequiredService&lt;TScene&gt;();\n\n        scene.Initialize();\n        await scene.LoadAsync(ct);\n\n        CurrentScene = scene;\n    }\n}</code></pre> <p>Scoped lifecycle: 1. Scene loads \u2192 Scoped services created 2. Scene runs \u2192 Services used 3. Scene unloads \u2192 Scoped services disposed 4. New scene loads \u2192 New scoped services created</p>"},{"location":"concepts/dependency-injection/#common-patterns","title":"Common Patterns","text":""},{"location":"concepts/dependency-injection/#factory-pattern","title":"Factory Pattern","text":"<pre><code>// Register factory\nbuilder.Services.AddSingleton&lt;IEnemyFactory, EnemyFactory&gt;();\n\npublic interface IEnemyFactory\n{\n    Enemy CreateEnemy(EnemyType type);\n}\n\npublic class EnemyFactory : IEnemyFactory\n{\n    private readonly ITextureLoader _textureLoader;\n    private readonly ILoggerFactory _loggerFactory;\n\n    public EnemyFactory(\n        ITextureLoader textureLoader,\n        ILoggerFactory loggerFactory)\n    {\n        _textureLoader = textureLoader;\n        _loggerFactory = loggerFactory;\n    }\n\n    public Enemy CreateEnemy(EnemyType type)\n    {\n        return type switch\n        {\n            EnemyType.Zombie =&gt; new Zombie(_textureLoader, _loggerFactory),\n            EnemyType.Spider =&gt; new Spider(_textureLoader, _loggerFactory),\n            _ =&gt; throw new ArgumentException(\"Unknown enemy type\")\n        };\n    }\n}</code></pre>"},{"location":"concepts/dependency-injection/#optional-dependencies","title":"Optional Dependencies","text":"<pre><code>public class GameScene : Scene\n{\n    private readonly IRenderer _renderer;\n    private readonly IAudioService? _audio;\n    private readonly EventBus? _eventBus;\n\n    public GameScene(\n        IRenderer renderer,\n        IAudioService? audio,      // Optional\n        EventBus? eventBus,        // Optional - for custom events\n        ILogger&lt;GameScene&gt; logger\n    ) : base(logger)\n    {\n        _renderer = renderer;\n        _audio = audio;\n        _eventBus = eventBus;\n    }\n\n    protected override void OnLoad()\n    {\n        // Subscribe to custom events\n        _eventBus?.Subscribe&lt;PlayerScoredEvent&gt;(OnPlayerScored);\n    }\n\n    protected override void OnUnload()\n    {\n        // Clean up event subscriptions\n        _eventBus?.Unsubscribe&lt;PlayerScoredEvent&gt;(OnPlayerScored);\n    }\n\n    private void OnPlayerScored(PlayerScoredEvent evt)\n    {\n        _audio?.PlaySound(\"score.wav\");\n    }\n\n    protected override void PlaySound()\n    {\n        _audio?.PlaySound(soundEffect);\n    }\n}</code></pre> <p>EventBus in v0.7.0: - <code>EventBus</code> moved from <code>Brine2D.ECS</code> to <code>Brine2D.Core</code> namespace - Now available globally without ECS dependencies - Used internally by renderers for window events (<code>WindowResizedEvent</code>) - Optional service - register with <code>builder.Services.AddSingleton&lt;EventBus&gt;()</code></p>"},{"location":"concepts/dependency-injection/#testing-with-di","title":"Testing with DI","text":"<p>DI makes testing easy:</p> <pre><code>public class GameSceneTests\n{\n    [Fact]\n    public void Update_WhenEscapePressed_RequestsExit()\n    {\n        // Arrange - mock dependencies\n        var mockRenderer = new Mock&lt;IRenderer&gt;();\n        var mockInput = new Mock&lt;IInputService&gt;();\n        var mockContext = new Mock&lt;IGameContext&gt;();\n        var mockLogger = new Mock&lt;ILogger&lt;GameScene&gt;&gt;();\n\n        mockInput.Setup(i =&gt; i.IsKeyPressed(Keys.Escape))\n            .Returns(true);\n\n        var scene = new GameScene(\n            mockRenderer.Object,\n            mockInput.Object,\n            mockContext.Object,\n            mockLogger.Object);\n\n        // Act\n        scene.Update(new GameTime(TimeSpan.Zero, TimeSpan.Zero));\n\n        // Assert\n        mockContext.Verify(c =&gt; c.RequestExit(), Times.Once);\n    }\n}</code></pre>"},{"location":"concepts/dependency-injection/#best-practices","title":"Best Practices","text":""},{"location":"concepts/dependency-injection/#do","title":"DO","text":"<ol> <li> <p>Inject interfaces, not implementations <pre><code>public GameScene(IRenderer renderer) // \u2705 Good</code></pre></p> </li> <li> <p>Use constructor injection <pre><code>public GameScene(IRenderer renderer, IInputService input) // \u2705 Good</code></pre></p> </li> <li> <p>Register services in extension methods <pre><code>builder.Services.AddMySystem(); // \u2705 Good</code></pre></p> </li> <li> <p>Use appropriate lifetimes</p> </li> <li>Singleton for expensive/global services</li> <li>Scoped for scene-specific state</li> <li> <p>Transient for lightweight/stateless objects</p> </li> <li> <p>Store dependencies in readonly fields <pre><code>private readonly IRenderer _renderer; // \u2705 Good</code></pre></p> </li> </ol>"},{"location":"concepts/dependency-injection/#dont","title":"DON'T","text":"<ol> <li> <p>Don't create dependencies manually <pre><code>var renderer = new SDL3Renderer(); // \u274c Bad - use DI</code></pre></p> </li> <li> <p>Don't use service locator anti-pattern <pre><code>var renderer = ServiceProvider.GetService&lt;IRenderer&gt;(); // \u274c Bad</code></pre></p> </li> <li> <p>Don't inject <code>IServiceProvider</code> into scenes <pre><code>public GameScene(IServiceProvider provider) // \u274c Bad - inject specific services</code></pre></p> </li> <li> <p>Don't make everything singleton</p> </li> <li>Singletons hold state forever</li> <li>Can cause memory leaks</li> <li>Harder to test</li> </ol>"},{"location":"concepts/dependency-injection/#complete-example","title":"Complete Example","text":"<p>Here's a full DI setup:</p> <pre><code>using Brine2D.Audio.SDL;\nusing Brine2D.Core;\nusing Brine2D.Core.Collision;\nusing Brine2D.Hosting;\nusing Brine2D.Input;\nusing Brine2D.Input.SDL;\nusing Brine2D.Rendering.SDL;\nusing Brine2D.UI;\nusing MyGame;\n\nvar builder = GameApplication.CreateBuilder(args);\n\n// Optional: Register EventBus for custom event handling\nbuilder.Services.AddSingleton&lt;EventBus&gt;();\n\n// Singleton services (global, expensive)\nbuilder.Services\n    .AddInputLayerManager()\n    .AddSDL3Input();\n\nbuilder.Services.AddSDL3Audio();\n\nbuilder.Services.AddSDL3Rendering(options =&gt;\n{\n    builder.Configuration.GetSection(\"Rendering\").Bind(options);\n});\n\n// Scoped services (per-scene)\nbuilder.Services.AddCollisionSystem();\nbuilder.Services.AddUICanvas();\n\n// Transient services (scenes)\nbuilder.Services.AddScene&lt;MenuScene&gt;();\nbuilder.Services.AddScene&lt;GameScene&gt;();\nbuilder.Services.AddScene&lt;PauseScene&gt;();\n\n// Custom services\nbuilder.Services.AddMyGameSystems();\n\nvar game = builder.Build();\nawait game.RunAsync&lt;MenuScene&gt;();</code></pre> <pre><code>using Microsoft.Extensions.DependencyInjection;\n\npublic static class MyGameSystemsExtensions\n{\n    public static IServiceCollection AddMyGameSystems(\n        this IServiceCollection services)\n    {\n        services.AddSingleton&lt;IEnemyFactory, EnemyFactory&gt;();\n        services.AddScoped&lt;ILevelManager, LevelManager&gt;();\n        services.AddTransient&lt;IParticleEmitter, ParticleEmitter&gt;();\n\n        return services;\n    }\n}</code></pre>"},{"location":"concepts/dependency-injection/#troubleshooting","title":"Troubleshooting","text":""},{"location":"concepts/dependency-injection/#service-not-found-error","title":"\"Service not found\" Error","text":"<pre><code>System.InvalidOperationException: No service for type 'IRenderer' has been registered.</code></pre> <p>Solution: Make sure you registered the service:</p> <pre><code>builder.Services.AddSDL3Rendering(); // Missing this!</code></pre>"},{"location":"concepts/dependency-injection/#circular-dependency-error","title":"\"Circular Dependency\" Error","text":"<pre><code>System.InvalidOperationException: A circular dependency was detected.</code></pre> <p>Solution: Refactor to break the cycle:</p> <pre><code>// BAD:\nA depends on B\nB depends on A\n\n// GOOD:\nA depends on IInterface\nB depends on IInterface\nC implements IInterface</code></pre>"},{"location":"concepts/dependency-injection/#wrong-lifetime","title":"Wrong Lifetime","text":"<pre><code>// Symptom: State persists between scenes when it shouldn't</code></pre> <p>Solution: Change from Singleton to Scoped:</p> <pre><code>services.AddSingleton&lt;CollisionSystem&gt;(); // \u274c Wrong\nservices.AddScoped&lt;CollisionSystem&gt;();    // \u2705 Correct</code></pre>"},{"location":"concepts/dependency-injection/#summary","title":"Summary","text":"Concept Description Service Lifetimes Singleton (app), Scoped (scene), Transient (always new) Constructor Injection Dependencies passed to constructor automatically Extension Methods <code>AddXXX()</code> pattern for clean registration Configuration Binding <code>IOptions&lt;T&gt;</code> pattern for settings Testability Easy to mock dependencies in unit tests"},{"location":"concepts/dependency-injection/#next-steps","title":"Next Steps","text":"<ul> <li>Builder Pattern - Master <code>GameApplicationBuilder</code></li> <li>Scene Management - Understand scene scoping</li> <li>Configuration - Deep dive into options pattern</li> <li>Testing - Write testable game code</li> </ul> <p>Ready to build your own services? Start with Builder Pattern!</p>"},{"location":"concepts/entity-component-system/","title":"Entity Component System","text":"<p>Brine2D features a hybrid object-based ECS that combines the flexibility of traditional object-oriented programming with the performance benefits of component-based architecture. Unlike pure data-oriented ECS frameworks, Brine2D's approach is designed for rapid game development while still offering optimization paths when needed.</p>"},{"location":"concepts/entity-component-system/#what-is-hybrid-ecs","title":"What is Hybrid ECS?","text":"<p>Brine2D's ECS is \"hybrid\" because it bridges two worlds:</p> <p>Traditional OOP: - Components are classes (not structs) - Components can contain logic - Easy to learn and prototype with</p> <p>Performance-Oriented ECS: - Optional systems for batch processing - Entity queries for efficient lookups - Component-based composition - Automatic system execution via lifecycle hooks</p> <p>Think of it as \"ASP.NET for game entities\" - familiar patterns with performance when you need it.</p>"},{"location":"concepts/entity-component-system/#core-concepts","title":"Core Concepts","text":""},{"location":"concepts/entity-component-system/#entities","title":"Entities","text":"<p>Entities are containers for components. They're like game objects but lightweight.</p> <pre><code>// Create an entity\nvar player = world.CreateEntity(\"Player\");\nplayer.Tags.Add(\"Player\");\n\n// Entities have:\n// - Id (unique identifier)\n// - Name (for debugging)\n// - Tags (for querying)\n// - Components (the data and behavior)</code></pre> <p>Think of entities as: - Rows in a database - Game objects in Unity - Containers that hold components</p>"},{"location":"concepts/entity-component-system/#components","title":"Components","text":"<p>Components are classes that inherit from <code>Component</code> and can contain both data and logic.</p> <pre><code>using Brine2D.Core;\nusing Brine2D.ECS;\n\n// Simple data component\npublic class HealthComponent : Component\n{\n    public float Current { get; set; }\n    public float Max { get; set; }\n\n    public float Percentage =&gt; Current / Max;\n}\n\n// Component with logic\npublic class LifetimeComponent : Component\n{\n    public float Lifetime { get; set; }\n\n    protected internal override void OnUpdate(GameTime gameTime)\n    {\n        Lifetime -= (float)gameTime.DeltaTime;\n        if (Lifetime &lt;= 0) Entity?.Destroy();\n    }\n}</code></pre> <p>Key features: - Inherit from <code>Component</code> base class - Can override lifecycle methods (<code>OnUpdate</code>, <code>OnAdded</code>, etc.) - Access other components via <code>Entity</code> - Can be enabled/disabled - Update automatically via <code>SceneManager</code></p>"},{"location":"concepts/entity-component-system/#systems-optional","title":"Systems (Optional)","text":"<p>Systems are performance optimizations that batch-process many entities with specific components.</p> <pre><code>using Brine2D.ECS.Systems;\n\npublic class VelocitySystem : IUpdateSystem\n{\n    private readonly IEntityWorld _world;\n    public int UpdateOrder =&gt; 100;\n\n    public void Update(GameTime gameTime)\n    {\n        // Process ALL entities with Transform + Velocity efficiently\n        var entities = _world.GetEntitiesWithComponents&lt;TransformComponent, VelocityComponent&gt;();\n        var deltaTime = (float)gameTime.DeltaTime;\n\n        foreach (var entity in entities)\n        {\n            var transform = entity.GetComponent&lt;TransformComponent&gt;()!;\n            var velocity = entity.GetComponent&lt;VelocityComponent&gt;()!;\n\n            transform.Position += velocity.Velocity * deltaTime;\n        }\n    }\n}</code></pre> <p>When to use: - 50+ entities need the same processing - Performance is critical - Explicit execution order needed</p> <p>Once registered via <code>ConfigureSystemPipelines()</code>, systems run automatically via lifecycle hooks!</p>"},{"location":"concepts/entity-component-system/#architecture-comparison","title":"Architecture Comparison","text":""},{"location":"concepts/entity-component-system/#traditional-oop-unity-style","title":"Traditional OOP (Unity-style)","text":"<p>```mermaid graph TD     GO1[\"GameObject: Player\"] --&gt; C1[\"Health: 100\"]     GO1 --&gt; C2[\"Movement Script\"]     GO1 --&gt; C3[\"Render Script\"]</p> <pre><code>GO2[\"GameObject: Enemy\"] --&gt; C4[\"Health: 50\"]\nGO2 --&gt; C5[\"AI Script\"]\nGO2 --&gt; C6[\"Render Script\"]\n\nstyle GO1 fill:#264f78,stroke:#4fc1ff,stroke-width:2px,color:#fff\nstyle GO2 fill:#264f78,stroke:#4fc1ff,stroke-width:2px,color:#fff\nstyle C1 fill:#2d5016,stroke:#4ec9b0,stroke-width:2px,color:#fff\nstyle C2 fill:#2d5016,stroke:#4ec9b0,stroke-width:2px,color:#fff\nstyle C3 fill:#2d5016,stroke:#4ec9b0,stroke-width:2px,color:#fff\nstyle C4 fill:#2d5016,stroke:#4ec9b0,stroke-width:2px,color:#fff\nstyle C5 fill:#2d5016,stroke:#4ec9b0,stroke-width:2px,color:#fff\nstyle C6 fill:#2d5016,stroke:#4ec9b0,stroke-width:2px,color:#fff</code></pre> <p>```</p> <p>Characteristics: - Components update individually - Easy to write and understand - Can be slow with many objects</p>"},{"location":"concepts/entity-component-system/#brine2d-hybrid-ecs","title":"Brine2D Hybrid ECS","text":"<p>```mermaid graph TD     subgraph \"Entities\"         E1[\"Entity: Player\"]         E2[\"Entity: Enemy\"]     end</p> <pre><code>subgraph \"Components (Data + Logic)\"\n    E1 --&gt; C1[\"Transform\"]\n    E1 --&gt; C2[\"Health\"]\n    E1 --&gt; C3[\"PlayerController\"]\n\n    E2 --&gt; C4[\"Transform\"]\n    E2 --&gt; C5[\"Health\"]\n    E2 --&gt; C6[\"AIController\"]\nend\n\nsubgraph \"Systems (Optional Performance)\"\n    S1[\"VelocitySystem\"] -.processes.-&gt; C1\n    S1 -.processes.-&gt; C4\n    S2[\"RenderSystem\"] -.processes.-&gt; C1\n    S2 -.processes.-&gt; C4\nend\n\nsubgraph \"Automatic Execution\"\n    SM[\"SceneManager\"] -.runs automatically.-&gt; S1\n    SM -.runs automatically.-&gt; S2\nend\n\nstyle E1 fill:#264f78,stroke:#4fc1ff,stroke-width:2px,color:#fff\nstyle E2 fill:#264f78,stroke:#4fc1ff,stroke-width:2px,color:#fff\nstyle C1 fill:#2d5016,stroke:#4ec9b0,stroke-width:2px,color:#fff\nstyle C2 fill:#2d5016,stroke:#4ec9b0,stroke-width:2px,color:#fff\nstyle C3 fill:#2d5016,stroke:#4ec9b0,stroke-width:2px,color:#fff\nstyle C4 fill:#2d5016,stroke:#4ec9b0,stroke-width:2px,color:#fff\nstyle C5 fill:#2d5016,stroke:#4ec9b0,stroke-width:2px,color:#fff\nstyle C6 fill:#2d5016,stroke:#4ec9b0,stroke-width:2px,color:#fff\nstyle S1 fill:#1e3a5f,stroke:#569cd6,stroke-width:2px,color:#fff\nstyle S2 fill:#1e3a5f,stroke:#569cd6,stroke-width:2px,color:#fff\nstyle SM fill:#4a2d4a,stroke:#c586c0,stroke-width:2px,color:#fff</code></pre> <p>```</p> <p>Characteristics: - Components can update themselves (rapid prototyping) - Systems available for performance (batch processing) - Systems run automatically via lifecycle hooks - Best of both worlds</p>"},{"location":"concepts/entity-component-system/#practical-example-building-a-game","title":"Practical Example: Building a Game","text":"<p>Let's build a simple game to see how everything works together.</p>"},{"location":"concepts/entity-component-system/#step-1-define-components","title":"Step 1: Define Components","text":"<pre><code>// Position in world\npublic class TransformComponent : Component\n{\n    public Vector2 Position { get; set; }\n    public float Rotation { get; set; }\n}\n\n// Movement velocity (processed by VelocitySystem)\npublic class VelocityComponent : Component\n{\n    public Vector2 Velocity { get; set; }\n    public float MaxSpeed { get; set; } = 200f;\n}\n\n// Player input (processed by PlayerControllerSystem)\npublic class PlayerControllerComponent : Component\n{\n    public float MoveSpeed { get; set; } = 200f;\n}\n\n// Auto-destroy (self-contained logic)\npublic class LifetimeComponent : Component\n{\n    public float Lifetime { get; set; }\n\n    protected internal override void OnUpdate(GameTime gameTime)\n    {\n        Lifetime -= (float)gameTime.DeltaTime;\n        if (Lifetime &lt;= 0) Entity?.Destroy();\n    }\n}</code></pre>"},{"location":"concepts/entity-component-system/#step-2-create-entities","title":"Step 2: Create Entities","text":"<pre><code>// Create player\nvar player = world.CreateEntity(\"Player\");\nplayer.Tags.Add(\"Player\");\n\nplayer.AddComponent&lt;TransformComponent&gt;().Position = new Vector2(400, 300);\nplayer.AddComponent&lt;VelocityComponent&gt;();\nplayer.AddComponent&lt;PlayerControllerComponent&gt;();\n\n// Create bullet (with lifetime)\nvar bullet = world.CreateEntity(\"Bullet\");\nbullet.AddComponent&lt;TransformComponent&gt;().Position = player.GetComponent&lt;TransformComponent&gt;()!.Position;\nbullet.AddComponent&lt;VelocityComponent&gt;().Velocity = new Vector2(500, 0);\nbullet.AddComponent&lt;LifetimeComponent&gt;().Lifetime = 3f; // Auto-destroy after 3 seconds</code></pre>"},{"location":"concepts/entity-component-system/#step-3-register-systems-optional","title":"Step 3: Register Systems (Optional)","text":"<pre><code>// In Program.cs\nbuilder.Services.ConfigureSystemPipelines(pipelines =&gt;\n{\n    pipelines.AddSystem&lt;PlayerControllerSystem&gt;();  // Read input\n    pipelines.AddSystem&lt;VelocitySystem&gt;();          // Apply movement\n    pipelines.AddSystem&lt;SpriteRenderingSystem&gt;();   // Draw sprites\n});</code></pre> <p>Systems run automatically via lifecycle hooks - no manual calls needed!</p>"},{"location":"concepts/entity-component-system/#step-4-use-in-scene","title":"Step 4: Use in Scene","text":"<pre><code>public class GameScene : Scene\n{\n    private readonly IEntityWorld _world;\n    private readonly IRenderer _renderer;\n\n    protected override void OnInitialize()\n    {\n        _renderer.ClearColor = new Color(40, 40, 60);\n\n        // Create entities\n        var player = _world.CreateEntity(\"Player\");\n        player.AddComponent&lt;TransformComponent&gt;();\n        player.AddComponent&lt;VelocityComponent&gt;();\n        player.AddComponent&lt;PlayerControllerComponent&gt;();\n    }\n\n    protected override void OnUpdate(GameTime gameTime)\n    {\n        // Just scene-specific logic\n        CheckWinCondition();\n\n        // Systems run automatically!\n        // Component OnUpdate() runs automatically!\n    }\n\n    protected override void OnRender(GameTime gameTime)\n    {\n        // Frame management automatic!\n        // Sprites already rendered by SpriteRenderingSystem!\n\n        // Just draw UI\n        _renderer.DrawText($\"Score: {_score}\", 10, 10, Color.White);\n    }\n}</code></pre> <p>Notice: No manual <code>_updatePipeline.Execute()</code> or <code>_world.Update()</code> calls needed!</p>"},{"location":"concepts/entity-component-system/#component-lifecycle","title":"Component Lifecycle","text":"<p>Components have several lifecycle hooks:</p> <p>```mermaid sequenceDiagram     participant E as Entity     participant C as Component     participant SM as SceneManager</p> <pre><code>E-&gt;&gt;C: AddComponent()\nC-&gt;&gt;C: OnAdded()\nNote over C: Initialize component\n\nloop Every Frame (Automatic)\n    SM-&gt;&gt;C: OnUpdate(gameTime)\n    Note over C: Component logic runs automatically\nend\n\nE-&gt;&gt;C: IsEnabled = false\nC-&gt;&gt;C: OnDisabled()\n\nE-&gt;&gt;C: IsEnabled = true\nC-&gt;&gt;C: OnEnabled()\n\nE-&gt;&gt;C: RemoveComponent()\nC-&gt;&gt;C: OnRemoved()\nNote over C: Cleanup</code></pre> <p>```</p> <pre><code>public class MyComponent : Component\n{\n    protected internal override void OnAdded()\n    {\n        // Called when added to entity\n        Logger.LogInformation(\"Component added!\");\n    }\n\n    protected internal override void OnUpdate(GameTime gameTime)\n    {\n        // Called every frame if enabled\n        // Runs automatically via SceneManager!\n    }\n\n    protected internal override void OnEnabled()\n    {\n        // Called when component is enabled\n    }\n\n    protected internal override void OnDisabled()\n    {\n        // Called when component is disabled\n    }\n\n    protected internal override void OnRemoved()\n    {\n        // Called when removed from entity\n        // Cleanup here\n    }\n}</code></pre>"},{"location":"concepts/entity-component-system/#design-patterns","title":"Design Patterns","text":""},{"location":"concepts/entity-component-system/#composition-over-inheritance","title":"Composition Over Inheritance","text":"<p>Build complex entities by combining simple components:</p> <pre><code>// Flying enemy = Transform + AI + Flying behavior\nvar flyingEnemy = world.CreateEntity(\"FlyingEnemy\");\nflyingEnemy.AddComponent&lt;TransformComponent&gt;();\nflyingEnemy.AddComponent&lt;VelocityComponent&gt;();\nflyingEnemy.AddComponent&lt;AIControllerComponent&gt;();\nflyingEnemy.AddComponent&lt;FlyingMovementComponent&gt;();\nflyingEnemy.AddComponent&lt;SpriteComponent&gt;();\n\n// Boss = Everything above + special abilities\nvar boss = world.CreateEntity(\"Boss\");\nboss.AddComponent&lt;TransformComponent&gt;();\nboss.AddComponent&lt;VelocityComponent&gt;();\nboss.AddComponent&lt;AIControllerComponent&gt;();\nboss.AddComponent&lt;FlyingMovementComponent&gt;();\nboss.AddComponent&lt;SpriteComponent&gt;();\nboss.AddComponent&lt;BossAbilitiesComponent&gt;(); // Unique!\nboss.AddComponent&lt;HealthComponent&gt;().Max = 1000; // Lots of health</code></pre> <p>No inheritance hierarchy needed!</p>"},{"location":"concepts/entity-component-system/#using-prefabs","title":"Using Prefabs","text":"<p>Reuse entity templates:</p> <pre><code>// Create prefab once\nvar enemyPrefab = new EntityPrefab(\"Enemy\");\nenemyPrefab.AddComponent&lt;TransformComponent&gt;();\nenemyPrefab.AddComponent&lt;VelocityComponent&gt;();\nenemyPrefab.AddComponent&lt;AIControllerComponent&gt;(ai =&gt;\n{\n    ai.Behavior = AIBehavior.Chase;\n    ai.MoveSpeed = 100f;\n});\n\n// Register prefab\nprefabLibrary.Register(enemyPrefab);\n\n// Instantiate many times\nfor (int i = 0; i &lt; 10; i++)\n{\n    var enemy = enemyPrefab.Instantiate(world, new Vector2(i * 100, 200));\n}</code></pre>"},{"location":"concepts/entity-component-system/#component-communication","title":"Component Communication","text":"<p>Components can interact:</p> <pre><code>public class DamageOnContactComponent : Component\n{\n    public float Damage { get; set; } = 10f;\n\n    protected internal override void OnUpdate(GameTime gameTime)\n    {\n        // Get other components on same entity\n        var collider = Entity?.GetComponent&lt;ColliderComponent&gt;();\n        if (collider == null) return;\n\n        // Check collisions\n        foreach (var other in GetCollidingEntities())\n        {\n            var health = other.GetComponent&lt;HealthComponent&gt;();\n            if (health != null)\n            {\n                health.Current -= Damage;\n            }\n        }\n    }\n}</code></pre>"},{"location":"concepts/entity-component-system/#when-to-use-what","title":"When to Use What","text":""},{"location":"concepts/entity-component-system/#use-component-logic-when","title":"Use Component Logic When:","text":"<p>\u2705 Few entities (&lt;50) with this behavior \u2705 Simple, self-contained logic \u2705 Rapid prototyping \u2705 Unique per-entity behavior  </p> <p>Example: <pre><code>public class FollowMouseComponent : Component\n{\n    protected internal override void OnUpdate(GameTime gameTime)\n    {\n        var input = Entity?.World?.Services.GetService&lt;IInputService&gt;();\n        var transform = Entity?.GetComponent&lt;TransformComponent&gt;();\n\n        if (input != null &amp;&amp; transform != null)\n        {\n            transform.Position = input.MousePosition;\n        }\n    }\n}</code></pre></p>"},{"location":"concepts/entity-component-system/#use-systems-when","title":"Use Systems When:","text":"<p>\u2705 Many entities (50+) need same processing \u2705 Performance is critical \u2705 Cross-entity queries needed \u2705 Specific execution order required  </p> <p>Example: <pre><code>public class VelocitySystem : IUpdateSystem\n{\n    public int UpdateOrder =&gt; 100;\n\n    public void Update(GameTime gameTime)\n    {\n        // Efficiently process all moving entities\n        var entities = _world.GetEntitiesWithComponents&lt;TransformComponent, VelocityComponent&gt;();\n        var deltaTime = (float)gameTime.DeltaTime;\n\n        foreach (var entity in entities)\n        {\n            var transform = entity.GetComponent&lt;TransformComponent&gt;()!;\n            var velocity = entity.GetComponent&lt;VelocityComponent&gt;()!;\n\n            transform.Position += velocity.Velocity * deltaTime;\n        }\n    }\n}</code></pre></p> <p>Remember: Once registered, systems run automatically via lifecycle hooks!</p>"},{"location":"concepts/entity-component-system/#aspnet-parallels","title":"ASP.NET Parallels","text":"<p>Brine2D's ECS mirrors ASP.NET patterns:</p> ASP.NET Brine2D ECS Purpose <code>Controller</code> <code>Entity</code> Container for logic <code>Service</code> <code>Component</code> Specific functionality <code>Middleware</code> <code>System</code> Processing pipeline <code>IOptions&lt;T&gt;</code> Component properties Configuration <code>ILogger&lt;T&gt;</code> Component events Diagnostics DI Container <code>IEntityWorld</code> Service location Auto-execution Lifecycle hooks Automatic behavior <p>Example:</p> <pre><code>// ASP.NET Controller\npublic class PlayerController : ControllerBase\n{\n    private readonly IPlayerService _player;\n    public PlayerController(IPlayerService player) { }\n}\n\n// Brine2D Entity\nvar player = world.CreateEntity(\"Player\");\nplayer.AddComponent&lt;TransformComponent&gt;();\nplayer.AddComponent&lt;PlayerControllerComponent&gt;();</code></pre> <p>Both use dependency injection and composition!</p>"},{"location":"concepts/entity-component-system/#performance-characteristics","title":"Performance Characteristics","text":""},{"location":"concepts/entity-component-system/#component-updates","title":"Component Updates","text":"<ul> <li>Components update in order they were added</li> <li>Skipped if <code>IsEnabled = false</code></li> <li>Run automatically via <code>SceneManager</code></li> <li>Good for &lt;50 entities per component type</li> </ul>"},{"location":"concepts/entity-component-system/#system-processing","title":"System Processing","text":"<ul> <li>Batch processes all matching entities</li> <li>Explicit execution order (<code>UpdateOrder</code>)</li> <li>Run automatically via lifecycle hooks</li> <li>Efficient for 50+ entities</li> </ul>"},{"location":"concepts/entity-component-system/#querying","title":"Querying","text":"<pre><code>// Fast - uses internal indexing\nvar players = world.GetEntitiesByTag(\"Player\");\nvar moving = world.GetEntitiesWithComponents&lt;TransformComponent, VelocityComponent&gt;();\n\n// Slower - linear search\nvar specific = world.FindEntity(e =&gt; e.Name == \"Boss\" &amp;&amp; e.IsActive);</code></pre>"},{"location":"concepts/entity-component-system/#quick-reference","title":"Quick Reference","text":""},{"location":"concepts/entity-component-system/#entity-operations","title":"Entity Operations","text":"<pre><code>var entity = world.CreateEntity(\"Name\");\nentity.Tags.Add(\"Player\");\nentity.IsActive = false; // Disable\nworld.DestroyEntity(entity);</code></pre>"},{"location":"concepts/entity-component-system/#component-operations","title":"Component Operations","text":"<pre><code>var health = entity.AddComponent&lt;HealthComponent&gt;();\nhealth.Current = 100;\n\nvar health = entity.GetComponent&lt;HealthComponent&gt;();\nbool has = entity.HasComponent&lt;HealthComponent&gt;();\nentity.RemoveComponent&lt;HealthComponent&gt;();\n\nhealth.IsEnabled = false; // Disable component</code></pre>"},{"location":"concepts/entity-component-system/#querying_1","title":"Querying","text":"<pre><code>var all = world.Entities;\nvar tagged = world.GetEntitiesByTag(\"Enemy\");\nvar withHealth = world.GetEntitiesWithComponent&lt;HealthComponent&gt;();\nvar moving = world.GetEntitiesWithComponents&lt;TransformComponent, VelocityComponent&gt;();\nvar player = world.FindEntity(e =&gt; e.Name == \"Player\");</code></pre>"},{"location":"concepts/entity-component-system/#next-steps","title":"Next Steps","text":"<p>Now that you understand the concepts, start building:</p> <p>ECS Getting Started - Build your first ECS game in 15 minutes Components Guide - Learn component design patterns Systems Guide - Create efficient systems for performance Scene Management - See how automatic execution works</p> <p>Remember: Brine2D's hybrid ECS gives you flexibility. Start with component logic for rapid development, add systems when you need performance. Systems and component updates run automatically via lifecycle hooks - no manual calls needed! Choose what fits your needs!</p>"},{"location":"concepts/game-loop/","title":"Game Loop","text":"<p>The game loop is the heart of every game engine. It's the endless cycle that keeps your game running, processing input, updating game logic, and rendering graphics at a consistent rate.</p>"},{"location":"concepts/game-loop/#game-loop-overview","title":"Game Loop Overview","text":"<pre><code>sequenceDiagram\n    participant GL as GameLoop\n    participant IN as InputService\n    participant ILM as InputLayerManager\n    participant SM as SceneManager\n    participant S as Scene\n    participant R as Renderer\n\n    Note over GL: Start Loop (60 FPS target)\n\n    loop Every Frame (~16.67ms)\n        GL-&gt;&gt;GL: Calculate Delta Time\n        GL-&gt;&gt;IN: Update() - Poll SDL Events\n        IN-&gt;&gt;GL: Input Ready\n\n        GL-&gt;&gt;ILM: ProcessInput()\n        ILM-&gt;&gt;ILM: UI consumes first?\n        ILM-&gt;&gt;GL: Input Layers Processed\n\n        Note over GL: Check for Quit Event\n\n        GL-&gt;&gt;GL: Create GameTime\n        GL-&gt;&gt;SM: Update(gameTime)\n        SM-&gt;&gt;S: OnUpdate(gameTime)\n        S-&gt;&gt;S: Game Logic\n\n        GL-&gt;&gt;SM: Render(gameTime)\n        SM-&gt;&gt;S: OnRender(gameTime)\n        S-&gt;&gt;R: Draw Calls\n        R-&gt;&gt;R: Present Frame\n\n        GL-&gt;&gt;GL: Frame Limiting\n        Note over GL: Sleep + SpinWait for precision\n    end</code></pre>"},{"location":"concepts/game-loop/#game-loop-phases","title":"Game Loop Phases","text":""},{"location":"concepts/game-loop/#phase-1-input-processing","title":"Phase 1: Input Processing","text":"<p>Purpose: Poll hardware devices and prepare input state</p> <pre><code>// Update input (polls SDL events)\n_inputService.Update();\n\n// Process input layers (like middleware)\n_inputLayerManager.ProcessInput();\n\n// Check for quit event from window close\nif (_inputService.IsQuitRequested)\n{\n    _gameContext.RequestExit();\n}</code></pre> <p>What happens: 1. SDL events are polled (keyboard, mouse, gamepad, window events) 2. Input layers process in priority order (UI first, then game) 3. Quit events are detected (window close, Alt+F4, etc.)</p>"},{"location":"concepts/game-loop/#phase-2-time-calculation","title":"Phase 2: Time Calculation","text":"<p>Purpose: Track elapsed time for frame-rate independent gameplay</p> <pre><code>var currentTime = _stopwatch.Elapsed;\nvar elapsedTime = currentTime - lastFrameTime;\nlastFrameTime = currentTime;\ntotalTime += elapsedTime;\n\nvar gameTime = new GameTime(totalTime, elapsedTime);</code></pre> <p>GameTime Structure:</p> <pre><code>public readonly struct GameTime\n{\n    public TimeSpan TotalTime { get; init; }    // Total elapsed since start\n    public TimeSpan ElapsedTime { get; init; }  // Time since last frame\n    public double DeltaTime =&gt; ElapsedTime.TotalSeconds;  // Seconds as double\n    public double TotalSeconds =&gt; TotalTime.TotalSeconds; // Total as seconds\n}</code></pre> <p>Usage in scenes:</p> <pre><code>protected override void OnUpdate(GameTime gameTime)\n{\n    var deltaTime = (float)gameTime.DeltaTime;  // ~0.0166 at 60 FPS\n\n    // Frame-rate independent movement\n    position += velocity * speed * deltaTime;\n\n    // Animation timing\n    _animator.Update(deltaTime);\n}</code></pre>"},{"location":"concepts/game-loop/#phase-3-update-logic","title":"Phase 3: Update Logic","text":"<p>Purpose: Execute game logic, physics, AI, etc.</p> <pre><code>// Update game context time\nif (_gameContext is GameContext context)\n{\n    context.GameTime = gameTime;\n}\n\n// Update current scene\n_sceneManager.Update(gameTime);</code></pre> <p>Scene Update Flow:</p> <pre><code>graph TD\n    A[\"GameLoop.RunAsync()\"] --&gt; B[\"SceneManager.Update(gameTime)\"]\n    B --&gt; C[\"CurrentScene.Update(gameTime)\"]\n    C --&gt; D[\"OnUpdate(gameTime)\"]\n\n    D --&gt; E[\"Process Input\"]\n    D --&gt; F[\"Update Physics\"]\n    D --&gt; G[\"Update Animations\"]\n    D --&gt; H[\"Update AI\"]\n    D --&gt; I[\"Check Collisions\"]\n\n    style A fill:#1e3a5f,stroke:#569cd6,stroke-width:2px,color:#fff\nstyle B fill:#2d5016,stroke:#4ec9b0,stroke-width:2px,color:#fff\nstyle C fill:#2d5016,stroke:#4ec9b0,stroke-width:2px,color:#fff\nstyle D fill:#3d3d2a,stroke:#dcdcaa,stroke-width:2px,color:#fff\nstyle E fill:#4a3d1f,stroke:#ce9178,stroke-width:2px,color:#fff\nstyle F fill:#4a3d1f,stroke:#ce9178,stroke-width:2px,color:#fff\nstyle G fill:#4a3d1f,stroke:#ce9178,stroke-width:2px,color:#fff\nstyle H fill:#4a3d1f,stroke:#ce9178,stroke-width:2px,color:#fff\nstyle I fill:#4a3d1f,stroke:#ce9178,stroke-width:2px,color:#fff</code></pre>"},{"location":"concepts/game-loop/#phase-4-rendering","title":"Phase 4: Rendering","text":"<p>Purpose: Draw all visual elements to the screen</p> <pre><code>// Render current scene\n_sceneManager.Render(gameTime);</code></pre> <p>Rendering Flow:</p> <pre><code>graph TD\n    A[\"GameLoop.RunAsync()\"] --&gt; B[\"SceneManager.Render(gameTime)\"]\n    B --&gt; C[\"CurrentScene.Render(gameTime)\"]\n    C --&gt; D[\"OnRender(gameTime)\"]\n\n    D --&gt; E[\"_renderer.Clear(color)\"]\n    D --&gt; F[\"_renderer.BeginFrame()\"]\n    D --&gt; G[\"Draw Background\"]\n    D --&gt; H[\"Draw Game Objects\"]\n    D --&gt; I[\"Draw UI\"]\n    D --&gt; J[\"_renderer.EndFrame()\"]\n\n    J --&gt; K[\"SDL.RenderPresent()\"]\n    K --&gt; L[\"Display on Screen\"]\n\n    style A fill:#1e3a5f,stroke:#569cd6,stroke-width:2px,color:#fff\nstyle B fill:#2d5016,stroke:#4ec9b0,stroke-width:2px,color:#fff\nstyle C fill:#2d5016,stroke:#4ec9b0,stroke-width:2px,color:#fff\nstyle D fill:#3d3d2a,stroke:#dcdcaa,stroke-width:2px,color:#fff\nstyle E fill:#4a2d4a,stroke:#c586c0,stroke-width:2px,color:#fff\nstyle F fill:#4a2d4a,stroke:#c586c0,stroke-width:2px,color:#fff\nstyle G fill:#4a3d1f,stroke:#ce9178,stroke-width:2px,color:#fff\nstyle H fill:#4a3d1f,stroke:#ce9178,stroke-width:2px,color:#fff\nstyle I fill:#4a3d1f,stroke:#ce9178,stroke-width:2px,color:#fff\nstyle J fill:#4a2d4a,stroke:#c586c0,stroke-width:2px,color:#fff\nstyle K fill:#4a2d4a,stroke:#c586c0,stroke-width:2px,color:#fff\nstyle L fill:#264f78,stroke:#4fc1ff,stroke-width:2px,color:#fff</code></pre>"},{"location":"concepts/game-loop/#phase-5-frame-limiting","title":"Phase 5: Frame Limiting","text":"<p>Purpose: Maintain consistent frame rate (default 60 FPS)</p> <pre><code>var targetFrameTime = TimeSpan.FromSeconds(1.0 / TargetFramesPerSecond);\n\n// Frame limiting\nvar frameTime = _stopwatch.Elapsed - currentTime;\nif (frameTime &lt; targetFrameTime)\n{\n    var sleepTime = targetFrameTime - frameTime;\n\n    // Sleep for most of the time (OS scheduler)\n    if (sleepTime &gt; TimeSpan.FromMilliseconds(1))\n    {\n        Thread.Sleep(sleepTime - TimeSpan.FromMilliseconds(1));\n    }\n\n    // Spin for precision timing on the last millisecond\n    while (_stopwatch.Elapsed - currentTime &lt; targetFrameTime)\n    {\n        Thread.SpinWait(100);\n    }\n}</code></pre> <p>Why two-phase timing? 1. <code>Thread.Sleep()</code> - Efficient but imprecise (~15ms resolution on Windows) 2. <code>Thread.SpinWait()</code> - Precise but burns CPU (~1ms precision)</p> <p>Hybrid approach: - Sleep for most of the time (save CPU) - Spin-wait for the last millisecond (precision)</p>"},{"location":"concepts/game-loop/#frame-timing","title":"Frame Timing","text":""},{"location":"concepts/game-loop/#target-frame-rate","title":"Target Frame Rate","text":"<p>Default: 60 FPS (16.67ms per frame)</p> <pre><code>public int TargetFramesPerSecond { get; set; } = 60;</code></pre> <p>Frame budgets:</p> FPS Frame Time Use Case 30 33.33ms Low-power devices, slow games 60 16.67ms Standard (smooth gameplay) 120 8.33ms High-refresh displays 144 6.94ms Competitive gaming Uncapped Variable Benchmarking, menu screens"},{"location":"concepts/game-loop/#frame-budget-breakdown","title":"Frame Budget Breakdown","text":"<p>At 60 FPS (16.67ms per frame):</p> <pre><code>graph LR\n    A[\"Frame Budget: 16.67ms\"] --&gt; B[\"Input: &lt;1ms\"]\n    A --&gt; C[\"Update: ~10ms\"]\n    A --&gt; D[\"Render: ~5ms\"]\n    A --&gt; E[\"Frame Limit: ~1ms\"]\n\n    style A fill:#1e3a5f,stroke:#569cd6,stroke-width:3px,color:#fff\nstyle B fill:#2d5016,stroke:#4ec9b0,stroke-width:2px,color:#fff\nstyle C fill:#3d3d2a,stroke:#dcdcaa,stroke-width:2px,color:#fff\nstyle D fill:#4a3d1f,stroke:#ce9178,stroke-width:2px,color:#fff\nstyle E fill:#4a2d4a,stroke:#c586c0,stroke-width:2px,color:#fff</code></pre> Phase Time Budget What Can Go Wrong Input &lt;1ms Rare, unless reading massive controller DB Update ~10ms Complex physics, AI, too many entities Render ~5ms Draw calls, texture uploads, shader compilation Frame Limiting ~1ms Precision timing overhead"},{"location":"concepts/game-loop/#delta-time","title":"Delta Time","text":"<p>Frame-rate independent gameplay requires delta time:</p>"},{"location":"concepts/game-loop/#without-delta-time-bad","title":"Without Delta Time (Bad)","text":"<pre><code>// BAD: Speed depends on frame rate\nposition += velocity;  // Faster at 120 FPS, slower at 30 FPS</code></pre>"},{"location":"concepts/game-loop/#with-delta-time-good","title":"With Delta Time (Good)","text":"<pre><code>// GOOD: Speed is consistent at any frame rate\nvar deltaTime = (float)gameTime.DeltaTime;\nposition += velocity * speed * deltaTime;</code></pre> <p>Example:</p> FPS Delta Time Movement per Frame Movement per Second 30 0.0333s 200 * 0.0333 = 6.67 200 pixels 60 0.0166s 200 * 0.0166 = 3.33 200 pixels 120 0.0083s 200 * 0.0083 = 1.67 200 pixels <p>Speed is always 200 pixels/second regardless of frame rate!</p>"},{"location":"concepts/game-loop/#game-loop-lifecycle","title":"Game Loop Lifecycle","text":"<pre><code>stateDiagram-v2\n    [*] --&gt; Created: GameLoop Constructor\n    Created --&gt; Starting: RunAsync() Called\n    Starting --&gt; Running: IsRunning = true\n    Running --&gt; Running: Every Frame\n    Running --&gt; Stopping: Stop() or Cancel\n    Stopping --&gt; Stopped: IsRunning = false\n    Stopped --&gt; [*]\n\n    Running --&gt; Error: Exception\n    Error --&gt; Stopping: Catch &amp; Log</code></pre>"},{"location":"concepts/game-loop/#startup-sequence","title":"Startup Sequence","text":"<pre><code>var gameLoop = Services.GetRequiredService&lt;IGameLoop&gt;();\n\n// Start the loop\nawait gameLoop.RunAsync(cancellationToken);</code></pre> <p>Initialization flow:</p> <ol> <li><code>GameApplication.RunAsync&lt;TScene&gt;()</code> called</li> <li><code>GameEngine.InitializeAsync()</code> - Initialize subsystems</li> <li><code>SceneManager.LoadSceneAsync&lt;TScene&gt;()</code> - Load first scene</li> <li><code>GameLoop.RunAsync()</code> - Start main loop</li> </ol>"},{"location":"concepts/game-loop/#shutdown-sequence","title":"Shutdown Sequence","text":"<pre><code>// Graceful shutdown\n_gameContext.RequestExit();\n\n// Or force stop\ngameLoop.Stop();</code></pre> <p>Cleanup: 1. Loop detects <code>_gameContext.IsRunning == false</code> 2. Loop breaks out 3. <code>finally</code> block executes 4. <code>_stopwatch.Stop()</code> 5. <code>IsRunning = false</code> 6. Scene unloads (resources cleaned up)</p>"},{"location":"concepts/game-loop/#thread-safety","title":"Thread Safety","text":"<p>Important: The game loop is single-threaded by design.</p>"},{"location":"concepts/game-loop/#sdl3-requirement","title":"SDL3 Requirement","text":"<p>SDL3 must run on the main thread:</p> <pre><code>public Task RunAsync&lt;TScene&gt;(CancellationToken ct) where TScene : IScene\n{\n    // Block synchronously to keep SDL on the same thread\n    _host.StartAsync(ct).GetAwaiter().GetResult();\n\n    // Initialize game engine (SDL initialization)\n    engine.InitializeAsync(ct).GetAwaiter().GetResult();\n\n    // Start game loop - MUST stay on this thread\n    gameLoop.RunAsync(ct).GetAwaiter().GetResult();\n}</code></pre> <p>Why synchronous? - SDL3 window/rendering must stay on main thread - Async/await can resume on different threads - <code>.GetAwaiter().GetResult()</code> blocks on current thread</p>"},{"location":"concepts/game-loop/#async-loading","title":"Async Loading","text":"<p>You can still use async for loading:</p> <pre><code>protected override async Task OnLoadAsync(CancellationToken ct)\n{\n    // CPU-bound work (parsing JSON) - can run on thread pool\n    var data = await Task.Run(() =&gt; LoadHeavyData(), ct);\n\n    // SDL work (texture creation) - back on main thread\n    _texture = await _textureLoader.LoadTextureAsync(\"sprite.png\", ct);\n}</code></pre> <p>Rule: SDL calls happen on main thread, but prep work can be parallel.</p>"},{"location":"concepts/game-loop/#customizing-the-game-loop","title":"Customizing the Game Loop","text":""},{"location":"concepts/game-loop/#change-target-fps","title":"Change Target FPS","text":"<pre><code>var gameLoop = Services.GetRequiredService&lt;IGameLoop&gt;();\ngameLoop.TargetFramesPerSecond = 120; // High refresh rate\n\nawait gameLoop.RunAsync();</code></pre>"},{"location":"concepts/game-loop/#uncapped-frame-rate","title":"Uncapped Frame Rate","text":"<pre><code>gameLoop.TargetFramesPerSecond = 0; // No limiting (vsync only)</code></pre> <p>Use cases: - Benchmarking - Menu screens (don't need 60 FPS) - High-refresh displays (120Hz, 144Hz)</p>"},{"location":"concepts/game-loop/#custom-game-loop","title":"Custom Game Loop","text":"<p>You can implement your own:</p> <pre><code>public class MyCustomGameLoop : IGameLoop\n{\n    public bool IsRunning { get; private set; }\n    public int TargetFramesPerSecond { get; set; } = 60;\n\n    public async Task RunAsync(CancellationToken ct)\n    {\n        IsRunning = true;\n\n        while (IsRunning &amp;&amp; !ct.IsCancellationRequested)\n        {\n            // Your custom loop logic\n\n            // 1. Input\n            // 2. Update\n            // 3. Render\n            // 4. Frame limit\n        }\n\n        await Task.CompletedTask;\n    }\n\n    public void Stop() =&gt; IsRunning = false;\n}\n\n// Register\nbuilder.Services.AddSingleton&lt;IGameLoop, MyCustomGameLoop&gt;();</code></pre>"},{"location":"concepts/game-loop/#performance-monitoring","title":"Performance Monitoring","text":""},{"location":"concepts/game-loop/#measuring-frame-time","title":"Measuring Frame Time","text":"<pre><code>protected override void OnUpdate(GameTime gameTime)\n{\n    var deltaTime = gameTime.DeltaTime;\n    var fps = 1.0 / deltaTime;\n\n    Logger.LogDebug(\"Frame time: {Ms}ms, FPS: {Fps}\", \n        deltaTime * 1000, fps);\n}</code></pre>"},{"location":"concepts/game-loop/#profiling-phases","title":"Profiling Phases","text":"<pre><code>var stopwatch = Stopwatch.StartNew();\n\n// Measure update time\nvar updateStart = stopwatch.Elapsed;\n_sceneManager.Update(gameTime);\nvar updateTime = stopwatch.Elapsed - updateStart;\n\n// Measure render time\nvar renderStart = stopwatch.Elapsed;\n_sceneManager.Render(gameTime);\nvar renderTime = stopwatch.Elapsed - renderStart;\n\n_logger.LogDebug(\"Update: {U}ms, Render: {R}ms\", \n    updateTime.TotalMilliseconds,\n    renderTime.TotalMilliseconds);</code></pre>"},{"location":"concepts/game-loop/#common-patterns","title":"Common Patterns","text":""},{"location":"concepts/game-loop/#fixed-time-step-physics","title":"Fixed Time Step (Physics)","text":"<p>For deterministic physics:</p> <pre><code>private double _accumulator;\nprivate const double FixedTimeStep = 1.0 / 60.0; // 60 Hz physics\n\nprotected override void OnUpdate(GameTime gameTime)\n{\n    _accumulator += gameTime.DeltaTime;\n\n    // Run physics at fixed 60 Hz\n    while (_accumulator &gt;= FixedTimeStep)\n    {\n        UpdatePhysics(FixedTimeStep);\n        _accumulator -= FixedTimeStep;\n    }\n\n    // Render uses variable delta time\n    UpdateAnimations((float)gameTime.DeltaTime);\n}</code></pre> <p>Why? - Physics needs consistent timestep for stability - Rendering can vary without issues</p>"},{"location":"concepts/game-loop/#interpolation","title":"Interpolation","text":"<p>Smooth rendering between physics steps:</p> <pre><code>var alpha = _accumulator / FixedTimeStep;\nvar renderPosition = Vector2.Lerp(_previousPosition, _currentPosition, (float)alpha);</code></pre>"},{"location":"concepts/game-loop/#best-practices","title":"Best Practices","text":""},{"location":"concepts/game-loop/#do","title":"DO","text":"<ol> <li> <p>Always use delta time for movement/animation    <pre><code>position += velocity * deltaTime;  // \u2705 Good</code></pre></p> </li> <li> <p>Keep Update and Render separate <pre><code>OnUpdate(gameTime) { /* Logic only */ }\nOnRender(gameTime) { /* Drawing only */ }</code></pre></p> </li> <li> <p>Profile performance regularly    <pre><code>var fps = 1.0 / gameTime.DeltaTime;</code></pre></p> </li> <li> <p>Exit gracefully <pre><code>_gameContext.RequestExit(); // \u2705 Clean shutdown</code></pre></p> </li> </ol>"},{"location":"concepts/game-loop/#dont","title":"DON'T","text":"<ol> <li> <p>Don't use fixed values <pre><code>position += velocity; // \u274c Bad - frame-rate dependent</code></pre></p> </li> <li> <p>Don't do expensive work in Update <pre><code>// \u274c Bad - loads every frame!\nOnUpdate(gameTime)\n{\n    var texture = LoadTexture(\"sprite.png\");\n}\n\n// \u2705 Good - load once\nOnLoadAsync(ct)\n{\n    _texture = await LoadTextureAsync(\"sprite.png\", ct);\n}</code></pre></p> </li> <li> <p>Don't render in Update <pre><code>OnUpdate(gameTime)\n{\n    _renderer.DrawRectangle(...); // \u274c Wrong phase!\n}</code></pre></p> </li> <li> <p>Don't block the main thread <pre><code>Thread.Sleep(1000); // \u274c Freezes entire game!</code></pre></p> </li> </ol>"},{"location":"concepts/game-loop/#troubleshooting","title":"Troubleshooting","text":""},{"location":"concepts/game-loop/#low-frame-rate","title":"Low Frame Rate","text":"<p>Symptom: Game runs below target FPS</p> <p>Causes: - Too many draw calls - Complex physics calculations - Unoptimized collision detection - Large Update logic</p> <p>Solutions: 1. Profile with <code>Stopwatch</code> to find bottleneck 2. Reduce entity count 3. Use spatial partitioning for collisions 4. Batch draw calls</p>"},{"location":"concepts/game-loop/#stuttering","title":"Stuttering","text":"<p>Symptom: Inconsistent frame times</p> <p>Causes: - Garbage collection spikes - Asset loading during gameplay - VSync disabled - Background processes</p> <p>Solutions: 1. Enable VSync 2. Pre-load assets 3. Object pooling (reduce GC) 4. Close background apps</p>"},{"location":"concepts/game-loop/#input-lag","title":"Input Lag","text":"<p>Symptom: Delayed response to inputs</p> <p>Causes: - Triple buffering - High frame time - Input polling after rendering</p> <p>Solutions: 1. Disable triple buffering 2. Optimize Update phase 3. Input is polled first (\u2705 Brine2D does this)</p>"},{"location":"concepts/game-loop/#summary","title":"Summary","text":"Concept Key Point Loop Structure Input \u2192 Update \u2192 Render \u2192 Limit Frame Rate Default 60 FPS (16.67ms/frame) Delta Time Essential for frame-rate independence Threading Single-threaded (SDL3 requirement) Phase Budget Input (1ms), Update (10ms), Render (5ms) Precision Sleep + SpinWait hybrid timing"},{"location":"concepts/game-loop/#next-steps","title":"Next Steps","text":"<ul> <li>Scene Management - Understand scene lifecycle</li> <li>Input System - Master input handling</li> <li>Rendering - Optimize draw calls</li> <li>Performance - Profile and optimize</li> </ul> <p>Master the game loop and you master game development!</p>"},{"location":"concepts/scenes/","title":"Scene Management","text":"<p>Scenes are the building blocks of your game. Think of them like ASP.NET Controllers - each scene handles a specific part of your game (menu, gameplay, pause screen, etc.).</p>"},{"location":"concepts/scenes/#what-is-a-scene","title":"What is a Scene?","text":"<p>A scene represents a distinct state or screen in your game. Common examples:</p> Scene Purpose <code>MenuScene</code> Title screen, options <code>GameScene</code> Main gameplay <code>PauseScene</code> Pause menu overlay <code>GameOverScene</code> End game screen <code>LoadingScene</code> Asset loading screen <pre><code>stateDiagram-v2\n    [*] --&gt; MenuScene: Game Start\n    MenuScene --&gt; GameScene: Play Button\n    GameScene --&gt; PauseScene: ESC Key\n    PauseScene --&gt; GameScene: Resume\n    PauseScene --&gt; MenuScene: Quit\n    GameScene --&gt; GameOverScene: Player Dies\n    GameOverScene --&gt; MenuScene: Main Menu\n    GameOverScene --&gt; GameScene: Restart\n\n    state GameScene {\n        [*] --&gt; Initialize\n        Initialize --&gt; Load\n        Load --&gt; Update\n        Update --&gt; Render\n        Render --&gt; Update\n        Update --&gt; Unload\n        Unload --&gt; [*]\n    }\n\n    classDef menuStyle fill:#1e3a5f,stroke:#569cd6,stroke-width:2px,color:#fff\n    classDef gameStyle fill:#2d5016,stroke:#4ec9b0,stroke-width:2px,color:#fff\n    classDef pauseStyle fill:#3d3d2a,stroke:#dcdcaa,stroke-width:2px,color:#fff\n    classDef endStyle fill:#4a2d4a,stroke:#c586c0,stroke-width:2px,color:#fff\n\n    class MenuScene menuStyle\n    class GameScene gameStyle\n    class PauseScene pauseStyle\n    class GameOverScene endStyle</code></pre>"},{"location":"concepts/scenes/#scene-lifecycle","title":"Scene Lifecycle","text":"<p>Every scene goes through a 5-phase lifecycle with automatic ECS and frame management:</p> <pre><code>sequenceDiagram\n    participant SM as SceneManager\n    participant H as LifecycleHooks\n    participant S as Scene\n    participant DI as DIContainer\n\n    Note over SM: LoadSceneAsync&lt;GameScene&gt;\n\n    SM-&gt;&gt;DI: GetRequiredService&lt;GameScene&gt;\n    DI-&gt;&gt;S: new GameScene(dependencies...)\n    DI-&gt;&gt;SM: Scene instance\n\n    SM-&gt;&gt;S: Initialize()\n    Note over S: OnInitialize() - Setup state\n    S-&gt;&gt;S: IsActive = true\n\n    SM-&gt;&gt;S: LoadAsync()\n    Note over S: OnLoadAsync() - Load assets\n    S-&gt;&gt;SM: Task completed\n\n    loop Every Frame (Update)\n        Note over SM: SceneManager.Update()\n\n        SM-&gt;&gt;H: PreUpdate hooks\n        Note over H: Input layers, etc.\n\n        SM-&gt;&gt;S: Update(gameTime)\n        Note over S: OnUpdate() - Game logic\n\n        SM-&gt;&gt;H: PostUpdate hooks\n        Note over H: ECS systems execute automatically!\n    end\n\n    loop Every Frame (Render)\n        Note over SM: SceneManager.Render()\n        SM-&gt;&gt;SM: Clear/BeginFrame (automatic)\n\n        SM-&gt;&gt;H: PreRender hooks\n        Note over H: ECS rendering (sprites, particles)\n\n        SM-&gt;&gt;S: Render(gameTime)\n        Note over S: OnRender() - Draw UI\n\n        SM-&gt;&gt;H: PostRender hooks\n        Note over H: Debug overlays\n\n        SM-&gt;&gt;SM: EndFrame (automatic)\n    end\n\n    Note over SM: Loading new scene...\n\n    SM-&gt;&gt;S: UnloadAsync()\n    Note over S: OnUnloadAsync() - Cleanup\n    S-&gt;&gt;S: IsActive = false\n    S-&gt;&gt;SM: Task completed\n\n    Note over DI: Scene instance disposed\n\n    box rgba(30, 58, 95, 0.3) SceneManager Layer\n    participant SM\n    end\n\n    box rgba(45, 80, 22, 0.3) Lifecycle Hooks\n    participant H\n    end\n\n    box rgba(74, 45, 74, 0.3) Scene Layer\n    participant S\n    end\n\n    box rgba(61, 61, 42, 0.3) DI Container\n    participant DI\n    end</code></pre>"},{"location":"concepts/scenes/#phase-1-constructor-dependency-injection","title":"Phase 1: Constructor (Dependency Injection)","text":"<p>Purpose: Receive dependencies via constructor injection</p> <pre><code>public class GameScene : Scene\n{\n    private readonly IRenderer _renderer;\n    private readonly IInputService _input;\n    private readonly IGameContext _gameContext;\n    private readonly IEntityWorld _world; // ECS support\n\n    // Constructor injection (DI)\n    public GameScene(\n        IRenderer renderer,\n        IInputService input,\n        IGameContext gameContext,\n        IEntityWorld world,\n        ILogger&lt;GameScene&gt; logger\n    ) : base(logger)\n    {\n        _renderer = renderer;\n        _input = input;\n        _gameContext = gameContext;\n        _world = world;\n    }\n}</code></pre> <p>\u2705 DO: Store dependencies in readonly fields \u274c DON'T: Initialize game state here (use <code>OnInitialize</code> instead)</p>"},{"location":"concepts/scenes/#phase-2-initialize","title":"Phase 2: Initialize","text":"<p>Purpose: Set up initial scene state (synchronous)</p> <pre><code>protected override void OnInitialize()\n{\n    Logger.LogInformation(\"Game scene initialized!\");\n\n    // Set clear color (automatic frame management uses this)\n    _renderer.ClearColor = new Color(40, 40, 60);\n\n    // Create ECS entities\n    var player = _world.CreateEntity(\"Player\");\n    player.AddComponent&lt;TransformComponent&gt;().Position = new Vector2(400, 300);\n    player.AddComponent&lt;PlayerControllerComponent&gt;();\n\n    // Create enemies\n    for (int i = 0; i &lt; 5; i++)\n    {\n        var enemy = _world.CreateEntity($\"Enemy{i}\");\n        enemy.AddComponent&lt;TransformComponent&gt;();\n        enemy.AddComponent&lt;AIControllerComponent&gt;();\n    }\n}</code></pre> <p>When: Called once when scene is created Use for:  - Creating game objects/entities - Setting up scene state - Configuring clear color - Initializing non-async resources</p> <p>\u274c DON'T: Load assets here (use <code>OnLoadAsync</code>)</p>"},{"location":"concepts/scenes/#phase-3-load-async","title":"Phase 3: Load (Async)","text":"<p>Purpose: Load assets and resources asynchronously</p> <pre><code>protected override async Task OnLoadAsync(CancellationToken cancellationToken)\n{\n    Logger.LogInformation(\"Loading assets...\");\n\n    // Load textures\n    _playerTexture = await _textureLoader.LoadTextureAsync(\n        \"assets/player.png\",\n        TextureScaleMode.Nearest,\n        cancellationToken);\n\n    // Load audio\n    _bgMusic = await _audio.LoadMusicAsync(\n        \"assets/music.mp3\",\n        cancellationToken);\n\n    _audio.PlayMusic(_bgMusic);\n\n    Logger.LogInformation(\"Assets loaded!\");\n}</code></pre> <p>When: Called once after <code>Initialize</code> Use for: - Loading textures/sprites - Loading audio - Loading fonts - Reading level data - Any I/O operations</p> <p>\u2705 DO: Use <code>cancellationToken</code> for long operations \u2705 DO: Load assets in parallel when possible</p> <pre><code>// Parallel loading\nvar loadTasks = new[]\n{\n    _textureLoader.LoadTextureAsync(\"player.png\", cancellationToken),\n    _textureLoader.LoadTextureAsync(\"enemy.png\", cancellationToken),\n    _audio.LoadMusicAsync(\"music.mp3\", cancellationToken)\n};\n\nawait Task.WhenAll(loadTasks);</code></pre>"},{"location":"concepts/scenes/#phase-4-update-every-frame","title":"Phase 4: Update (Every Frame)","text":"<p>Purpose: Update game logic</p> <pre><code>protected override void OnUpdate(GameTime gameTime)\n{\n    var deltaTime = (float)gameTime.DeltaTime;\n\n    // Input handling\n    if (_input.IsKeyPressed(Keys.Escape))\n    {\n        _gameContext.RequestExit();\n    }\n\n    // Scene-specific logic\n    HandlePlayerInput();\n    CheckWinCondition();\n\n    // NO MANUAL PIPELINE CALLS NEEDED!\n    // ECS systems execute automatically via lifecycle hooks!\n    // VelocitySystem, PhysicsSystem, etc. all run automatically\n}</code></pre> <p>When: Called every frame (~60 times per second) Use for: - Input processing - Scene-specific logic - Win/lose conditions - Scene transitions</p> <p>Automatic ECS Execution</p> <p>You no longer need to manually call:</p> <ul> <li>\u274c <code>_updatePipeline.Execute(gameTime)</code> - Runs automatically!</li> <li>\u274c <code>_world.Update(gameTime)</code> - Runs automatically!</li> </ul> <p>Behind the scenes, <code>SceneManager</code> executes:</p> <ol> <li>PreUpdate hooks (input layers, camera setup)</li> <li>Your <code>OnUpdate()</code> (scene logic)</li> <li>PostUpdate hooks (ECS systems, physics, AI)</li> </ol> <p>This happens automatically via lifecycle hooks!</p>"},{"location":"concepts/scenes/#phase-5-render-every-frame","title":"Phase 5: Render (Every Frame)","text":"<p>Purpose: Draw scene-specific graphics (UI, debug overlays)</p> <pre><code>protected override void OnRender(GameTime gameTime)\n{\n    // NO FRAME MANAGEMENT NEEDED!\n    // SceneManager handles Clear/BeginFrame/EndFrame automatically\n\n    // NO PIPELINE CALLS NEEDED!\n    // ECS render systems (sprites, particles) already drew automatically\n\n    // Just draw your scene-specific UI\n    DrawUI();\n    DrawDebugInfo();\n}\n\nprivate void DrawUI()\n{\n    _renderer.DrawText($\"Score: {_score}\", 10, 10, Color.White);\n    _renderer.DrawText($\"Lives: {_lives}\", 10, 35, Color.White);\n}</code></pre> <p>When: Called every frame after <code>Update</code> Use for: - Drawing UI overlays - Debug visualization - Scene-specific rendering</p> <p>Automatic Frame Management</p> <p>You no longer need to call: - \u274c <code>_renderer.Clear(color)</code> - Handled automatically! - \u274c <code>_renderer.BeginFrame()</code> - Handled automatically! - \u274c <code>_renderer.EndFrame()</code> - Handled automatically!</p> <p>Behind the scenes, <code>SceneManager</code> executes: 1. Clear screen (uses <code>_renderer.ClearColor</code> you set in <code>OnInitialize</code>) 2. BeginFrame() 3. PreRender hooks (ECS sprites, particles) 4. Your <code>OnRender()</code> (UI, debug) 5. PostRender hooks (debug overlays) 6. EndFrame()</p> <p>\u274c DON'T: Update game logic here (use <code>OnUpdate</code>)</p>"},{"location":"concepts/scenes/#phase-6-unload-async","title":"Phase 6: Unload (Async)","text":"<p>Purpose: Clean up resources</p> <pre><code>protected override Task OnUnloadAsync(CancellationToken cancellationToken)\n{\n    Logger.LogInformation(\"Unloading scene...\");\n\n    // Stop audio\n    _audio.StopMusic();\n\n    // Unload textures\n    if (_playerTexture != null)\n    {\n        _textureLoader.UnloadTexture(_playerTexture);\n    }\n\n    Logger.LogInformation(\"Scene unloaded\");\n    return Task.CompletedTask;\n}</code></pre> <p>When: Called when switching to another scene Use for: - Unloading assets - Stopping audio - Clearing collections - Disposing resources</p>"},{"location":"concepts/scenes/#complete-scene-example-modern-approach","title":"Complete Scene Example (Modern Approach)","text":"<p>Here's a full scene with automatic ECS execution:</p> <pre><code>using Brine2D.Core;\nusing Brine2D.ECS;\nusing Brine2D.ECS.Components;\nusing Brine2D.Input;\nusing Brine2D.Rendering;\nusing Microsoft.Extensions.Logging;\nusing System.Numerics;\n\npublic class GameScene : Scene\n{\n    private readonly IRenderer _renderer;\n    private readonly IInputService _input;\n    private readonly IGameContext _gameContext;\n    private readonly IEntityWorld _world;\n\n    private Entity? _player;\n    private int _score;\n\n    public GameScene(\n        IRenderer renderer,\n        IInputService input,\n        IGameContext gameContext,\n        IEntityWorld world,\n        ILogger&lt;GameScene&gt; logger\n    ) : base(logger)\n    {\n        _renderer = renderer;\n        _input = input;\n        _gameContext = gameContext;\n        _world = world;\n    }\n\n    protected override void OnInitialize()\n    {\n        Logger.LogInformation(\"Game scene initialized!\");\n\n        // Set clear color (automatic frame management uses this)\n        _renderer.ClearColor = new Color(40, 40, 60);\n\n        // Create player entity\n        _player = _world.CreateEntity(\"Player\");\n        _player.Tags.Add(\"Player\");\n\n        var transform = _player.AddComponent&lt;TransformComponent&gt;();\n        transform.Position = new Vector2(400, 300);\n\n        _player.AddComponent&lt;VelocityComponent&gt;();\n        _player.AddComponent&lt;PlayerControllerComponent&gt;();\n        _player.AddComponent&lt;SpriteComponent&gt;().TexturePath = \"assets/player.png\";\n    }\n\n    protected override async Task OnLoadAsync(CancellationToken cancellationToken)\n    {\n        Logger.LogInformation(\"Loading game assets...\");\n        // Textures are loaded automatically by SpriteRenderingSystem\n        Logger.LogInformation(\"Assets loaded!\");\n    }\n\n    protected override void OnUpdate(GameTime gameTime)\n    {\n        if (_input.IsKeyPressed(Keys.Escape))\n        {\n            _gameContext.RequestExit();\n        }\n\n        CheckCollisions();\n        UpdateScore();\n\n        // ECS systems run automatically!\n        // No manual pipeline calls needed\n    }\n\n    protected override void OnRender(GameTime gameTime)\n    {\n        // Frame management is automatic!\n        // Sprites already rendered via ECS!\n\n        // Just draw scene-specific UI\n        _renderer.DrawText($\"Score: {_score}\", 10, 10, Color.White);\n    }\n\n    protected override Task OnUnloadAsync(CancellationToken cancellationToken)\n    {\n        Logger.LogInformation(\"Unloading game scene...\");\n        return Task.CompletedTask;\n    }\n\n    private void CheckCollisions() { /* ... */ }\n    private void UpdateScore() { /* ... */ }\n}</code></pre>"},{"location":"concepts/scenes/#power-user-manual-control","title":"Power User: Manual Control","text":"<p>For advanced scenarios, you can opt out of automatic behavior:</p> <pre><code>public class AdvancedScene : Scene\n{\n    // Disable automatic ECS execution\n    public override bool EnableLifecycleHooks =&gt; false;\n\n    // Disable automatic frame management\n    public override bool EnableAutomaticFrameManagement =&gt; false;\n\n    private readonly UpdatePipeline _updatePipeline;\n    private readonly RenderPipeline _renderPipeline;\n    private readonly IEntityWorld _world;\n    private readonly IRenderer _renderer;\n\n    public AdvancedScene(\n        UpdatePipeline updatePipeline,\n        RenderPipeline renderPipeline,\n        IEntityWorld world,\n        IRenderer renderer,\n        ILogger&lt;AdvancedScene&gt; logger\n    ) : base(logger)\n    {\n        _updatePipeline = updatePipeline;\n        _renderPipeline = renderPipeline;\n        _world = world;\n        _renderer = renderer;\n    }\n\n    protected override void OnUpdate(GameTime gameTime)\n    {\n        // Manual control - you decide when systems run\n        if (_someCondition)\n        {\n            _updatePipeline.Execute(gameTime);\n            _world.Update(gameTime);\n        }\n    }\n\n    protected override void OnRender(GameTime gameTime)\n    {\n        // Manual frame management\n        _renderer.Clear(Color.Black);\n        _renderer.BeginFrame();\n\n        _renderPipeline.Execute(_renderer);\n        DrawCustomUI();\n\n        _renderer.EndFrame();\n    }\n}</code></pre> <p>Use cases for manual control: - Multi-pass rendering - Custom render targets - Pausing systems conditionally - Frame-by-frame debugging - Post-processing effects</p>"},{"location":"concepts/scenes/#scene-registration","title":"Scene Registration","text":""},{"location":"concepts/scenes/#step-1-register-scene","title":"Step 1: Register Scene","text":"<pre><code>var builder = GameApplication.CreateBuilder(args);\n\n// Register scenes\nbuilder.Services.AddScene&lt;MenuScene&gt;();\nbuilder.Services.AddScene&lt;GameScene&gt;();\nbuilder.Services.AddScene&lt;PauseScene&gt;();\nbuilder.Services.AddScene&lt;GameOverScene&gt;();\n\nvar game = builder.Build();</code></pre> <p>What it does: - Registers scene as transient (new instance each time) - Makes scene available for DI resolution</p>"},{"location":"concepts/scenes/#step-2-set-initial-scene","title":"Step 2: Set Initial Scene","text":"<pre><code>// Run with MenuScene as starting scene\nawait game.RunAsync&lt;MenuScene&gt;();</code></pre>"},{"location":"concepts/scenes/#scene-transitions","title":"Scene Transitions","text":""},{"location":"concepts/scenes/#method-1-via-scenemanager-injected","title":"Method 1: Via SceneManager (Injected)","text":"<pre><code>public class MenuScene : Scene\n{\n    private readonly ISceneManager _sceneManager;\n\n    public MenuScene(\n        ISceneManager sceneManager,\n        ILogger&lt;MenuScene&gt; logger\n    ) : base(logger)\n    {\n        _sceneManager = sceneManager;\n    }\n\n    protected override void OnUpdate(GameTime gameTime)\n    {\n        if (_input.IsKeyPressed(Keys.Enter))\n        {\n            // Transition to GameScene\n            _ = _sceneManager.LoadSceneAsync&lt;GameScene&gt;();\n        }\n    }\n}</code></pre>"},{"location":"concepts/scenes/#method-2-via-game-context-common-pattern","title":"Method 2: Via Game Context (Common Pattern)","text":"<pre><code>public class GameScene : Scene\n{\n    private readonly IGameContext _gameContext;\n\n    protected override void OnUpdate(GameTime gameTime)\n    {\n        if (_playerHealth &lt;= 0)\n        {\n            // Request scene transition\n            _gameContext.RequestExit(); // Or custom transition logic\n        }\n    }\n}</code></pre>"},{"location":"concepts/scenes/#scene-manager","title":"Scene Manager","text":"<p>The <code>SceneManager</code> orchestrates scene lifecycle automatically:</p> <pre><code>public interface ISceneManager\n{\n    IScene? CurrentScene { get; }\n\n    Task LoadSceneAsync&lt;TScene&gt;(CancellationToken ct = default) \n        where TScene : IScene;\n\n    void Update(GameTime gameTime);\n    void Render(GameTime gameTime);\n}</code></pre> <p>What it does automatically: 1. \u2705 Resolves scene from DI 2. \u2705 Calls lifecycle methods in correct order 3. \u2705 Executes lifecycle hooks (ECS systems) 4. \u2705 Handles frame management (Clear/Begin/End) 5. \u2705 Manages current scene state 6. \u2705 Handles scene transitions</p>"},{"location":"concepts/scenes/#best-practices","title":"Best Practices","text":""},{"location":"concepts/scenes/#do","title":"DO \u2705","text":"<ol> <li> <p>Use dependency injection <pre><code>public GameScene(IRenderer renderer, IEntityWorld world, ...) : base(logger)</code></pre></p> </li> <li> <p>Initialize in <code>OnInitialize</code> <pre><code>protected override void OnInitialize()\n{\n    _renderer.ClearColor = new Color(40, 40, 60);\n    _player = _world.CreateEntity(\"Player\");\n}</code></pre></p> </li> <li> <p>Load assets in <code>OnLoadAsync</code> <pre><code>protected override async Task OnLoadAsync(CancellationToken ct)\n{\n    _texture = await _textureLoader.LoadTextureAsync(..., ct);\n}</code></pre></p> </li> <li> <p>Trust automatic execution <pre><code>// \u2705 Clean - systems run automatically\nprotected override void OnUpdate(GameTime gameTime)\n{\n    HandleInput();\n    CheckWinCondition();\n}</code></pre></p> </li> <li> <p>Draw only UI in <code>OnRender</code> <pre><code>// \u2705 Sprites already rendered by ECS\nprotected override void OnRender(GameTime gameTime)\n{\n    _renderer.DrawText($\"Score: {_score}\", 10, 10, Color.White);\n}</code></pre></p> </li> <li> <p>Clean up in <code>OnUnloadAsync</code> <pre><code>protected override Task OnUnloadAsync(CancellationToken ct)\n{\n    _textureLoader.UnloadTexture(_texture);\n    return Task.CompletedTask;\n}</code></pre></p> </li> </ol>"},{"location":"concepts/scenes/#dont","title":"DON'T \u274c","text":"<ol> <li> <p>Don't manually call pipelines (unless opting out) <pre><code>// \u274c Unnecessary - runs automatically!\nprotected override void OnUpdate(GameTime gameTime)\n{\n    _updatePipeline.Execute(gameTime); // Don't do this!\n    _world.Update(gameTime); // Don't do this!\n}</code></pre></p> </li> <li> <p>Don't manually manage frames (unless opting out) <pre><code>// \u274c Unnecessary - automatic!\nprotected override void OnRender(GameTime gameTime)\n{\n    _renderer.Clear(Color.Black); // Don't do this!\n    _renderer.BeginFrame(); // Don't do this!\n\n    DrawUI();\n\n    _renderer.EndFrame(); // Don't do this!\n}</code></pre></p> </li> <li> <p>Don't update logic in <code>OnRender</code> <pre><code>// \u274c Bad\nprotected override void OnRender(GameTime gt)\n{\n    _player.Update(); // Wrong place!\n}</code></pre></p> </li> <li> <p>Don't forget to unload <pre><code>// \u274c Memory leak!\nprotected override Task OnUnloadAsync(CancellationToken ct)\n{\n    // Forgot to unload _texture!\n    return Task.CompletedTask;\n}</code></pre></p> </li> </ol>"},{"location":"concepts/scenes/#advanced-patterns","title":"Advanced Patterns","text":""},{"location":"concepts/scenes/#shared-state-between-scenes","title":"Shared State Between Scenes","text":"<pre><code>// Create a shared service\npublic class GameState\n{\n    public int PlayerScore { get; set; }\n    public int PlayerLevel { get; set; }\n}\n\n// Register as singleton\nbuilder.Services.AddSingleton&lt;GameState&gt;();\n\n// Inject into scenes\npublic class GameScene : Scene\n{\n    private readonly GameState _gameState;\n\n    public GameScene(GameState gameState, ...)\n    {\n        _gameState = gameState;\n    }\n\n    protected override void OnUpdate(GameTime gt)\n    {\n        _gameState.PlayerScore += points;\n    }\n}</code></pre>"},{"location":"concepts/scenes/#scene-data-transfer","title":"Scene Data Transfer","text":"<pre><code>// Option 1: Via shared service\npublic class SceneTransitionData\n{\n    public string NextLevel { get; set; }\n    public int PlayerHealth { get; set; }\n}\n\nbuilder.Services.AddSingleton&lt;SceneTransitionData&gt;();\n\n// Option 2: Via SceneManager extension\npublic static class SceneManagerExtensions\n{\n    public static Task LoadGameSceneAsync(\n        this ISceneManager sceneManager,\n        string level,\n        int health)\n    {\n        // Store data and load scene\n        // Implementation specific to your needs\n    }\n}</code></pre>"},{"location":"concepts/scenes/#troubleshooting","title":"Troubleshooting","text":""},{"location":"concepts/scenes/#scene-not-loading","title":"Scene Not Loading","text":"<p>Symptom: Scene doesn't appear</p> <p>Solutions: 1. Check scene is registered:    <pre><code>builder.Services.AddScene&lt;GameScene&gt;();</code></pre></p> <ol> <li>Check <code>RunAsync</code> has correct type:    <pre><code>await game.RunAsync&lt;GameScene&gt;(); // \u2705 Correct</code></pre></li> </ol>"},{"location":"concepts/scenes/#assets-not-unloading","title":"Assets Not Unloading","text":"<p>Symptom: Memory usage keeps growing</p> <p>Solution: Always unload in <code>OnUnloadAsync</code>: <pre><code>protected override Task OnUnloadAsync(CancellationToken ct)\n{\n    _textureLoader.UnloadTexture(_texture);\n    _audio.UnloadMusic(_music);\n    return Task.CompletedTask;\n}</code></pre></p>"},{"location":"concepts/scenes/#scene-state-persists","title":"Scene State Persists","text":"<p>Symptom: Old scene state affects new scene</p> <p>Cause: Scenes are transient - new instance each load</p> <p>Solution: Don't rely on scene fields persisting. Use shared services for persistent state.</p>"},{"location":"concepts/scenes/#summary","title":"Summary","text":"Phase Method Purpose What's Automatic Constructor <code>__init__</code> DI - Initialize <code>OnInitialize()</code> Setup - Load <code>OnLoadAsync()</code> Load assets - Update <code>OnUpdate(gt)</code> Scene logic ECS systems, World update Render <code>OnRender(gt)</code> Draw UI Frame management, ECS rendering Unload <code>OnUnloadAsync()</code> Cleanup -"},{"location":"concepts/scenes/#next-steps","title":"Next Steps","text":"<ul> <li>Game Loop - Understand how scenes fit in the loop</li> <li>Dependency Injection - Master scene dependencies</li> <li>ECS Systems - Create systems that run automatically</li> <li>Input Handling - Process player input</li> </ul> <p>Scenes are now cleaner than ever! Trust automatic execution and focus on game logic.</p>"},{"location":"getting-started/configuration/","title":"Configuration","text":"<p>Brine2D uses JSON-based configuration just like ASP.NET Core. Settings are loaded from <code>gamesettings.json</code> and can be bound to strongly-typed option classes.</p>"},{"location":"getting-started/configuration/#the-aspnet-way","title":"The ASP.NET Way","text":"<p>If you've used ASP.NET Core, this will be instantly familiar:</p> ASP.NET Core Brine2D Purpose <code>appsettings.json</code> <code>gamesettings.json</code> Main configuration file <code>appsettings.Development.json</code> <code>gamesettings.Development.json</code> Environment-specific settings <code>IOptions&lt;T&gt;</code> <code>IOptions&lt;RenderingOptions&gt;</code> Strongly-typed configuration <code>builder.Configuration</code> <code>builder.Configuration</code> Configuration API"},{"location":"getting-started/configuration/#quick-example","title":"Quick Example","text":"<pre><code>// Load from gamesettings.json\nbuilder.Services.AddSDL3Rendering(options =&gt;\n{\n    builder.Configuration.GetSection(\"Rendering\").Bind(options);\n});\n\n// Or configure in code\nbuilder.Services.AddSDL3Rendering(options =&gt;\n{\n    options.WindowTitle = \"My Game\";\n    options.WindowWidth = 1920;\n    options.WindowHeight = 1080;\n    options.VSync = true;\n});</code></pre>"},{"location":"getting-started/configuration/#the-gamesettingsjson-file","title":"The <code>gamesettings.json</code> File","text":"<p>Create a <code>gamesettings.json</code> file in your project root:</p> <pre><code>{\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Information\",\n      \"Brine2D\": \"Debug\",\n      \"Brine2D.Rendering\": \"Information\",\n      \"Brine2D.Input\": \"Warning\"\n    }\n  },\n  \"Rendering\": {\n    \"WindowTitle\": \"My Brine2D Game\",\n    \"WindowWidth\": 1280,\n    \"WindowHeight\": 720,\n    \"Fullscreen\": false,\n    \"VSync\": true,\n    \"Resizable\": true,\n    \"Backend\": \"GPU\",\n    \"PreferredGPUDriver\": null\n  }\n}</code></pre>"},{"location":"getting-started/configuration/#make-sure-its-copied-to-output","title":"Make Sure It's Copied to Output","text":"<p>Update your <code>.csproj</code> to copy the file:</p> <pre><code>&lt;ItemGroup&gt;\n  &lt;None Update=\"gamesettings.json\"&gt;\n    &lt;CopyToOutputDirectory&gt;PreserveNewest&lt;/CopyToOutputDirectory&gt;\n  &lt;/None&gt;\n&lt;/ItemGroup&gt;</code></pre>"},{"location":"getting-started/configuration/#configuration-sections","title":"Configuration Sections","text":""},{"location":"getting-started/configuration/#logging","title":"Logging","text":"<p>Controls logging output for different parts of the engine.</p> <pre><code>{\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Information\",\n      \"Brine2D\": \"Debug\",\n      \"Brine2D.Rendering\": \"Information\",\n      \"Brine2D.Input\": \"Warning\",\n      \"Brine2D.Audio\": \"Information\",\n      \"Microsoft\": \"Warning\"\n    }\n  }\n}</code></pre> <p>Log Levels: - <code>Trace</code> - Very detailed, for deep debugging - <code>Debug</code> - Detailed debugging information - <code>Information</code> - General informational messages - <code>Warning</code> - Warning messages - <code>Error</code> - Error messages - <code>Critical</code> - Critical failures - <code>None</code> - No logging</p> <p>Example Usage:</p> <pre><code>builder.Logging.SetMinimumLevel(LogLevel.Debug);\nbuilder.Logging.AddConsole();\nbuilder.Logging.AddDebug(); // Visual Studio Output window</code></pre>"},{"location":"getting-started/configuration/#rendering","title":"Rendering","text":"<p>Controls window and rendering settings.</p> <pre><code>{\n  \"Rendering\": {\n    \"WindowTitle\": \"My Game\",\n    \"WindowWidth\": 1280,\n    \"WindowHeight\": 720,\n    \"Fullscreen\": false,\n    \"VSync\": true,\n    \"Resizable\": true,\n    \"Backend\": \"GPU\",\n    \"PreferredGPUDriver\": \"Vulkan\"\n  }\n}</code></pre>"},{"location":"getting-started/configuration/#options","title":"Options:","text":"Property Type Default Description <code>WindowTitle</code> <code>string</code> <code>\"Brine2D Game\"</code> Window title text <code>WindowWidth</code> <code>int</code> <code>1280</code> Window width in pixels <code>WindowHeight</code> <code>int</code> <code>720</code> Window height in pixels <code>Fullscreen</code> <code>bool</code> <code>false</code> Start in fullscreen mode <code>VSync</code> <code>bool</code> <code>true</code> Enable vertical sync <code>Resizable</code> <code>bool</code> <code>true</code> Allow window resizing <code>Backend</code> <code>string</code> <code>\"GPU\"</code> Graphics backend: <code>\"GPU\"</code>, <code>\"LegacyRenderer\"</code>, or <code>\"Auto\"</code> <code>PreferredGPUDriver</code> <code>string?</code> <code>null</code> GPU driver: <code>\"Vulkan\"</code>, <code>\"Metal\"</code>, <code>\"D3D11\"</code>, <code>\"D3D12\"</code>, or <code>null</code> (auto)"},{"location":"getting-started/configuration/#graphics-backends","title":"Graphics Backends:","text":"<ul> <li><code>GPU</code> - Modern SDL3 GPU API (recommended)</li> <li>Supports Vulkan, Metal, D3D11, D3D12</li> <li>Better performance</li> <li> <p>Cross-platform shader system</p> </li> <li> <p><code>LegacyRenderer</code> - SDL3's traditional 2D renderer</p> </li> <li>More compatible with older hardware</li> <li>Simpler API</li> <li> <p>Faster startup</p> </li> <li> <p><code>Auto</code> - Automatically selects GPU if available, falls back to Legacy</p> </li> </ul>"},{"location":"getting-started/configuration/#gpu-drivers","title":"GPU Drivers:","text":"<p>If using <code>Backend: \"GPU\"</code>, you can specify a preferred driver:</p> <pre><code>{\n  \"Rendering\": {\n    \"Backend\": \"GPU\",\n    \"PreferredGPUDriver\": \"Vulkan\"\n  }\n}</code></pre> <ul> <li><code>null</code> (default) - Auto-select best driver for platform</li> <li><code>Vulkan</code> - Windows, Linux, Android</li> <li><code>Metal</code> - macOS, iOS</li> <li><code>D3D11</code> - Windows (older GPUs)</li> <li><code>D3D12</code> - Windows (modern GPUs)</li> </ul>"},{"location":"getting-started/configuration/#environment-specific-configuration","title":"Environment-Specific Configuration","text":"<p>Just like ASP.NET, you can have different settings per environment.</p>"},{"location":"getting-started/configuration/#file-structure","title":"File Structure:","text":"<pre><code>MyGame/\n\u251c\u2500\u2500 gamesettings.json              # Base settings\n\u251c\u2500\u2500 gamesettings.Development.json  # Development overrides\n\u251c\u2500\u2500 gamesettings.Production.json   # Production overrides\n\u2514\u2500\u2500 Program.cs</code></pre>"},{"location":"getting-started/configuration/#example-development-settings","title":"Example: Development Settings","text":"<p><code>gamesettings.Development.json</code>:</p> <pre><code>{\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Debug\",\n      \"Brine2D\": \"Trace\"\n    }\n  },\n  \"Rendering\": {\n    \"WindowTitle\": \"My Game [DEV]\",\n    \"VSync\": false\n  }\n}</code></pre>"},{"location":"getting-started/configuration/#set-the-environment","title":"Set the Environment:","text":"<pre><code># Windows (PowerShell)\n$env:DOTNET_ENVIRONMENT = \"Development\"\ndotnet run\n\n# Linux/macOS\nDOTNET_ENVIRONMENT=Development dotnet run</code></pre> <p>Or in Visual Studio, set it in Project Properties &gt; Debug &gt; Environment Variables.</p>"},{"location":"getting-started/configuration/#code-based-configuration","title":"Code-Based Configuration","text":"<p>You can configure options entirely in code:</p> <pre><code>using Brine2D.Hosting;\nusing Brine2D.Rendering.SDL;\n\nvar builder = GameApplication.CreateBuilder(args);\n\n// Method 1: Inline configuration\nbuilder.Services.AddSDL3Rendering(options =&gt;\n{\n    options.WindowTitle = \"My Game\";\n    options.WindowWidth = 1920;\n    options.WindowHeight = 1080;\n    options.Fullscreen = true;\n    options.VSync = true;\n    options.Backend = GraphicsBackend.GPU;\n    options.PreferredGPUDriver = \"Vulkan\";\n});\n\n// Method 2: Bind from configuration\nbuilder.Services.AddSDL3Rendering(options =&gt;\n{\n    builder.Configuration.GetSection(\"Rendering\").Bind(options);\n\n    // Override specific values\n    options.WindowTitle = \"Overridden Title\";\n});\n\n// Method 3: Mix both\nbuilder.Services.AddSDL3Rendering(options =&gt;\n{\n    // Load base from JSON\n    builder.Configuration.GetSection(\"Rendering\").Bind(options);\n\n    // Override based on logic\n    if (args.Contains(\"--fullscreen\"))\n    {\n        options.Fullscreen = true;\n    }\n});</code></pre>"},{"location":"getting-started/configuration/#accessing-configuration-in-scenes","title":"Accessing Configuration in Scenes","text":"<p>You can inject <code>IConfiguration</code> or <code>IOptions&lt;T&gt;</code> into your scenes:</p> <pre><code>using Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Options;\n\npublic class GameScene : Scene\n{\n    private readonly IConfiguration _configuration;\n    private readonly RenderingOptions _renderingOptions;\n\n    public GameScene\n    (\n        IConfiguration configuration,\n        IOptions&lt;RenderingOptions&gt; renderingOptions,\n        ILogger&lt;GameScene&gt; logger\n    ) : base(logger)\n    {\n        _configuration = configuration;\n        _renderingOptions = renderingOptions.Value;\n    }\n\n    protected override void OnInitialize()\n    {\n        // Access configuration\n        var windowTitle = _configuration[\"Rendering:WindowTitle\"];\n\n        // Access strongly-typed options\n        var width = _renderingOptions.WindowWidth;\n        var height = _renderingOptions.WindowHeight;\n\n        Logger.LogInformation(\"Window: {Title} ({Width}x{Height})\", \n            windowTitle, width, height);\n    }\n}</code></pre>"},{"location":"getting-started/configuration/#custom-configuration-sections","title":"Custom Configuration Sections","text":"<p>You can add your own configuration sections:</p>"},{"location":"getting-started/configuration/#1-define-your-options-class","title":"1. Define Your Options Class","text":"<pre><code>public class GameplayOptions\n{\n    public const string SectionName = \"Gameplay\";\n\n    public int StartingLives { get; set; } = 3;\n    public float PlayerSpeed { get; set; } = 200f;\n    public bool EnableCheats { get; set; } = false;\n    public string Difficulty { get; set; } = \"Normal\";\n}</code></pre>"},{"location":"getting-started/configuration/#2-add-to-gamesettingsjson","title":"2. Add to <code>gamesettings.json</code>","text":"<pre><code>{\n  \"Gameplay\": {\n    \"StartingLives\": 5,\n    \"PlayerSpeed\": 250.0,\n    \"EnableCheats\": false,\n    \"Difficulty\": \"Hard\"\n  }\n}</code></pre>"},{"location":"getting-started/configuration/#3-register-and-use","title":"3. Register and Use","text":"<pre><code>// Register in Program.cs\nbuilder.Services.Configure&lt;GameplayOptions&gt;(\n    builder.Configuration.GetSection(GameplayOptions.SectionName)\n);\n\n// Inject into scene\npublic class GameScene : Scene\n{\n    private readonly GameplayOptions _gameplay;\n\n    public GameScene\n    (\n        IOptions&lt;GameplayOptions&gt; gameplay,\n        ILogger&lt;GameScene&gt; logger\n    ) : base(logger)\n    {\n        _gameplay = gameplay.Value;\n    }\n\n    protected override void OnInitialize()\n    {\n        Logger.LogInformation(\"Starting with {Lives} lives at {Difficulty} difficulty\", \n            _gameplay.StartingLives, _gameplay.Difficulty);\n    }\n}</code></pre>"},{"location":"getting-started/configuration/#hot-reload","title":"Hot Reload","text":"<p>Configuration files support hot reload by default:</p> <pre><code>// In GameApplicationBuilder, this is already set up:\nConfiguration.AddJsonFile(\"gamesettings.json\", \n    optional: true, \n    reloadOnChange: true);  // \u2190 Hot reload enabled</code></pre>"},{"location":"getting-started/configuration/#using-ioptionsmonitor-for-hot-reload","title":"Using <code>IOptionsMonitor</code> for Hot Reload","text":"<p>If you need to detect configuration changes at runtime:</p> <pre><code>using Microsoft.Extensions.Options;\n\npublic class GameScene : Scene\n{\n    private readonly IOptionsMonitor&lt;RenderingOptions&gt; _renderingMonitor;\n\n    public GameScene\n    (\n        IOptionsMonitor&lt;RenderingOptions&gt; renderingMonitor,\n        ILogger&lt;GameScene&gt; logger\n    ) : base(logger)\n    {\n        _renderingMonitor = renderingMonitor;\n\n        // Subscribe to changes\n        _renderingMonitor.OnChange(options =&gt;\n        {\n            Logger.LogInformation(\"Configuration changed! New window size: {Width}x{Height}\", \n                options.WindowWidth, options.WindowHeight);\n        });\n    }\n\n    protected override void OnUpdate(GameTime gameTime)\n    {\n        // Always get current value\n        var currentOptions = _renderingMonitor.CurrentValue;\n    }\n}</code></pre>"},{"location":"getting-started/configuration/#command-line-arguments","title":"Command-Line Arguments","text":"<p>Override configuration with command-line arguments:</p> <pre><code># Command-line args are already added by default in CreateBuilder\n# They override JSON settings\n\n# Run with:\ndotnet run --Rendering:WindowWidth=1920 --Rendering:Fullscreen=true</code></pre>"},{"location":"getting-started/configuration/#in-gamesettingsjson","title":"In <code>gamesettings.json</code>:","text":"<pre><code>{\n  \"Rendering\": {\n    \"WindowWidth\": 1280,\n    \"Fullscreen\": false\n  }\n}</code></pre>"},{"location":"getting-started/configuration/#override-via-cli","title":"Override via CLI:","text":"<pre><code>dotnet run --Rendering:WindowWidth=1920 --Rendering:Fullscreen=true</code></pre> <p>Result: Window will be 1920 pixels wide and fullscreen.</p>"},{"location":"getting-started/configuration/#configuration-providers","title":"Configuration Providers","text":"<p>Brine2D uses Microsoft's configuration system, which supports multiple providers:</p> <pre><code>var builder = GameApplication.CreateBuilder(args);\n\n// JSON files (default)\nbuilder.Configuration.AddJsonFile(\"gamesettings.json\", optional: true, reloadOnChange: true);\nbuilder.Configuration.AddJsonFile(\"secrets.json\", optional: true);\n\n// Environment variables\nbuilder.Configuration.AddEnvironmentVariables(prefix: \"GAME_\");\n\n// Command-line arguments (already added by default)\nbuilder.Configuration.AddCommandLine(args);\n\n// User secrets (for development)\nif (builder.Environment.IsDevelopment())\n{\n    builder.Configuration.AddUserSecrets&lt;Program&gt;();\n}\n\n// In-memory values (for testing)\nbuilder.Configuration.AddInMemoryCollection(new Dictionary&lt;string, string?&gt;\n{\n    [\"Rendering:WindowTitle\"] = \"Test Window\"\n});</code></pre> <p>Priority Order (last wins): 1. JSON files 2. Environment variables 3. Command-line arguments 4. In-memory overrides</p>"},{"location":"getting-started/configuration/#common-patterns","title":"Common Patterns","text":""},{"location":"getting-started/configuration/#pattern-1-debug-vs-release-settings","title":"Pattern 1: Debug vs Release Settings","text":"<pre><code>builder.Services.AddSDL3Rendering(options =&gt;\n{\n    builder.Configuration.GetSection(\"Rendering\").Bind(options);\n\n#if DEBUG\n    options.WindowTitle += \" [DEBUG]\";\n    options.VSync = false; // Better for debugging\n#endif\n});</code></pre>"},{"location":"getting-started/configuration/#pattern-2-dynamic-resolution","title":"Pattern 2: Dynamic Resolution","text":"<pre><code>builder.Services.AddSDL3Rendering(options =&gt;\n{\n    builder.Configuration.GetSection(\"Rendering\").Bind(options);\n\n    // Let user override via CLI\n    if (args.Contains(\"--720p\"))\n    {\n        options.WindowWidth = 1280;\n        options.WindowHeight = 720;\n    }\n    else if (args.Contains(\"--1080p\"))\n    {\n        options.WindowWidth = 1920;\n        options.WindowHeight = 1080;\n    }\n});</code></pre>"},{"location":"getting-started/configuration/#pattern-3-platform-specific-settings","title":"Pattern 3: Platform-Specific Settings","text":"<pre><code>builder.Services.AddSDL3Rendering(options =&gt;\n{\n    builder.Configuration.GetSection(\"Rendering\").Bind(options);\n\n    // Auto-select best backend per platform\n    if (OperatingSystem.IsWindows())\n    {\n        options.PreferredGPUDriver = \"D3D12\";\n    }\n    else if (OperatingSystem.IsMacOS())\n    {\n        options.PreferredGPUDriver = \"Metal\";\n    }\n    else if (OperatingSystem.IsLinux())\n    {\n        options.PreferredGPUDriver = \"Vulkan\";\n    }\n});</code></pre>"},{"location":"getting-started/configuration/#best-practices","title":"Best Practices","text":""},{"location":"getting-started/configuration/#do-use-json-for-user-configurable-settings","title":"DO: Use JSON for User-Configurable Settings","text":"<p>Settings players might want to change (resolution, volume, graphics quality) should be in JSON.</p>"},{"location":"getting-started/configuration/#do-use-code-for-developer-settings","title":"DO: Use Code for Developer Settings","text":"<p>Settings developers control (debug flags, profiling) can be in code.</p>"},{"location":"getting-started/configuration/#do-validate-configuration","title":"DO: Validate Configuration","text":"<pre><code>builder.Services.AddSDL3Rendering(options =&gt;\n{\n    builder.Configuration.GetSection(\"Rendering\").Bind(options);\n\n    // Validate\n    if (options.WindowWidth &lt; 640 || options.WindowHeight &lt; 480)\n    {\n        throw new InvalidOperationException(\"Window size too small!\");\n    }\n});</code></pre>"},{"location":"getting-started/configuration/#do-use-strongly-typed-options","title":"DO: Use Strongly-Typed Options","text":"<p>Avoid magic strings\u2014create option classes for your settings.</p>"},{"location":"getting-started/configuration/#dont-hardcode-secrets","title":"DON'T: Hardcode Secrets","text":"<p>Never put API keys, passwords, or tokens in <code>gamesettings.json</code> that gets committed to Git. Use User Secrets or environment variables.</p>"},{"location":"getting-started/configuration/#dont-reload-configuration-mid-frame","title":"DON'T: Reload Configuration Mid-Frame","text":"<p>If you need to apply new settings (like resolution), do it between scenes, not during rendering.</p>"},{"location":"getting-started/configuration/#example-complete-configuration","title":"Example: Complete Configuration","text":"<p><code>gamesettings.json</code>:</p> <pre><code>{\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Information\",\n      \"Brine2D\": \"Debug\"\n    }\n  },\n  \"Rendering\": {\n    \"WindowTitle\": \"My Awesome Game\",\n    \"WindowWidth\": 1280,\n    \"WindowHeight\": 720,\n    \"Fullscreen\": false,\n    \"VSync\": true,\n    \"Resizable\": true,\n    \"Backend\": \"GPU\",\n    \"PreferredGPUDriver\": null\n  },\n  \"Gameplay\": {\n    \"StartingLives\": 3,\n    \"PlayerSpeed\": 200.0,\n    \"Difficulty\": \"Normal\"\n  }\n}</code></pre> <p><code>Program.cs</code>:</p> <pre><code>using Brine2D.Hosting;\nusing Brine2D.Input.SDL;\nusing Brine2D.Rendering.SDL;\n\nvar builder = GameApplication.CreateBuilder(args);\n\n// Configure rendering from JSON\nbuilder.Services.AddSDL3Rendering(options =&gt;\n{\n    builder.Configuration.GetSection(\"Rendering\").Bind(options);\n});\n\nbuilder.Services.AddSDL3Input();\n\n// Register custom options\nbuilder.Services.Configure&lt;GameplayOptions&gt;(\n    builder.Configuration.GetSection(\"Gameplay\")\n);\n\nbuilder.Services.AddScene&lt;GameScene&gt;();\n\nvar game = builder.Build();\nawait game.RunAsync&lt;GameScene&gt;();</code></pre>"},{"location":"getting-started/configuration/#next-steps","title":"Next Steps","text":"<ul> <li>Your First Game - Build a complete game</li> <li>Project Structure - Understanding the architecture</li> <li>Scene Management - Deep dive into scenes</li> <li>Logging Guide - Using <code>ILogger&lt;T&gt;</code> effectively</li> </ul> <p>Configuration in Brine2D works exactly like ASP.NET\u2014if you know one, you know the other!</p>"},{"location":"getting-started/first-game/","title":"Your First Game","text":"<p>Now that you've completed the Quick Start, let's build a complete game from scratch. We'll create a simple but fun game where you control a player sprite, avoid obstacles, and collect coins.</p>"},{"location":"getting-started/first-game/#what-youll-build","title":"What You'll Build","text":"<p>By the end of this tutorial, you'll have:</p> <ul> <li>\u2705 A movable player sprite</li> <li>\u2705 Obstacle collision detection</li> <li>\u2705 Collectible coins</li> <li>\u2705 Score tracking</li> <li>\u2705 Game over logic</li> <li>\u2705 Proper scene lifecycle management</li> <li>\u2705 Particle effects</li> <li>\u2705 Smooth movement physics</li> </ul> <p>Estimated time: 20-30 minutes</p>"},{"location":"getting-started/first-game/#prerequisites","title":"Prerequisites","text":"<ul> <li>Completed the Quick Start guide</li> <li>Basic understanding of C# and OOP</li> <li>.NET 10 SDK installed</li> </ul>"},{"location":"getting-started/first-game/#step-1-project-setup","title":"Step 1: Project Setup","text":"<p>Create a new console application:</p> <pre><code>dotnet new console -n CoinCollector\ncd CoinCollector</code></pre> <p>Add the Brine2D.Desktop package:</p> <pre><code>dotnet add package Brine2D.Desktop</code></pre>"},{"location":"getting-started/first-game/#step-2-create-the-game-scene","title":"Step 2: Create the Game Scene","text":"<p>Replace <code>Program.cs</code> with this code:</p> <pre><code>using Brine2D.Core;\nusing Brine2D.Engine;\nusing Brine2D.Hosting;\nusing Brine2D.Input;\nusing Brine2D.Input.SDL;\nusing Brine2D.Rendering;\nusing Brine2D.Rendering.SDL;\nusing Microsoft.Extensions.Logging;\nusing System.Numerics;\n\n// Create builder\nvar builder = GameApplication.CreateBuilder(args);\n\n// Configure services\nbuilder.Services.AddSDL3Rendering(options =&gt;\n{\n    options.WindowTitle = \"Coin Collector\";\n    options.WindowWidth = 800;\n    options.WindowHeight = 600;\n    options.VSync = true;\n});\n\nbuilder.Services.AddSDL3Input();\nbuilder.Services.AddScene&lt;GameScene&gt;();\n\n// Build and run\nvar game = builder.Build();\nawait game.RunAsync&lt;GameScene&gt;();\n\n// Game Scene\npublic class GameScene : Scene\n{\n    private readonly IRenderer _renderer;\n    private readonly IInputService _input;\n    private readonly IGameContext _gameContext;\n\n    // Game state\n    private Vector2 _playerPosition;\n    private float _playerSpeed = 200f;\n    private int _score = 0;\n    private bool _isGameOver = false;\n\n    // Game objects\n    private readonly List&lt;Vector2&gt; _obstacles = new();\n    private readonly List&lt;Vector2&gt; _coins = new();\n\n    public GameScene(\n        IRenderer renderer,\n        IInputService input,\n        IGameContext gameContext,\n        ILogger&lt;GameScene&gt; logger\n    ) : base(logger)\n    {\n        _renderer = renderer;\n        _input = input;\n        _gameContext = gameContext;\n        _playerPosition = new Vector2(400, 300);\n    }\n\n    protected override void OnInitialize()\n    {\n        Logger.LogInformation(\"Coin Collector initialized!\");\n\n        // Create obstacles\n        _obstacles.Add(new Vector2(200, 150));\n        _obstacles.Add(new Vector2(600, 200));\n        _obstacles.Add(new Vector2(300, 400));\n        _obstacles.Add(new Vector2(500, 450));\n\n        // Create coins\n        _coins.Add(new Vector2(100, 100));\n        _coins.Add(new Vector2(700, 100));\n        _coins.Add(new Vector2(100, 500));\n        _coins.Add(new Vector2(700, 500));\n        _coins.Add(new Vector2(400, 50));\n    }\n\n    protected override void OnUpdate(GameTime gameTime)\n    {\n        if (_isGameOver)\n        {\n            // Press R to restart\n            if (_input.IsKeyPressed(Keys.R))\n            {\n                RestartGame();\n            }\n\n            if (_input.IsKeyPressed(Keys.Escape))\n            {\n                _gameContext.RequestExit();\n            }\n            return;\n        }\n\n        var deltaTime = (float)gameTime.DeltaTime;\n\n        // Player movement\n        var movement = Vector2.Zero;\n        if (_input.IsKeyDown(Keys.W)) movement.Y -= 1;\n        if (_input.IsKeyDown(Keys.S)) movement.Y += 1;\n        if (_input.IsKeyDown(Keys.A)) movement.X -= 1;\n        if (_input.IsKeyDown(Keys.D)) movement.X += 1;\n\n        if (movement != Vector2.Zero)\n        {\n            movement = Vector2.Normalize(movement);\n            _playerPosition += movement * _playerSpeed * deltaTime;\n\n            // Keep player in bounds\n            _playerPosition.X = Math.Clamp(_playerPosition.X, 20, 780);\n            _playerPosition.Y = Math.Clamp(_playerPosition.Y, 20, 580);\n        }\n\n        // Check collision with obstacles\n        foreach (var obstacle in _obstacles)\n        {\n            if (CheckCollision(_playerPosition, obstacle, 20, 30))\n            {\n                _isGameOver = true;\n                Logger.LogInformation(\"Game Over! Final Score: {Score}\", _score);\n                return;\n            }\n        }\n\n        // Check collision with coins\n        for (int i = _coins.Count - 1; i &gt;= 0; i--)\n        {\n            if (CheckCollision(_playerPosition, _coins[i], 20, 15))\n            {\n                _coins.RemoveAt(i);\n                _score += 10;\n                Logger.LogInformation(\"Coin collected! Score: {Score}\", _score);\n\n                // Win condition\n                if (_coins.Count == 0)\n                {\n                    Logger.LogInformation(\"You Win! Final Score: {Score}\", _score);\n                    _isGameOver = true;\n                }\n            }\n        }\n\n        // Exit\n        if (_input.IsKeyPressed(Keys.Escape))\n        {\n            _gameContext.RequestExit();\n        }\n    }\n\n    protected override void OnRender(GameTime gameTime)\n    {\n        _renderer.Clear(new Color(20, 20, 30)); // Dark blue background\n        _renderer.BeginFrame();\n\n        if (!_isGameOver)\n        {\n            // Draw obstacles (red squares)\n            foreach (var obstacle in _obstacles)\n            {\n                _renderer.DrawRectangle(\n                    obstacle.X - 15, \n                    obstacle.Y - 15, \n                    30, \n                    30, \n                    new Color(200, 50, 50)\n                );\n            }\n\n            // Draw coins (yellow circles - using squares for now)\n            foreach (var coin in _coins)\n            {\n                _renderer.DrawRectangle(\n                    coin.X - 7, \n                    coin.Y - 7, \n                    15, \n                    15, \n                    new Color(255, 215, 0)\n                );\n            }\n\n            // Draw player (blue square)\n            _renderer.DrawRectangle(\n                _playerPosition.X - 10, \n                _playerPosition.Y - 10, \n                20, \n                20, \n                new Color(50, 150, 255)\n            );\n\n            // Draw score\n            _renderer.DrawText($\"Score: {_score}\", 10, 10, Color.White);\n            _renderer.DrawText($\"Coins: {_coins.Count}\", 10, 30, Color.White);\n        }\n        else\n        {\n            // Game over screen\n            if (_coins.Count == 0)\n            {\n                _renderer.DrawText(\"YOU WIN!\", 300, 250, new Color(0, 255, 0));\n            }\n            else\n            {\n                _renderer.DrawText(\"GAME OVER\", 280, 250, new Color(255, 0, 0));\n            }\n\n            _renderer.DrawText($\"Final Score: {_score}\", 300, 300, Color.White);\n            _renderer.DrawText(\"Press R to Restart\", 270, 350, Color.White);\n            _renderer.DrawText(\"Press ESC to Exit\", 280, 380, Color.White);\n        }\n\n        _renderer.EndFrame();\n    }\n\n    private bool CheckCollision(Vector2 pos1, Vector2 pos2, float radius1, float radius2)\n    {\n        var distance = Vector2.Distance(pos1, pos2);\n        return distance &lt; (radius1 + radius2);\n    }\n\n    private void RestartGame()\n    {\n        _playerPosition = new Vector2(400, 300);\n        _score = 0;\n        _isGameOver = false;\n\n        // Reset coins\n        _coins.Clear();\n        _coins.Add(new Vector2(100, 100));\n        _coins.Add(new Vector2(700, 100));\n        _coins.Add(new Vector2(100, 500));\n        _coins.Add(new Vector2(700, 500));\n        _coins.Add(new Vector2(400, 50));\n\n        Logger.LogInformation(\"Game restarted!\");\n    }\n}</code></pre>"},{"location":"getting-started/first-game/#step-3-run-your-game","title":"Step 3: Run Your Game","text":"<p>Build and run:</p> <pre><code>dotnet run</code></pre> <p>You should see: - A blue square (player) in the center - Red squares (obstacles) scattered around - Yellow squares (coins) to collect - Score counter at the top</p>"},{"location":"getting-started/first-game/#controls","title":"Controls:","text":"<ul> <li>WASD - Move player</li> <li>R - Restart (when game over)</li> <li>ESC - Exit game</li> </ul>"},{"location":"getting-started/first-game/#understanding-the-code","title":"Understanding the Code","text":"<p>Let's break down what we built:</p>"},{"location":"getting-started/first-game/#1-game-state","title":"1. Game State","text":"<pre><code>private Vector2 _playerPosition;\nprivate float _playerSpeed = 200f;\nprivate int _score = 0;\nprivate bool _isGameOver = false;\n\nprivate readonly List&lt;Vector2&gt; _obstacles = new();\nprivate readonly List&lt;Vector2&gt; _coins = new();</code></pre> <p>We track the player's position, speed, score, and game state. Lists hold obstacle and coin positions.</p>"},{"location":"getting-started/first-game/#2-initialization","title":"2. Initialization","text":"<pre><code>protected override void OnInitialize()\n{\n    Logger.LogInformation(\"Coin Collector initialized!\");\n\n    // Create obstacles\n    _obstacles.Add(new Vector2(200, 150));\n    // ... more obstacles\n\n    // Create coins\n    _coins.Add(new Vector2(100, 100));\n    // ... more coins\n}</code></pre> <p><code>OnInitialize()</code> runs once when the scene loads. We set up our game world here.</p>"},{"location":"getting-started/first-game/#3-update-loop","title":"3. Update Loop","text":"<pre><code>protected override void OnUpdate(GameTime gameTime)\n{\n    var deltaTime = (float)gameTime.DeltaTime;\n\n    // Player movement\n    var movement = Vector2.Zero;\n    if (_input.IsKeyDown(Keys.W)) movement.Y -= 1;\n    // ... handle input\n\n    _playerPosition += movement * _playerSpeed * deltaTime;\n\n    // Check collisions\n    // ... collision logic\n}</code></pre> <p><code>OnUpdate()</code> runs every frame. We:</p> <ol> <li>Get input</li> <li>Move the player</li> <li>Check collisions</li> <li>Update game state</li> </ol> <p>Key concept: We multiply movement by <code>deltaTime</code> to make it frame-rate independent.</p>"},{"location":"getting-started/first-game/#4-render-loop","title":"4. Render Loop","text":"<pre><code>protected override void OnRender(GameTime gameTime)\n{\n    _renderer.Clear(new Color(20, 20, 30));\n    _renderer.BeginFrame();\n\n    // Draw game objects\n    _renderer.DrawRectangle(...);\n\n    _renderer.EndFrame();\n}</code></pre> <p><code>OnRender()</code> draws everything. Always call:</p> <ol> <li><code>Clear()</code> - Clear the screen</li> <li><code>BeginFrame()</code> - Start drawing</li> <li>Draw your stuff</li> <li><code>EndFrame()</code> - Present to screen</li> </ol>"},{"location":"getting-started/first-game/#5-collision-detection","title":"5. Collision Detection","text":"<pre><code>private bool CheckCollision(Vector2 pos1, Vector2 pos2, float radius1, float radius2)\n{\n    var distance = Vector2.Distance(pos1, pos2);\n    return distance &lt; (radius1 + radius2);\n}</code></pre> <p>Simple circle-circle collision using distance between centers.</p>"},{"location":"getting-started/first-game/#step-4-enhance-your-game","title":"Step 4: Enhance Your Game","text":"<p>Now let's make it better! We'll add particle effects, a timer, and smooth movement physics.</p>"},{"location":"getting-started/first-game/#add-particle-effects-on-coin-collection","title":"Add Particle Effects on Coin Collection","text":"<p>Add this <code>Particle</code> class after the <code>GameScene</code> class:</p> <pre><code>public class Particle\n{\n    public Vector2 Position;\n    public Vector2 Velocity;\n    public float Lifetime;\n    public Color Color;\n}</code></pre> <p>In the <code>GameScene</code> class, add a field to track particles:</p> <pre><code>private readonly List&lt;Particle&gt; _particles = new();</code></pre> <p>Update the coin collection code in <code>OnUpdate()</code>:</p> <pre><code>// Check collision with coins\nfor (int i = _coins.Count - 1; i &gt;= 0; i--)\n{\n    if (CheckCollision(_playerPosition, _coins[i], 20, 15))\n    {\n        // Spawn particles\n        for (int p = 0; p &lt; 5; p++)\n        {\n            _particles.Add(new Particle\n            {\n                Position = _coins[i],\n                Velocity = new Vector2(\n                    Random.Shared.NextSingle() * 100 - 50,\n                    Random.Shared.NextSingle() * 100 - 50\n                ),\n                Lifetime = 1.0f,\n                Color = new Color(255, 215, 0)\n            });\n        }\n\n        _coins.RemoveAt(i);\n        _score += 10;\n        Logger.LogInformation(\"Coin collected! Score: {Score}\", _score);\n\n        // Win condition\n        if (_coins.Count == 0)\n        {\n            Logger.LogInformation(\"You Win! Final Score: {Score}\", _score);\n            _isGameOver = true;\n        }\n    }\n}</code></pre> <p>Add particle update logic in <code>OnUpdate()</code> (after player movement):</p> <pre><code>// Update particles\nfor (int i = _particles.Count - 1; i &gt;= 0; i--)\n{\n    var p = _particles[i];\n    p.Position += p.Velocity * deltaTime;\n    p.Lifetime -= deltaTime;\n\n    if (p.Lifetime &lt;= 0)\n    {\n        _particles.RemoveAt(i);\n    }\n}</code></pre> <p>Add particle rendering in <code>OnRender()</code> (after drawing coins):</p> <pre><code>// Draw particles\nforeach (var p in _particles)\n{\n    var alpha = (byte)(255 * (p.Lifetime / 1.0f));\n    _renderer.DrawRectangle(\n        p.Position.X - 2, \n        p.Position.Y - 2, \n        4, \n        4, \n        new Color(p.Color.R, p.Color.G, p.Color.B, alpha)\n    );\n}</code></pre>"},{"location":"getting-started/first-game/#add-a-timer","title":"Add a Timer","text":"<p>Add a field to track game time:</p> <pre><code>private double _gameTime = 0;</code></pre> <p>In <code>OnUpdate()</code>, add this before checking input (when not game over):</p> <pre><code>_gameTime += gameTime.DeltaTime;</code></pre> <p>In <code>OnRender()</code>, add this after drawing the coins count:</p> <pre><code>_renderer.DrawText($\"Time: {(int)_gameTime}s\", 10, 50, Color.White);</code></pre> <p>Don't forget to reset the timer in <code>RestartGame()</code>:</p> <pre><code>_gameTime = 0;</code></pre>"},{"location":"getting-started/first-game/#add-smooth-movement","title":"Add Smooth Movement","text":"<p>Add fields for velocity-based movement:</p> <pre><code>private Vector2 _velocity = Vector2.Zero;\nprivate float _acceleration = 500f;\nprivate float _friction = 0.9f;</code></pre> <p>Replace the player movement code in <code>OnUpdate()</code>:</p> <pre><code>// Player movement with physics\nvar input = Vector2.Zero;\nif (_input.IsKeyDown(Keys.W)) input.Y -= 1;\nif (_input.IsKeyDown(Keys.S)) input.Y += 1;\nif (_input.IsKeyDown(Keys.A)) input.X -= 1;\nif (_input.IsKeyDown(Keys.D)) input.X += 1;\n\nif (input != Vector2.Zero)\n{\n    input = Vector2.Normalize(input);\n    _velocity += input * _acceleration * deltaTime;\n}\n\n// Apply friction\n_velocity *= _friction;\n\n// Move player\n_playerPosition += _velocity * deltaTime;\n\n// Keep player in bounds\n_playerPosition.X = Math.Clamp(_playerPosition.X, 20, 780);\n_playerPosition.Y = Math.Clamp(_playerPosition.Y, 20, 580);</code></pre> <p>Reset velocity in <code>RestartGame()</code>:</p> <pre><code>_velocity = Vector2.Zero;</code></pre>"},{"location":"getting-started/first-game/#complete-code-with-all-enhancements","title":"Complete Code with All Enhancements","text":"<p>Here's the full <code>Program.cs</code> with all enhancements integrated:</p> <pre><code>using Brine2D.Core;\nusing Brine2D.Engine;\nusing Brine2D.Hosting;\nusing Brine2D.Input;\nusing Brine2D.Input.SDL;\nusing Brine2D.Rendering;\nusing Brine2D.Rendering.SDL;\nusing Microsoft.Extensions.Logging;\nusing System.Numerics;\n\n// Create builder\nvar builder = GameApplication.CreateBuilder(args);\n\n// Configure services\nbuilder.Services.AddSDL3Rendering(options =&gt;\n{\n    options.WindowTitle = \"Coin Collector\";\n    options.WindowWidth = 800;\n    options.WindowHeight = 600;\n    options.VSync = true;\n});\n\nbuilder.Services.AddSDL3Input();\nbuilder.Services.AddScene&lt;GameScene&gt;();\n\n// Build and run\nvar game = builder.Build();\nawait game.RunAsync&lt;GameScene&gt;();\n\n// Game Scene\npublic class GameScene : Scene\n{\n    private readonly IRenderer _renderer;\n    private readonly IInputService _input;\n    private readonly IGameContext _gameContext;\n\n    // Game state\n    private Vector2 _playerPosition;\n    private Vector2 _velocity = Vector2.Zero;\n    private float _playerSpeed = 200f;\n    private float _acceleration = 500f;\n    private float _friction = 0.9f;\n    private int _score = 0;\n    private double _gameTime = 0;\n    private bool _isGameOver = false;\n\n    // Game objects\n    private readonly List&lt;Vector2&gt; _obstacles = new();\n    private readonly List&lt;Vector2&gt; _coins = new();\n    private readonly List&lt;Particle&gt; _particles = new();\n\n    public GameScene(\n        IRenderer renderer,\n        IInputService input,\n        IGameContext gameContext,\n        ILogger&lt;GameScene&gt; logger\n    ) : base(logger)\n    {\n        _renderer = renderer;\n        _input = input;\n        _gameContext = gameContext;\n        _playerPosition = new Vector2(400, 300);\n    }\n\n    protected override void OnInitialize()\n    {\n        Logger.LogInformation(\"Coin Collector initialized!\");\n\n        // Create obstacles\n        _obstacles.Add(new Vector2(200, 150));\n        _obstacles.Add(new Vector2(600, 200));\n        _obstacles.Add(new Vector2(300, 400));\n        _obstacles.Add(new Vector2(500, 450));\n\n        // Create coins\n        _coins.Add(new Vector2(100, 100));\n        _coins.Add(new Vector2(700, 100));\n        _coins.Add(new Vector2(100, 500));\n        _coins.Add(new Vector2(700, 500));\n        _coins.Add(new Vector2(400, 50));\n    }\n\n    protected override void OnUpdate(GameTime gameTime)\n    {\n        if (_isGameOver)\n        {\n            // Press R to restart\n            if (_input.IsKeyPressed(Keys.R))\n            {\n                RestartGame();\n            }\n\n            if (_input.IsKeyPressed(Keys.Escape))\n            {\n                _gameContext.RequestExit();\n            }\n            return;\n        }\n\n        var deltaTime = (float)gameTime.DeltaTime;\n\n        // Update game time\n        _gameTime += gameTime.DeltaTime;\n\n        // Player movement with physics\n        var input = Vector2.Zero;\n        if (_input.IsKeyDown(Keys.W)) input.Y -= 1;\n        if (_input.IsKeyDown(Keys.S)) input.Y += 1;\n        if (_input.IsKeyDown(Keys.A)) input.X -= 1;\n        if (_input.IsKeyDown(Keys.D)) input.X += 1;\n\n        if (input != Vector2.Zero)\n        {\n            input = Vector2.Normalize(input);\n            _velocity += input * _acceleration * deltaTime;\n        }\n\n        // Apply friction\n        _velocity *= _friction;\n\n        // Move player\n        _playerPosition += _velocity * deltaTime;\n\n        // Keep player in bounds\n        _playerPosition.X = Math.Clamp(_playerPosition.X, 20, 780);\n        _playerPosition.Y = Math.Clamp(_playerPosition.Y, 20, 580);\n\n        // Update particles\n        for (int i = _particles.Count - 1; i &gt;= 0; i--)\n        {\n            var p = _particles[i];\n            p.Position += p.Velocity * deltaTime;\n            p.Lifetime -= deltaTime;\n\n            if (p.Lifetime &lt;= 0)\n            {\n                _particles.RemoveAt(i);\n            }\n        }\n\n        // Check collision with obstacles\n        foreach (var obstacle in _obstacles)\n        {\n            if (CheckCollision(_playerPosition, obstacle, 20, 30))\n            {\n                _isGameOver = true;\n                Logger.LogInformation(\"Game Over! Final Score: {Score}\", _score);\n                return;\n            }\n        }\n\n        // Check collision with coins\n        for (int i = _coins.Count - 1; i &gt;= 0; i--)\n        {\n            if (CheckCollision(_playerPosition, _coins[i], 20, 15))\n            {\n                // Spawn particles\n                for (int p = 0; p &lt; 5; p++)\n                {\n                    _particles.Add(new Particle\n                    {\n                        Position = _coins[i],\n                        Velocity = new Vector2(\n                            Random.Shared.NextSingle() * 100 - 50,\n                            Random.Shared.NextSingle() * 100 - 50\n                        ),\n                        Lifetime = 1.0f,\n                        Color = new Color(255, 215, 0)\n                    });\n                }\n\n                _coins.RemoveAt(i);\n                _score += 10;\n                Logger.LogInformation(\"Coin collected! Score: {Score}\", _score);\n\n                // Win condition\n                if (_coins.Count == 0)\n                {\n                    Logger.LogInformation(\"You Win! Final Score: {Score}\", _score);\n                    _isGameOver = true;\n                }\n            }\n        }\n\n        // Exit\n        if (_input.IsKeyPressed(Keys.Escape))\n        {\n            _gameContext.RequestExit();\n        }\n    }\n\n    protected override void OnRender(GameTime gameTime)\n    {\n        _renderer.Clear(new Color(20, 20, 30)); // Dark blue background\n        _renderer.BeginFrame();\n\n        if (!_isGameOver)\n        {\n            // Draw obstacles (red squares)\n            foreach (var obstacle in _obstacles)\n            {\n                _renderer.DrawRectangle(\n                    obstacle.X - 15, \n                    obstacle.Y - 15, \n                    30, \n                    30, \n                    new Color(200, 50, 50)\n                );\n            }\n\n            // Draw coins (yellow squares)\n            foreach (var coin in _coins)\n            {\n                _renderer.DrawRectangle(\n                    coin.X - 7, \n                    coin.Y - 7, \n                    15, \n                    15, \n                    new Color(255, 215, 0)\n                );\n            }\n\n            // Draw particles\n            foreach (var p in _particles)\n            {\n                var alpha = (byte)(255 * (p.Lifetime / 1.0f));\n                _renderer.DrawRectangle(\n                    p.Position.X - 2, \n                    p.Position.Y - 2, \n                    4, \n                    4, \n                    new Color(p.Color.R, p.Color.G, p.Color.B, alpha)\n                );\n            }\n\n            // Draw player (blue square)\n            _renderer.DrawRectangle(\n                _playerPosition.X - 10, \n                _playerPosition.Y - 10, \n                20, \n                20, \n                new Color(50, 150, 255)\n            );\n\n            // Draw HUD\n            _renderer.DrawText($\"Score: {_score}\", 10, 10, Color.White);\n            _renderer.DrawText($\"Coins: {_coins.Count}\", 10, 30, Color.White);\n            _renderer.DrawText($\"Time: {(int)_gameTime}s\", 10, 50, Color.White);\n        }\n        else\n        {\n            // Game over screen\n            if (_coins.Count == 0)\n            {\n                _renderer.DrawText(\"YOU WIN!\", 300, 250, new Color(0, 255, 0));\n            }\n            else\n            {\n                _renderer.DrawText(\"GAME OVER\", 280, 250, new Color(255, 0, 0));\n            }\n\n            _renderer.DrawText($\"Final Score: {_score}\", 300, 300, Color.White);\n            _renderer.DrawText($\"Time: {(int)_gameTime}s\", 320, 330, Color.White);\n            _renderer.DrawText(\"Press R to Restart\", 270, 380, Color.White);\n            _renderer.DrawText(\"Press ESC to Exit\", 280, 410, Color.White);\n        }\n\n        _renderer.EndFrame();\n    }\n\n    private bool CheckCollision(Vector2 pos1, Vector2 pos2, float radius1, float radius2)\n    {\n        var distance = Vector2.Distance(pos1, pos2);\n        return distance &lt; (radius1 + radius2);\n    }\n\n    private void RestartGame()\n    {\n        _playerPosition = new Vector2(400, 300);\n        _velocity = Vector2.Zero;\n        _score = 0;\n        _gameTime = 0;\n        _isGameOver = false;\n\n        // Reset coins\n        _coins.Clear();\n        _coins.Add(new Vector2(100, 100));\n        _coins.Add(new Vector2(700, 100));\n        _coins.Add(new Vector2(100, 500));\n        _coins.Add(new Vector2(700, 500));\n        _coins.Add(new Vector2(400, 50));\n\n        // Clear particles\n        _particles.Clear();\n\n        Logger.LogInformation(\"Game restarted!\");\n    }\n}\n\n// Particle class\npublic class Particle\n{\n    public Vector2 Position;\n    public Vector2 Velocity;\n    public float Lifetime;\n    public Color Color;\n}</code></pre>"},{"location":"getting-started/first-game/#what-youve-learned","title":"What You've Learned","text":"<p>\u2705 Scene lifecycle - <code>OnInitialize()</code>, <code>OnUpdate()</code>, <code>OnRender()</code> \u2705 Input handling - Keyboard input with <code>IInputService</code> \u2705 Game state - Managing player, obstacles, and collectibles \u2705 Collision detection - Simple circle-based collision \u2705 Game flow - Win/lose conditions and restart logic \u2705 Delta time - Frame-rate independent movement \u2705 Rendering - Drawing shapes and text \u2705 Logging - Using <code>ILogger&lt;T&gt;</code> for debugging \u2705 Particle systems - Simple particle effects \u2705 Physics - Velocity-based movement with friction  </p>"},{"location":"getting-started/first-game/#next-steps","title":"Next Steps","text":"<p>Now that you have a complete game, you can:</p> <ul> <li>Learn about Sprites - Replace shapes with actual graphics</li> <li>Add Animations - Animate your player character</li> <li>Use the Collision System - More robust collision detection</li> <li>Add Audio - Sound effects and music</li> </ul> <p>Congratulations! You've built your first complete game with Brine2D. You now understand the core concepts and are ready to build more complex games.</p>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>Get Brine2D installed and ready for game development in just a few minutes.</p>"},{"location":"getting-started/installation/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, make sure you have:</p> <ul> <li>.NET 10 SDK or later</li> <li>A code editor:</li> <li>Visual Studio 2022 (17.9+) - Full IDE with debugging</li> <li>Visual Studio Code - Lightweight with C# extension</li> <li>JetBrains Rider - Cross-platform IDE</li> <li>Basic C# knowledge - Familiarity with C# and .NET</li> </ul> <p>Verify .NET Installation</p> <p>Open a terminal and run: <pre><code>dotnet --version</code></pre> You should see <code>10.0.x</code> or higher.</p>"},{"location":"getting-started/installation/#installation-methods","title":"Installation Methods","text":"<p>Choose the method that works best for you:</p>"},{"location":"getting-started/installation/#method-1-nuget-package-recommended","title":"Method 1: NuGet Package (Recommended)","text":"<p>The easiest way to get started. Perfect for most users.</p> <p>1. Create a new project:</p> <pre><code>dotnet new console -n MyGame\ncd MyGame</code></pre> <p>2. Add Brine2D:</p> <pre><code>dotnet add package Brine2D.Desktop</code></pre> <p>3. Done! You're ready to start coding.</p>"},{"location":"getting-started/installation/#method-2-visual-studio-gui","title":"Method 2: Visual Studio (GUI)","text":"<p>If you prefer Visual Studio's interface:</p> <p>1. Create a new project:</p> <ul> <li>File \u2192 New \u2192 Project</li> <li>Select Console App (.NET 10)</li> <li>Name it <code>MyGame</code></li> <li>Click Create</li> </ul> <p>2. Add NuGet Package:</p> <ul> <li>Right-click project \u2192 Manage NuGet Packages</li> <li>Click Browse tab</li> <li>Check Include prerelease</li> <li>Search for <code>Brine2D.Desktop</code></li> <li>Click Install</li> </ul> <p>3. Done! Start coding in <code>Program.cs</code>.</p>"},{"location":"getting-started/installation/#method-3-building-from-source","title":"Method 3: Building from Source","text":"<p>For contributors or users who want the latest development version:</p> <p>1. Clone the repository:</p> <pre><code>git clone https://github.com/CrazyPickleStudios/Brine2D.git\ncd Brine2D</code></pre> <p>2. Build the solution:</p> <pre><code>dotnet build</code></pre> <p>3. Reference in your game project:</p> <p>Create your game project in a separate directory:</p> <pre><code>cd ..\ndotnet new console -n MyGame\ncd MyGame</code></pre> <p>Add project references:</p> <pre><code>dotnet add reference ../Brine2D/src/Brine2D.Core/Brine2D.Core.csproj\ndotnet add reference ../Brine2D/src/Brine2D.Engine/Brine2D.Engine.csproj\ndotnet add reference ../Brine2D/src/Brine2D.Hosting/Brine2D.Hosting.csproj\ndotnet add reference ../Brine2D/src/Brine2D.Rendering.SDL/Brine2D.Rendering.SDL.csproj\ndotnet add reference ../Brine2D/src/Brine2D.Input.SDL/Brine2D.Input.SDL.csproj\ndotnet add reference ../Brine2D/src/Brine2D.Audio.SDL/Brine2D.Audio.SDL.csproj\ndotnet add reference ../Brine2D/src/Brine2D.UI/Brine2D.UI.csproj\ndotnet add reference ../Brine2D/src/Brine2D.ECS/Brine2D.ECS.csproj</code></pre>"},{"location":"getting-started/installation/#package-options","title":"Package Options","text":"<p>Brine2D offers flexible package options depending on your needs:</p>"},{"location":"getting-started/installation/#brine2ddesktop-recommended","title":"Brine2D.Desktop (Recommended)","text":"<p>The all-in-one package. Includes everything you need for desktop game development.</p> <pre><code>dotnet add package Brine2D.Desktop</code></pre> <p>Includes:</p> <ul> <li>\u2705 Core abstractions (<code>Brine2D.Core</code>)</li> <li>\u2705 Game engine (<code>Brine2D.Engine</code>)</li> <li>\u2705 Hosting system (<code>Brine2D.Hosting</code>)</li> <li>\u2705 Entity Component System (<code>Brine2D.ECS</code>)</li> <li>\u2705 SDL3 rendering (<code>Brine2D.Rendering.SDL</code>)</li> <li>\u2705 SDL3 input (<code>Brine2D.Input.SDL</code>)</li> <li>\u2705 SDL3 audio (<code>Brine2D.Audio.SDL</code>)</li> <li>\u2705 UI framework (<code>Brine2D.UI</code>)</li> </ul> <p>Perfect for: 99% of users. Just install and start building!</p>"},{"location":"getting-started/installation/#individual-packages-advanced","title":"Individual Packages (Advanced)","text":"<p>For advanced users who want fine-grained control:</p> <p>Core Packages:</p> <pre><code># Core abstractions and types\ndotnet add package Brine2D.Core\n\n# Game loop, scene management, and transitions\ndotnet add package Brine2D.Engine\n\n# ASP.NET-style hosting\ndotnet add package Brine2D.Hosting\n\n# Entity Component System\ndotnet add package Brine2D.ECS</code></pre> <p>Abstraction Layers:</p> <pre><code># Rendering abstractions (IRenderer, ITexture, etc.)\ndotnet add package Brine2D.Rendering\n\n# Input abstractions (IInputService)\ndotnet add package Brine2D.Input\n\n# Audio abstractions (IAudioService)\ndotnet add package Brine2D.Audio</code></pre> <p>SDL3 Implementations:</p> <pre><code># SDL3 rendering backend\ndotnet add package Brine2D.Rendering.SDL\n\n# SDL3 input backend\ndotnet add package Brine2D.Input.SDL\n\n# SDL3 audio backend\ndotnet add package Brine2D.Audio.SDL</code></pre> <p>Extensions:</p> <pre><code># UI components (buttons, inputs, dialogs, tabs, etc.)\ndotnet add package Brine2D.UI</code></pre> <p>Use case: Custom setups, plugin development, or minimal dependencies.</p>"},{"location":"getting-started/installation/#verify-installation","title":"Verify Installation","text":"<p>Let's verify everything is working correctly.</p>"},{"location":"getting-started/installation/#1-create-a-test-program","title":"1. Create a Test Program","text":"<p>Replace your <code>Program.cs</code> with:</p> <pre><code>using Brine2D.Core;\nusing Brine2D.Hosting;\nusing Brine2D.Input;\nusing Brine2D.Input.SDL;\nusing Brine2D.Rendering;\nusing Brine2D.Rendering.SDL;\nusing Microsoft.Extensions.Logging;\n\nvar builder = GameApplication.CreateBuilder(args);\n\nbuilder.Services.AddSDL3Rendering(options =&gt;\n{\n    options.WindowTitle = \"Brine2D Installation Test\";\n    options.WindowWidth = 800;\n    options.WindowHeight = 600;\n});\n\nbuilder.Services.AddSDL3Input();\nbuilder.Services.AddScene&lt;TestScene&gt;();\n\nvar game = builder.Build();\nawait game.RunAsync&lt;TestScene&gt;();\n\npublic class TestScene : Scene\n{\n    private readonly IRenderer _renderer;\n    private readonly IInputService _input;\n    private readonly IGameContext _context;\n\n    public TestScene(\n        IRenderer renderer,\n        IInputService input,\n        IGameContext context,\n        ILogger&lt;TestScene&gt; logger\n    ) : base(logger)\n    {\n        _renderer = renderer;\n        _input = input;\n        _context = context;\n    }\n\n    protected override void OnRender(GameTime gameTime)\n    {\n        // Frame management happens automatically!\n        _renderer.DrawRectangleFilled(350, 250, 100, 100, Color.White);\n        _renderer.DrawText(\"Installation successful!\", 250, 280, Color.White);\n        _renderer.DrawText(\"Press ESC to exit\", 280, 320, Color.White);\n    }\n\n    protected override void OnUpdate(GameTime gameTime)\n    {\n        if (_input.IsKeyPressed(Keys.Escape))\n        {\n            _context.RequestExit();\n        }\n    }\n}</code></pre> <p>!!! tip Automatic Frame Management\"     Notice we don't call <code>Clear()</code>, <code>BeginFrame()</code>, or <code>EndFrame()</code> - the framework handles this automatically!</p>"},{"location":"getting-started/installation/#2-run-the-test","title":"2. Run the Test","text":"<pre><code>dotnet run</code></pre> <p>Expected result:</p> <ul> <li>A window opens with a blue background</li> <li>White square in the center</li> <li>Text: \"Installation successful!\"</li> <li>Pressing ESC closes the window</li> </ul> <p>\u2705 If you see this, Brine2D is installed correctly!</p>"},{"location":"getting-started/installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/installation/#could-not-find-package-brine2ddesktop","title":"\"Could not find package Brine2D.Desktop\"","text":"<p>Solution: 1. Make sure you're targeting .NET 10:</p> <pre><code>&lt;TargetFramework&gt;net10.0&lt;/TargetFramework&gt;</code></pre> <ol> <li>Include prerelease packages:</li> </ol> <pre><code>dotnet add package Brine2D.Desktop --prerelease</code></pre> <ol> <li>Try restoring packages explicitly:</li> </ol> <pre><code>dotnet restore</code></pre> <ol> <li>Check NuGet.org is accessible:</li> </ol> <pre><code>dotnet nuget list source</code></pre>"},{"location":"getting-started/installation/#sdl3-native-libraries-not-found","title":"\"SDL3 native libraries not found\"","text":"<p>Cause: SDL3 native binaries aren't being copied to output.</p> <p>Solution:</p> <ol> <li>Clean and rebuild:</li> </ol> <pre><code>dotnet clean\ndotnet build</code></pre> <ol> <li>Verify SDL3-CS packages are installed:</li> </ol> <pre><code>dotnet list package</code></pre> <p>You should see:</p> <ul> <li><code>SDL3-CS</code></li> <li><code>SDL3-CS.Native</code></li> <li><code>SDL3-CS.Native.TTF</code></li> <li><code>SDL3-CS.Native.Image</code></li> <li> <p><code>SDL3-CS.Native.Mixer</code></p> </li> <li> <p>If issues persist, manually download SDL3 from libsdl.org and place DLLs in your output directory.</p> </li> </ul>"},{"location":"getting-started/installation/#window-doesnt-appear-or-black-screen","title":"\"Window doesn't appear\" or \"Black screen\"","text":"<p>Solution:</p> <ol> <li>Check logs for errors:</li> </ol> <pre><code>dotnet run --verbosity normal</code></pre> <ol> <li>Frame management is automatic. If using manual control, make sure you're calling <code>BeginFrame()</code> and <code>EndFrame()</code>:</li> </ol> <pre><code>public override bool EnableAutomaticFrameManagement =&gt; false;\n\nprotected override void OnRender(GameTime gameTime)\n{\n    _renderer.Clear(Color.Black);\n    _renderer.BeginFrame();\n\n    // Your drawing code...\n\n    _renderer.EndFrame();\n}</code></pre> <ol> <li>Verify graphics drivers are up to date.</li> </ol>"},{"location":"getting-started/installation/#text-renders-as-rectangles","title":"\"Text renders as rectangles\"","text":"<p>Cause: Default font isn't loading (rare).</p> <p>Solution:</p> <p>The embedded Roboto font should work automatically. If not:</p> <ol> <li>Download a <code>.ttf</code> font (e.g., Roboto Mono)</li> <li>Load it manually:</li> </ol> <pre><code>protected override async Task OnLoadAsync(CancellationToken ct)\n{\n    var font = await _fontLoader.LoadFontAsync(\"path/to/font.ttf\", 16, ct);\n    _renderer.SetDefaultFont(font);\n}</code></pre>"},{"location":"getting-started/installation/#net-10-sdk-not-found","title":"\".NET 10 SDK not found\"","text":"<p>Solution:</p> <ol> <li>Download from dotnet.microsoft.com</li> <li>Install the SDK (not just the runtime)</li> <li>Restart your terminal/IDE</li> <li>Verify:</li> </ol> <pre><code>dotnet --version</code></pre>"},{"location":"getting-started/installation/#still-having-issues","title":"Still Having Issues?","text":"<ol> <li>Check GitHub Issues: github.com/CrazyPickleStudios/Brine2D/issues</li> <li>Ask in Discussions: github.com/CrazyPickleStudios/Brine2D/discussions</li> <li>Create an issue: Include:</li> <li>OS and version</li> <li>.NET SDK version</li> <li>Full error message</li> <li>Stack trace</li> </ol>"},{"location":"getting-started/installation/#platform-specific-notes","title":"Platform-Specific Notes","text":""},{"location":"getting-started/installation/#windows","title":"Windows","text":"<p>\u2705 Fully supported on Windows 10/11</p> <p>No additional setup required. SDL3 native libraries are included via NuGet.</p>"},{"location":"getting-started/installation/#linux","title":"Linux","text":"<p>\u26a0\ufe0f Should work but untested</p> <p>SDL3 supports Linux, but we haven't tested Brine2D there yet.</p> <p>If you try it:</p> <ol> <li>Install .NET 10 SDK: docs.microsoft.com/dotnet/core/install/linux</li> <li>Install SDL3 dependencies:</li> </ol> <pre><code># Ubuntu/Debian\nsudo apt-get install libsdl3-dev\n\n# Fedora\nsudo dnf install SDL3-devel</code></pre> <ol> <li>Let us know if it works! Open a discussion with your findings.</li> </ol>"},{"location":"getting-started/installation/#macos","title":"macOS","text":"<p>\u26a0\ufe0f Should work but untested</p> <p>SDL3 supports macOS, but we haven't tested Brine2D there yet.</p> <p>If you try it:</p> <ol> <li>Install .NET 10 SDK: docs.microsoft.com/dotnet/core/install/macos</li> <li>Install SDL3 via Homebrew:</li> </ol> <pre><code>brew install sdl3</code></pre> <ol> <li>Report your results! We'd love to hear from Mac users.</li> </ol>"},{"location":"getting-started/installation/#development-environment-setup","title":"Development Environment Setup","text":""},{"location":"getting-started/installation/#visual-studio-2022","title":"Visual Studio 2022","text":"<p>Recommended extensions:</p> <ul> <li>C# Dev Kit (built-in)</li> <li>GitHub Copilot (optional, but helpful)</li> <li>Hot Reload (built-in, works great!)</li> </ul> <p>Settings:</p> <ul> <li>Enable Just My Code for cleaner debugging</li> <li>Set Output Verbosity to <code>Normal</code> to see Brine2D logs</li> </ul>"},{"location":"getting-started/installation/#visual-studio-code","title":"Visual Studio Code","text":"<p>Required extensions:</p> <ol> <li>C# Dev Kit</li> <li>C#</li> </ol> <p>Recommended extensions:</p> <ul> <li>GitHub Copilot</li> <li>C# XML Documentation Comments</li> </ul> <p>Launch configuration (<code>.vscode/launch.json</code>):</p> <pre><code>{\n    \"version\": \"0.2.0\",\n    \"configurations\": [\n        {\n            \"name\": \".NET Launch\",\n            \"type\": \"coreclr\",\n            \"request\": \"launch\",\n            \"preLaunchTask\": \"build\",\n            \"program\": \"${workspaceFolder}/bin/Debug/net10.0/MyGame.dll\",\n            \"args\": [],\n            \"cwd\": \"${workspaceFolder}\",\n            \"console\": \"internalConsole\",\n            \"stopAtEntry\": false\n        }\n    ]\n}</code></pre>"},{"location":"getting-started/installation/#jetbrains-rider","title":"JetBrains Rider","text":"<p>Setup:</p> <ul> <li>Rider 2024.1+ recommended</li> <li>.NET 10 SDK detected automatically</li> <li>NuGet restore happens on project open</li> </ul> <p>Tips:</p> <ul> <li>Use Run/Debug Configurations for different scenes</li> <li>Enable Hot Reload for faster iteration</li> <li>Use Solution-Wide Analysis to catch issues early</li> </ul>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<p>Now that Brine2D is installed:</p> <ol> <li>Quick Start \u2192 - Build your first game in 5 minutes</li> <li>First Game \u2192 - Create a complete game with collision and scoring</li> <li>FeatureDemos \u2192 - Explore 6 interactive demos showcasing features</li> <li>Core Concepts \u2192 - Deep dive into Brine2D's architecture</li> </ol>"},{"location":"getting-started/installation/#keeping-brine2d-updated","title":"Keeping Brine2D Updated","text":""},{"location":"getting-started/installation/#check-for-updates","title":"Check for Updates","text":"<pre><code>dotnet list package --outdated</code></pre>"},{"location":"getting-started/installation/#update-to-latest-version","title":"Update to Latest Version","text":"<pre><code>dotnet add package Brine2D.Desktop</code></pre>"},{"location":"getting-started/installation/#pre-release-versions","title":"Pre-release Versions","text":"<p>To use the latest pre-release (alpha/beta):</p> <pre><code>dotnet add package Brine2D.Desktop --prerelease</code></pre>"},{"location":"getting-started/installation/#uninstalling","title":"Uninstalling","text":"<p>To remove Brine2D from a project:</p> <pre><code>dotnet remove package Brine2D.Desktop</code></pre> <p>Clean up build artifacts:</p> <pre><code>dotnet clean</code></pre> <p>\u2705 Installation complete! Ready to build your first game? Head to the Quick Start guide!</p>"},{"location":"getting-started/project-structure/","title":"Project Structure","text":"<p>Brine2D follows a clean, modular architecture inspired by ASP.NET Core's design principles. Each package has a single responsibility and depends only on what it needs.</p>"},{"location":"getting-started/project-structure/#architecture-overview","title":"Architecture Overview","text":"<pre><code>graph TB\n    Game[\"&lt;b&gt;Your Game Project&lt;/b&gt;&lt;br/&gt;&lt;i&gt;FeatureDemos.csproj&lt;/i&gt;\"]\n\n    subgraph Direct[\"Direct References\"]\n        Hosting[\"&lt;b&gt;Brine2D.Hosting&lt;/b&gt;\"]\n        RenderingSDL[\"&lt;b&gt;Brine2D.Rendering.SDL&lt;/b&gt;\"]\n        InputSDL[\"&lt;b&gt;Brine2D.Input.SDL&lt;/b&gt;\"]\n        AudioSDL[\"&lt;b&gt;Brine2D.Audio.SDL&lt;/b&gt;\"]\n        UI[\"&lt;b&gt;Brine2D.UI&lt;/b&gt;\"]\n    end\n\n    subgraph Transitive[\"Transitive Dependencies\"]\n        Engine[\"&lt;b&gt;Brine2D.Engine&lt;/b&gt;\"]\n        Rendering[\"&lt;b&gt;Brine2D.Rendering&lt;/b&gt;\"]\n        Input[\"&lt;b&gt;Brine2D.Input&lt;/b&gt;\"]\n        Audio[\"&lt;b&gt;Brine2D.Audio&lt;/b&gt;\"]\n        Core[\"&lt;b&gt;Brine2D.Core&lt;/b&gt;\"]\n    end\n\n    Game --&gt; Hosting\n    Game --&gt; RenderingSDL\n    Game --&gt; InputSDL\n    Game --&gt; AudioSDL\n    Game --&gt; UI\n\n    Hosting --&gt; Engine\n    Engine --&gt; Core\n\n    RenderingSDL --&gt; Rendering\n    InputSDL --&gt; Input\n    AudioSDL --&gt; Audio\n    UI --&gt; Core\n    UI --&gt; Rendering\n    UI --&gt; Input\n\n    Rendering --&gt; Core\n    Input --&gt; Core\n    Audio -.-&gt; Core\n\n    style Game fill:#264f78,stroke:#4fc1ff,stroke-width:3px,color:#fff\n    style Hosting fill:#1e3a5f,stroke:#569cd6,stroke-width:2px,color:#fff\n    style RenderingSDL fill:#4a2d4a,stroke:#c586c0,stroke-width:2px,color:#fff\n    style InputSDL fill:#4a2d4a,stroke:#c586c0,stroke-width:2px,color:#fff\n    style AudioSDL fill:#4a2d4a,stroke:#c586c0,stroke-width:2px,color:#fff\n    style UI fill:#4a3d1f,stroke:#ce9178,stroke-width:2px,color:#fff\n    style Engine fill:#2d5016,stroke:#4ec9b0,stroke-width:2px,color:#fff\n    style Rendering fill:#3d3d2a,stroke:#dcdcaa,stroke-width:2px,color:#fff\n    style Input fill:#3d3d2a,stroke:#dcdcaa,stroke-width:2px,color:#fff\n    style Audio fill:#3d3d2a,stroke:#dcdcaa,stroke-width:2px,color:#fff\n    style Core fill:#3d3d2a,stroke:#dcdcaa,stroke-width:2px,color:#fff\n    style Direct fill:#1a2332,stroke:#c586c0,stroke-width:2px,color:#fff\n    style Transitive fill:#1a2332,stroke:#4ec9b0,stroke-width:2px,color:#fff</code></pre> <p>This design follows the Dependency Inversion Principle: high-level modules (your game) depend on abstractions (interfaces), not concrete implementations.</p>"},{"location":"getting-started/project-structure/#core-packages","title":"Core Packages","text":""},{"location":"getting-started/project-structure/#brine2dcore","title":"Brine2D.Core","text":"<p>Purpose: Core abstractions and data structures used throughout the engine.</p> <p>Key Types:</p> <ul> <li><code>IScene</code> - Interface for game scenes</li> <li><code>Scene</code> - Base class with lifecycle methods</li> <li><code>GameTime</code> - Holds frame timing information</li> <li><code>IGameContext</code> - Access to game state and exit control</li> <li><code>Color</code>, <code>Rectangle</code>, <code>RectangleF</code> - Common data types</li> </ul> <p>Namespaces:</p> <ul> <li><code>Brine2D.Core</code> - Core interfaces and base classes</li> <li><code>Brine2D.Core.Animation</code> - Sprite animation system</li> <li><code>Brine2D.Core.Collision</code> - Collision detection</li> <li><code>Brine2D.Core.Tilemap</code> - Tilemap loading and rendering</li> </ul> <p>No Dependencies - This package is the foundation and doesn't depend on other Brine2D packages.</p> <pre><code>// Example: Implementing a custom scene\npublic class MyScene : Scene\n{\n    public MyScene(ILogger&lt;MyScene&gt; logger) : base(logger) { }\n\n    protected override void OnUpdate(GameTime gameTime) { }\n    protected override void OnRender(GameTime gameTime) { }\n}</code></pre>"},{"location":"getting-started/project-structure/#brine2dengine","title":"Brine2D.Engine","text":"<p>Purpose: Game loop, scene management, and engine coordination.</p> <p>Key Types:</p> <ul> <li><code>IGameEngine</code> - Core engine interface</li> <li><code>GameEngine</code> - Coordinates subsystems</li> <li><code>IGameLoop</code> - Game loop abstraction</li> <li><code>GameLoop</code> - Frame timing and update/render cycle</li> <li><code>ISceneManager</code> - Scene loading and transitions</li> <li><code>SceneManager</code> - Manages active scene</li> </ul> <p>Dependencies:</p> <ul> <li><code>Brine2D.Core</code></li> <li><code>Microsoft.Extensions.*</code> (DI, Logging, Configuration)</li> </ul> <pre><code>// The engine coordinates everything\nvar engine = serviceProvider.GetRequiredService&lt;IGameEngine&gt;();\nawait engine.InitializeAsync();\n\n// Scene manager handles scene transitions\nvar sceneManager = serviceProvider.GetRequiredService&lt;ISceneManager&gt;();\nawait sceneManager.LoadSceneAsync&lt;MenuScene&gt;();</code></pre>"},{"location":"getting-started/project-structure/#brine2dhosting","title":"Brine2D.Hosting","text":"<p>Purpose: ASP.NET-style application hosting and builder pattern.</p> <p>Key Types:</p> <ul> <li><code>GameApplication</code> - The main application host</li> <li><code>GameApplicationBuilder</code> - Fluent API for configuration</li> <li>Service registration extensions</li> </ul> <p>Dependencies:</p> <ul> <li><code>Brine2D.Core</code></li> <li><code>Brine2D.Engine</code></li> <li><code>Microsoft.Extensions.Hosting</code></li> </ul> <p>This is your entry point:</p> <pre><code>// Familiar ASP.NET-style builder\nvar builder = GameApplication.CreateBuilder(args);\n\n// Configure services\nbuilder.Services.AddSDL3Rendering();\nbuilder.Services.AddSDL3Input();\nbuilder.Services.AddScene&lt;GameScene&gt;();\n\n// Build and run\nvar game = builder.Build();\nawait game.RunAsync&lt;GameScene&gt;();</code></pre>"},{"location":"getting-started/project-structure/#rendering-system","title":"Rendering System","text":""},{"location":"getting-started/project-structure/#brine2drendering","title":"Brine2D.Rendering","text":"<p>Purpose: Rendering abstractions (interfaces and options).</p> <p>Key Types:</p> <ul> <li><code>IRenderer</code> - Core rendering interface</li> <li><code>ITexture</code> - Texture abstraction</li> <li><code>ITextureLoader</code> - Async texture loading</li> <li><code>IFont</code>, <code>IFontLoader</code> - Font rendering</li> <li><code>ICamera</code> - Camera abstraction</li> <li><code>Camera2D</code> - 2D camera implementation</li> <li><code>Color</code> - Color representation</li> <li><code>RenderingOptions</code> - Configuration</li> </ul> <p>Dependencies:</p> <ul> <li><code>Brine2D.Core</code></li> </ul> <pre><code>// All rendering goes through IRenderer\npublic class GameScene : Scene\n{\n    private readonly IRenderer _renderer;\n\n    protected override void OnRender(GameTime gameTime)\n    {\n        _renderer.Clear(Color.Black);\n        _renderer.BeginFrame();\n        _renderer.DrawTexture(texture, x, y);\n        _renderer.EndFrame();\n    }\n}</code></pre>"},{"location":"getting-started/project-structure/#brine2drenderingsdl","title":"Brine2D.Rendering.SDL","text":"<p>Purpose: SDL3-based rendering implementation.</p> <p>Key Types:</p> <ul> <li><code>SDL3Renderer</code> - Implements <code>IRenderer</code> using SDL3</li> <li><code>SDL3Texture</code> - SDL3 texture wrapper</li> <li><code>SDL3TextureLoader</code> - Loads textures via SDL3_image</li> <li><code>SDL3Font</code>, <code>SDL3FontLoader</code> - Font rendering via SDL3_ttf</li> <li>Service registration extensions</li> </ul> <p>Dependencies:</p> <ul> <li><code>Brine2D.Rendering</code></li> <li><code>SDL3-CS</code> (NuGet package - C# bindings for SDL3)</li> </ul> <p>Registration:</p> <pre><code>builder.Services.AddSDL3Rendering(options =&gt;\n{\n    options.WindowTitle = \"My Game\";\n    options.WindowWidth = 1280;\n    options.WindowHeight = 720;\n    options.VSync = true;\n    options.Backend = GraphicsBackend.GPU; // or Legacy\n});</code></pre>"},{"location":"getting-started/project-structure/#input-system","title":"Input System","text":""},{"location":"getting-started/project-structure/#brine2dinput","title":"Brine2D.Input","text":"<p>Purpose: Input abstractions for keyboard, mouse, and gamepad.</p> <p>Key Types:</p> <ul> <li><code>IInputService</code> - Unified input interface</li> <li><code>Keys</code> - Keyboard key enumeration</li> <li><code>MouseButton</code> - Mouse button enumeration</li> <li><code>GamepadButton</code>, <code>GamepadAxis</code> - Gamepad enums</li> <li><code>IInputLayer</code> - For layered input processing (like middleware)</li> <li><code>InputLayerManager</code> - Manages input layers</li> </ul> <p>Dependencies:</p> <ul> <li><code>Brine2D.Core</code></li> </ul> <pre><code>// Unified input API\nif (_input.IsKeyPressed(Keys.Space))\n{\n    Jump();\n}\n\nif (_input.IsMouseButtonDown(MouseButton.Left))\n{\n    Shoot();\n}\n\nvar stick = _input.GetGamepadLeftStick();</code></pre>"},{"location":"getting-started/project-structure/#brine2dinputsdl","title":"Brine2D.Input.SDL","text":"<p>Purpose: SDL3-based input implementation.</p> <p>Key Types:</p> <ul> <li><code>SDL3InputService</code> - Implements <code>IInputService</code></li> <li>Service registration extensions</li> </ul> <p>Dependencies:</p> <ul> <li><code>Brine2D.Input</code></li> <li><code>SDL3-CS</code></li> </ul> <p>Registration:</p> <pre><code>builder.Services.AddSDL3Input();</code></pre>"},{"location":"getting-started/project-structure/#audio-system","title":"Audio System","text":""},{"location":"getting-started/project-structure/#brine2daudio","title":"Brine2D.Audio","text":"<p>Purpose: Audio abstractions for sound effects and music.</p> <p>Key Types:</p> <ul> <li><code>IAudioService</code> - Audio playback interface</li> <li><code>ISoundEffect</code> - Short sound effect</li> <li><code>IMusic</code> - Background music</li> </ul> <p>Dependencies:</p> <ul> <li>None (pure abstractions)</li> </ul> <pre><code>// Simple audio API\nvar jumpSound = await _audio.LoadSoundAsync(\"jump.wav\");\n_audio.PlaySound(jumpSound);\n\nvar bgMusic = await _audio.LoadMusicAsync(\"theme.mp3\");\n_audio.PlayMusic(bgMusic, loops: -1); // Loop forever</code></pre>"},{"location":"getting-started/project-structure/#brine2daudiosdl","title":"Brine2D.Audio.SDL","text":"<p>Purpose: SDL3_mixer-based audio implementation.</p> <p>Key Types:</p> <ul> <li><code>SDL3AudioService</code> - Implements <code>IAudioService</code></li> <li><code>SDL3SoundEffect</code>, <code>SDL3Music</code> - SDL3 wrappers</li> <li>Service registration extensions</li> </ul> <p>Dependencies:</p> <ul> <li><code>Brine2D.Audio</code></li> <li><code>SDL3-CS</code> (includes SDL3_mixer bindings)</li> </ul> <p>Registration:</p> <pre><code>builder.Services.AddSDL3Audio();</code></pre>"},{"location":"getting-started/project-structure/#ui-system","title":"UI System","text":""},{"location":"getting-started/project-structure/#brine2dui","title":"Brine2D.UI","text":"<p>Purpose: Immediate-mode UI framework.</p> <p>Key Types:</p> <ul> <li><code>UICanvas</code> - Container for UI components</li> <li><code>UIButton</code>, <code>UILabel</code>, <code>UISlider</code> - Basic components</li> <li><code>UITextInput</code>, <code>UICheckbox</code>, <code>UIDropdown</code> - Form controls</li> <li><code>UIDialog</code>, <code>UITooltip</code> - Advanced components</li> <li><code>UIPanel</code>, <code>UIScrollView</code> - Layout containers</li> <li><code>IUIComponent</code> - Interface for custom UI</li> </ul> <p>Dependencies:</p> <ul> <li><code>Brine2D.Core</code></li> <li><code>Brine2D.Rendering</code></li> <li><code>Brine2D.Input</code></li> </ul> <pre><code>// Add UI canvas to your scene\nprivate readonly UICanvas _uiCanvas;\n\nvar button = new UIButton(\"Click Me\", new Vector2(10, 10), new Vector2(100, 30));\nbutton.OnClick += () =&gt; Logger.LogInformation(\"Clicked!\");\n_uiCanvas.Add(button);\n\n// Update and render\n_uiCanvas.Update(deltaTime);\n_uiCanvas.Render(_renderer);</code></pre>"},{"location":"getting-started/project-structure/#optional-packages","title":"Optional Packages","text":""},{"location":"getting-started/project-structure/#brine2dcoreanimation","title":"Brine2D.Core.Animation","text":"<p>Included in: <code>Brine2D.Core</code></p> <p>Purpose: Sprite animation system.</p> <p>Key Types:</p> <ul> <li><code>SpriteAnimator</code> - Plays animation clips</li> <li><code>AnimationClip</code> - Sequence of frames</li> <li><code>SpriteFrame</code> - Single frame with duration</li> </ul> <pre><code>var animator = new SpriteAnimator();\nvar walkAnim = AnimationClip.FromSpriteSheet(\"walk\", 32, 32, 8, columns: 10);\nanimator.AddAnimation(walkAnim);\nanimator.Play(\"walk\");</code></pre>"},{"location":"getting-started/project-structure/#brine2dcorecollision","title":"Brine2D.Core.Collision","text":"<p>Included in: <code>Brine2D.Core</code></p> <p>Purpose: Collision detection system.</p> <p>Key Types:</p> <ul> <li><code>CollisionSystem</code> - Manages collision checks</li> <li><code>CollisionShape</code> - Base for all colliders</li> <li><code>BoxCollider</code>, <code>CircleCollider</code> - Shape types</li> <li><code>RectangleF</code> - Floating-point rectangle</li> <li><code>CollisionResponse</code> - Helper methods for collision resolution</li> </ul> <pre><code>var collisionSystem = new CollisionSystem();\nvar playerCollider = new BoxCollider(32, 32);\ncollisionSystem.AddShape(playerCollider);\n\nvar collisions = collisionSystem.GetCollisions(playerCollider);</code></pre>"},{"location":"getting-started/project-structure/#brine2dcoretilemap","title":"Brine2D.Core.Tilemap","text":"<p>Included in: <code>Brine2D.Core</code></p> <p>Purpose: Tilemap loading and rendering (Tiled format).</p> <p>Key Types:</p> <ul> <li><code>Tilemap</code> - Loaded tilemap data</li> <li><code>ITilemapLoader</code> - Loads <code>.tmj</code> files</li> <li><code>TilemapRenderer</code> - Renders tilemaps</li> </ul> <p>Supports:</p> <ul> <li>Tiled Editor <code>.tmj</code> format</li> <li>Multiple layers</li> <li>Automatic collision generation</li> </ul> <pre><code>var tilemap = await _tilemapLoader.LoadAsync(\"level1.tmj\");\nawait _tilemapRenderer.LoadTilesetAsync(tilemap, _textureLoader);\n_tilemapRenderer.Render(tilemap, _renderer, _camera);\n\n// Generate collision from tilemap\nvar colliders = tilemap.GenerateColliders(\"collision\");</code></pre>"},{"location":"getting-started/project-structure/#dependency-flow","title":"Dependency Flow","text":"<p>Understanding how packages depend on each other:</p> <pre><code>Your Game\n    \u2193 references\nBrine2D.Hosting\n    \u2193 uses\nBrine2D.Engine + Brine2D.Core\n    \u2193 abstractions\nBrine2D.Rendering \u2190 Brine2D.Rendering.SDL (implementation)\nBrine2D.Input \u2190 Brine2D.Input.SDL (implementation)\nBrine2D.Audio \u2190 Brine2D.Audio.SDL (implementation)</code></pre> <p>Key insight: Your game references abstractions (interfaces), and the hosting layer wires up concrete implementations via dependency injection.</p>"},{"location":"getting-started/project-structure/#directory-structure","title":"Directory Structure","text":"<pre><code>Brine2D/\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 Brine2D.Core/\n\u2502   \u2502   \u251c\u2500\u2500 Scene.cs, IScene.cs\n\u2502   \u2502   \u251c\u2500\u2500 GameTime.cs, IGameContext.cs\n\u2502   \u2502   \u251c\u2500\u2500 Animation/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 SpriteAnimator.cs\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 AnimationClip.cs\n\u2502   \u2502   \u251c\u2500\u2500 Collision/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 CollisionSystem.cs\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 CollisionShape.cs\n\u2502   \u2502   \u2514\u2500\u2500 Tilemap/\n\u2502   \u2502       \u251c\u2500\u2500 Tilemap.cs\n\u2502   \u2502       \u2514\u2500\u2500 TilemapLoader.cs\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 Brine2D.Engine/\n\u2502   \u2502   \u251c\u2500\u2500 GameEngine.cs\n\u2502   \u2502   \u251c\u2500\u2500 GameLoop.cs\n\u2502   \u2502   \u2514\u2500\u2500 SceneManager.cs\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 Brine2D.Hosting/\n\u2502   \u2502   \u251c\u2500\u2500 GameApplication.cs\n\u2502   \u2502   \u2514\u2500\u2500 GameApplicationBuilder.cs\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 Brine2D.Rendering/\n\u2502   \u2502   \u251c\u2500\u2500 IRenderer.cs\n\u2502   \u2502   \u251c\u2500\u2500 ITexture.cs, ITextureLoader.cs\n\u2502   \u2502   \u251c\u2500\u2500 IFont.cs, IFontLoader.cs\n\u2502   \u2502   \u251c\u2500\u2500 ICamera.cs, Camera2D.cs\n\u2502   \u2502   \u251c\u2500\u2500 Color.cs\n\u2502   \u2502   \u2514\u2500\u2500 RenderingOptions.cs\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 Brine2D.Rendering.SDL/\n\u2502   \u2502   \u251c\u2500\u2500 SDL3Renderer.cs\n\u2502   \u2502   \u251c\u2500\u2500 SDL3Texture.cs, SDL3TextureLoader.cs\n\u2502   \u2502   \u2514\u2500\u2500 SDL3Font.cs, SDL3FontLoader.cs\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 Brine2D.Input/\n\u2502   \u2502   \u251c\u2500\u2500 IInputService.cs\n\u2502   \u2502   \u251c\u2500\u2500 Keys.cs, MouseButton.cs\n\u2502   \u2502   \u251c\u2500\u2500 GamepadButton.cs, GamepadAxis.cs\n\u2502   \u2502   \u2514\u2500\u2500 IInputLayer.cs, InputLayerManager.cs\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 Brine2D.Input.SDL/\n\u2502   \u2502   \u2514\u2500\u2500 SDL3InputService.cs\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 Brine2D.Audio/\n\u2502   \u2502   \u251c\u2500\u2500 IAudioService.cs\n\u2502   \u2502   \u251c\u2500\u2500 ISoundEffect.cs\n\u2502   \u2502   \u2514\u2500\u2500 IMusic.cs\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 Brine2D.Audio.SDL/\n\u2502   \u2502   \u251c\u2500\u2500 SDL3AudioService.cs\n\u2502   \u2502   \u251c\u2500\u2500 SDL3SoundEffect.cs\n\u2502   \u2502   \u2514\u2500\u2500 SDL3Music.cs\n\u2502   \u2502\n\u2502   \u2514\u2500\u2500 Brine2D.UI/\n\u2502       \u251c\u2500\u2500 UICanvas.cs\n\u2502       \u251c\u2500\u2500 IUIComponent.cs\n\u2502       \u251c\u2500\u2500 UIButton.cs, UILabel.cs\n\u2502       \u251c\u2500\u2500 UISlider.cs, UITextInput.cs\n\u2502       \u2514\u2500\u2500 UIDialog.cs, UITooltip.cs\n\u2502\n\u251c\u2500\u2500 samples/\n\u2502   \u251c\u2500\u2500 FeatureDemos/\n\u2502   \u251c\u2500\u2500 PlatformerGame/\n\u2502   \u2514\u2500\u2500 AdvancedGame/\n\u2502\n\u2514\u2500\u2500 tests/\n    \u251c\u2500\u2500 Brine2D.Core.Tests/\n    \u251c\u2500\u2500 Brine2D.Engine.Tests/\n    \u2514\u2500\u2500 ...</code></pre>"},{"location":"getting-started/project-structure/#design-principles","title":"Design Principles","text":"<p>Brine2D's architecture follows these key principles:</p>"},{"location":"getting-started/project-structure/#1-dependency-inversion","title":"1. Dependency Inversion","text":"<p>High-level modules (your game) depend on abstractions (<code>IRenderer</code>), not implementations (<code>SDL3Renderer</code>).</p>"},{"location":"getting-started/project-structure/#2-single-responsibility","title":"2. Single Responsibility","text":"<p>Each package has one job:</p> <ul> <li><code>Core</code> = abstractions</li> <li><code>Engine</code> = game loop</li> <li><code>Rendering</code> = draw things</li> <li><code>Input</code> = handle input</li> <li>etc.</li> </ul>"},{"location":"getting-started/project-structure/#3-openclosed","title":"3. Open/Closed","text":"<p>Open for extension (implement <code>IRenderer</code> with DirectX, Metal, etc.), closed for modification (core interfaces rarely change).</p>"},{"location":"getting-started/project-structure/#4-dependency-injection","title":"4. Dependency Injection","text":"<p>Everything is resolved via DI container\u2014testable, mockable, swappable.</p>"},{"location":"getting-started/project-structure/#5-configuration-over-code","title":"5. Configuration Over Code","text":"<p>Prefer <code>gamesettings.json</code> over hardcoded values.</p>"},{"location":"getting-started/project-structure/#extending-brine2d","title":"Extending Brine2D","text":""},{"location":"getting-started/project-structure/#add-a-custom-renderer","title":"Add a Custom Renderer","text":"<pre><code>// 1. Implement IRenderer\npublic class MyCustomRenderer : IRenderer\n{\n    public void DrawTexture(ITexture texture, float x, float y) { ... }\n    // ... implement all methods\n}\n\n// 2. Register it\nbuilder.Services.AddSingleton&lt;IRenderer, MyCustomRenderer&gt;();</code></pre>"},{"location":"getting-started/project-structure/#add-a-custom-input-provider","title":"Add a Custom Input Provider","text":"<pre><code>// 1. Implement IInputService\npublic class MyInputService : IInputService\n{\n    public bool IsKeyDown(Keys key) { ... }\n    // ... implement all methods\n}\n\n// 2. Register it\nbuilder.Services.AddSingleton&lt;IInputService, MyInputService&gt;();</code></pre>"},{"location":"getting-started/project-structure/#create-custom-ui-components","title":"Create Custom UI Components","text":"<pre><code>public class MyCustomWidget : IUIComponent\n{\n    public Vector2 Position { get; set; }\n    public Vector2 Size { get; set; }\n    public bool Visible { get; set; } = true;\n    public bool Enabled { get; set; } = true;\n    public UITooltip? Tooltip { get; set; }\n\n    public void Update(float deltaTime) { }\n    public void Render(IRenderer renderer) { }\n    public bool Contains(Vector2 screenPosition) { return false; }\n}</code></pre>"},{"location":"getting-started/project-structure/#best-practices","title":"Best Practices","text":""},{"location":"getting-started/project-structure/#do-depend-on-interfaces","title":"DO: Depend on Interfaces","text":"<pre><code>// Good\nprivate readonly IRenderer _renderer;\n\n// Bad\nprivate readonly SDL3Renderer _renderer;</code></pre>"},{"location":"getting-started/project-structure/#do-use-constructor-injection","title":"DO: Use Constructor Injection","text":"<pre><code>public MyScene(IRenderer renderer, IInputService input, ILogger&lt;MyScene&gt; logger)\n    : base(logger)\n{\n    _renderer = renderer;\n    _input = input;\n}</code></pre>"},{"location":"getting-started/project-structure/#do-keep-scenes-focused","title":"DO: Keep Scenes Focused","text":"<p>Each scene should represent one game state (Menu, Gameplay, GameOver, etc.).</p>"},{"location":"getting-started/project-structure/#do-use-async-for-loading","title":"DO: Use Async for Loading","text":"<pre><code>protected override async Task OnLoadAsync(CancellationToken cancellationToken)\n{\n    _texture = await _textureLoader.LoadTextureAsync(\"sprite.png\", cancellationToken);\n}</code></pre>"},{"location":"getting-started/project-structure/#dont-directly-reference-sdl3","title":"DON'T: Directly Reference SDL3","text":"<p>Let the SDL implementations handle SDL\u2014your game should only use Brine2D abstractions.</p>"},{"location":"getting-started/project-structure/#dont-use-static-state","title":"DON'T: Use Static State","text":"<p>Use DI instead of singletons or static classes.</p>"},{"location":"getting-started/project-structure/#next-steps","title":"Next Steps","text":"<ul> <li>Configuration - Learn about <code>gamesettings.json</code> and options</li> <li>Core Concepts - Deep dive into architecture</li> <li>Scene Management - Understanding scene lifecycle</li> <li>Dependency Injection - How DI works in Brine2D</li> </ul> <p>Understanding Brine2D's structure makes it easy to navigate, extend, and maintain. The modular design means you can swap out any piece\u2014just like ASP.NET!</p>"},{"location":"getting-started/quickstart/","title":"Quick Start Guide","text":"<p>Get your first Brine2D game running in less than 5 minutes. If you're familiar with ASP.NET Core, you'll feel right at home.</p>"},{"location":"getting-started/quickstart/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, make sure you have:</p> <ul> <li>.NET 10 SDK or later</li> <li>A code editor (Visual Studio 2022, VS Code, or Rider recommended)</li> <li>Basic C# knowledge</li> </ul>"},{"location":"getting-started/quickstart/#step-1-create-your-game-project","title":"Step 1: Create Your Game Project","text":"<p>Create a new console application:</p> <pre><code>dotnet new console -n MyFirstGame\ncd MyFirstGame</code></pre> <p>This creates a basic .NET 10 console application with a <code>Program.cs</code> file.</p>"},{"location":"getting-started/quickstart/#step-2-add-brine2d-package","title":"Step 2: Add Brine2D Package","text":"<p>Add the Brine2D.Desktop NuGet package, which includes everything you need:</p> <pre><code>dotnet add package Brine2D.Desktop</code></pre> <p>What's Included?</p> <p><code>Brine2D.Desktop</code> is a meta-package that includes:</p> <ul> <li>Brine2D.Core - Core abstractions and types</li> <li>Brine2D.Engine - Game loop, scene management, and transitions</li> <li>Brine2D.Hosting - ASP.NET-style hosting and DI</li> <li>Brine2D.ECS - Entity Component System</li> <li>Brine2D.Rendering.SDL - SDL3-based rendering</li> <li>Brine2D.Input.SDL - SDL3-based input handling</li> <li>Brine2D.Audio.SDL - SDL3-based audio system</li> <li>Brine2D.UI - Complete UI component library</li> </ul> <p>Everything needed for a complete desktop game!</p>"},{"location":"getting-started/quickstart/#step-3-write-your-first-game","title":"Step 3: Write Your First Game","text":"<p>Replace the contents of <code>Program.cs</code> with this code:</p> <pre><code>using Brine2D.Core;\nusing Brine2D.Hosting;\nusing Brine2D.Input;\nusing Brine2D.Input.SDL;\nusing Brine2D.Rendering;\nusing Brine2D.Rendering.SDL;\nusing Microsoft.Extensions.Logging;\n\n// Create builder (like ASP.NET's WebApplication.CreateBuilder)\nvar builder = GameApplication.CreateBuilder(args);\n\n// Configure services\nbuilder.Services.AddSDL3Rendering(options =&gt;\n{\n    options.WindowTitle = \"My First Game\";\n    options.WindowWidth = 1280;\n    options.WindowHeight = 720;\n});\n\nbuilder.Services.AddSDL3Input();\nbuilder.Services.AddScene&lt;GameScene&gt;();\n\n// Build and run\nvar game = builder.Build();\n\nawait game.RunAsync&lt;GameScene&gt;();\n\n// Define your scene (like an ASP.NET controller)\npublic class GameScene : Scene\n{\n    private readonly IGameContext _gameContext;\n    private readonly IInputService _input;\n    private readonly IRenderer _renderer;\n\n    public GameScene(\n        IRenderer renderer,\n        IInputService input,\n        IGameContext gameContext,\n        ILogger&lt;GameScene&gt; logger\n    ) : base(logger)\n    {\n        _renderer = renderer;\n        _input = input;\n        _gameContext = gameContext;\n    }\n\n    protected override void OnRender(GameTime gameTime)\n    {\n        // Frame management happens automatically!\n        _renderer.DrawText(\"Hello, Brine2D!\", 100, 100, Color.White);\n    }\n\n    protected override void OnUpdate(GameTime gameTime)\n    {\n        if (_input.IsKeyPressed(Keys.Escape))\n        {\n            _gameContext.RequestExit();\n        }\n    }\n}</code></pre> <p>!!! tip Automatic Frame Management\"     Notice we don't call <code>Clear()</code>, <code>BeginFrame()</code>, or <code>EndFrame()</code> - the framework handles this automatically via lifecycle hooks! Just focus on your game logic.</p>"},{"location":"getting-started/quickstart/#step-4-run-your-game","title":"Step 4: Run Your Game","text":"<p>Build and run your game:</p> <pre><code>dotnet run</code></pre> <p>You should see a window with \"Hello, Brine2D!\" displayed. Press Escape to exit.</p> <p>Congratulations! You've created your first Brine2D game!</p>"},{"location":"getting-started/quickstart/#understanding-what-you-just-built","title":"Understanding What You Just Built","text":"<p>Let's break down the key concepts:</p>"},{"location":"getting-started/quickstart/#the-builder-pattern","title":"The Builder Pattern","text":"<pre><code>var builder = GameApplication.CreateBuilder(args);</code></pre> <p>Just like ASP.NET's <code>WebApplication.CreateBuilder()</code>, this sets up your game with sensible defaults. It:</p> <ul> <li>Configures dependency injection</li> <li>Sets up logging</li> <li>Loads configuration from <code>gamesettings.json</code> (if present)</li> <li>Registers core engine services</li> <li>NEW: Configures automatic system execution via lifecycle hooks</li> </ul>"},{"location":"getting-started/quickstart/#service-registration","title":"Service Registration","text":"<pre><code>builder.Services.AddSDL3Rendering(options =&gt; { ... });\nbuilder.Services.AddSDL3Input();\nbuilder.Services.AddScene&lt;GameScene&gt;();</code></pre> <p>This should look familiar if you've used ASP.NET:</p> <ul> <li><code>AddSDL3Rendering()</code> - Registers the rendering system (like <code>AddControllers()</code>)</li> <li><code>AddSDL3Input()</code> - Registers input handling</li> <li><code>AddScene&lt;T&gt;()</code> - Registers your scene (like registering a controller)</li> </ul>"},{"location":"getting-started/quickstart/#scenes-are-like-controllers","title":"Scenes Are Like Controllers","text":"<pre><code>public class GameScene : Scene\n{\n    public GameScene(IRenderer renderer, IInputService input, ILogger&lt;GameScene&gt; logger) \n        : base(logger)\n    {\n        // Constructor injection!\n    }\n}</code></pre> <p>Scenes organize your game logic just like controllers organize your web endpoints. They:</p> <ul> <li>Get dependencies injected via constructor</li> <li>Have lifecycle methods (<code>OnInitialize</code>, <code>OnLoad</code>, <code>OnUpdate</code>, <code>OnRender</code>, <code>OnUnload</code>)</li> <li>Can be swapped at runtime with scene transitions</li> <li>NEW: Automatically execute systems and manage rendering</li> </ul>"},{"location":"getting-started/quickstart/#lifecycle-methods","title":"Lifecycle Methods","text":"<p>Your scene has these key methods:</p> <ul> <li><code>OnUpdate(GameTime)</code> - Called every frame for game logic</li> <li><code>OnRender(GameTime)</code> - Called every frame for drawing</li> <li><code>OnLoadAsync()</code> - Called once when the scene loads (for async loading)</li> <li><code>OnUnloadAsync()</code> - Called when the scene unloads</li> </ul> <p>Frame management (<code>Clear</code>, <code>BeginFrame</code>, <code>EndFrame</code>) happens automatically unless you opt-out!</p>"},{"location":"getting-started/quickstart/#next-steps","title":"Next Steps","text":"<p>Now that you have a working game, here's what to explore next:</p>"},{"location":"getting-started/quickstart/#add-some-movement","title":"Add Some Movement","text":"<p>Modify your <code>GameScene</code> to move text with arrow keys:</p> <pre><code>public class GameScene : Scene\n{\n    private readonly IGameContext _gameContext;\n    private readonly IInputService _input;\n    private readonly IRenderer _renderer;\n    private readonly float _speed = 200f; // pixels per second\n\n    private float _x = 100;\n    private float _y = 100;\n\n    protected override void OnRender(GameTime gameTime)\n    {\n        // Just draw - frame management is automatic!\n        _renderer.DrawText(\"Hello, Brine2D!\", _x, _y, Color.White);\n    }\n\n    // ... constructor ...\n\n    protected override void OnUpdate(GameTime gameTime)\n    {\n        var deltaTime = (float)gameTime.DeltaTime;\n\n        // Move with arrow keys\n        if (_input.IsKeyDown(Keys.Left))\n            _x -= _speed * deltaTime;\n\n        if (_input.IsKeyDown(Keys.Right))\n            _x += _speed * deltaTime;\n\n        if (_input.IsKeyDown(Keys.Up))\n            _y -= _speed * deltaTime;\n\n        if (_input.IsKeyDown(Keys.Down))\n            _y += _speed * deltaTime;\n\n        if (_input.IsKeyPressed(Keys.Escape))\n            _gameContext.RequestExit();\n    }\n}</code></pre> <p>Run it again and use the arrow keys to move the text!</p>"},{"location":"getting-started/quickstart/#add-shapes-and-lines","title":"Add Shapes and Lines","text":"<p>Draw simple shapes:</p> <pre><code>protected override void OnRender(GameTime gameTime)\n{\n    // Draw a white rectangle\n    _renderer.DrawRectangleFilled(200, 200, 100, 100, Color.White);\n\n    // Draw a circle\n    _renderer.DrawCircleFilled(400, 300, 50, Color.Red);\n\n    // Draw a line\n    _renderer.DrawLine(100, 100, 300, 200, Color.Yellow, 2f);\n\n    _renderer.DrawText(\"Hello, Brine2D!\", _x, _y, Color.White);\n}</code></pre>"},{"location":"getting-started/quickstart/#add-scene-transitions","title":"Add Scene Transitions","text":"<p>Create multiple scenes and transition between them:</p> <pre><code>using Brine2D.Engine;\nusing Brine2D.Engine.Transitions;\n\npublic class MenuScene : Scene\n{\n    private readonly ISceneManager _sceneManager;\n\n    protected override async void OnUpdate(GameTime gameTime)\n    {\n        if (_input.IsKeyPressed(Keys.Enter))\n        {\n            // Fade to game scene\n            await _sceneManager.LoadSceneAsync&lt;GameScene&gt;(\n                new FadeTransition(duration: 0.5f, color: Color.Black)\n            );\n        }\n    }\n}</code></pre>"},{"location":"getting-started/quickstart/#optional-add-configuration","title":"Optional: Add Configuration","text":"<p>Create a <code>gamesettings.json</code> file in your project:</p> <pre><code>{\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Information\",\n      \"Brine2D\": \"Debug\"\n    }\n  },\n  \"Rendering\": {\n    \"WindowTitle\": \"My First Game\",\n    \"WindowWidth\": 1280,\n    \"WindowHeight\": 720,\n    \"VSync\": true,\n    \"Fullscreen\": false,\n    \"Backend\": \"GPU\",\n    \"PreferredGPUDriver\": \"Vulkan\"\n  }\n}</code></pre> <p>Then simplify your rendering configuration:</p> <pre><code>builder.Services.AddSDL3Rendering(options =&gt;\n{\n    builder.Configuration.GetSection(\"Rendering\").Bind(options);\n});</code></pre> <p>Make sure to set the file to copy to the output directory in your <code>.csproj</code>:</p> <pre><code>&lt;ItemGroup&gt;\n  &lt;None Update=\"gamesettings.json\"&gt;\n    &lt;CopyToOutputDirectory&gt;PreserveNewest&lt;/CopyToOutputDirectory&gt;\n  &lt;/None&gt;\n&lt;/ItemGroup&gt;</code></pre>"},{"location":"getting-started/quickstart/#common-issues","title":"Common Issues","text":""},{"location":"getting-started/quickstart/#sdl3-native-library-not-found","title":"SDL3 Native Library Not Found","text":"<p>If you get an error about SDL3 libraries not being found, make sure:</p> <ol> <li>The SDL3-CS NuGet package is properly restored (<code>dotnet restore</code>)</li> <li>You're running on a supported platform (Windows, macOS, Linux)</li> <li>Try cleaning and rebuilding: <code>dotnet clean &amp;&amp; dotnet build</code></li> </ol>"},{"location":"getting-started/quickstart/#window-doesnt-appear","title":"Window Doesn't Appear","text":"<p>If the window doesn't show up:</p> <ol> <li>Check that <code>RunAsync&lt;GameScene&gt;()</code> is being called</li> <li>Make sure you're calling <code>await</code> on <code>RunAsync</code></li> <li>Check the console for error messages</li> </ol>"},{"location":"getting-started/quickstart/#text-doesnt-render","title":"Text Doesn't Render","text":"<p>The text rendering uses an embedded font by default. If text doesn't appear:</p> <ol> <li>Check that SDL3_ttf is loaded (should be automatic)</li> <li>Try using a custom font (see the Text Rendering guide)</li> <li>Check console logs for font loading errors</li> </ol>"},{"location":"getting-started/quickstart/#development-from-source","title":"Development from Source","text":"<p>If you want to contribute to Brine2D or use the latest development version, you can reference the projects directly instead:</p> <pre><code>git clone https://github.com/CrazyPickleStudios/Brine2D.git\ncd Brine2D\ndotnet build</code></pre> <p>Then in your game project, replace the NuGet package with project references:</p> <pre><code>dotnet remove package Brine2D.Desktop\ndotnet add reference ../Brine2D/src/Brine2D.Core/Brine2D.Core.csproj\ndotnet add reference ../Brine2D/src/Brine2D.Engine/Brine2D.Engine.csproj\ndotnet add reference ../Brine2D/src/Brine2D.Hosting/Brine2D.Hosting.csproj\ndotnet add reference ../Brine2D/src/Brine2D.Rendering/Brine2D.Rendering.csproj\ndotnet add reference ../Brine2D/src/Brine2D.Rendering.SDL/Brine2D.Rendering.SDL.csproj\ndotnet add reference ../Brine2D/src/Brine2D.Input/Brine2D.Input.csproj\ndotnet add reference ../Brine2D/src/Brine2D.Input.SDL/Brine2D.Input.SDL.csproj\ndotnet add reference ../Brine2D/src/Brine2D.ECS/Brine2D.ECS.csproj</code></pre>"},{"location":"getting-started/quickstart/#learn-more","title":"Learn More","text":"<ul> <li> <p> Core Concepts</p> <p>Deep dive into Brine2D's architecture</p> <p> Read Concepts</p> </li> <li> <p> Sprites &amp; Textures</p> <p>Learn to load and render images</p> <p> Sprite Guide</p> </li> <li> <p> Scene Transitions</p> <p>Smooth transitions between scenes</p> <p> Transitions Guide</p> </li> <li> <p> Input Handling</p> <p>Complete guide to keyboard, mouse, and gamepad</p> <p> Input Guide</p> </li> </ul>"},{"location":"getting-started/quickstart/#what-youve-learned","title":"What You've Learned","text":"<p>\u2705 How to set up a Brine2D project with NuGet \u2705 The builder pattern and service registration \u2705 Creating scenes with dependency injection \u2705 The basic game loop (update and render) \u2705 Handling input with <code>IInputService</code> \u2705 Drawing shapes, lines, and text \u2705 NEW: Automatic frame management via lifecycle hooks \u2705 NEW: Scene transitions  </p> <p>You're ready to build real games! Check out the FeatureDemos to see advanced examples, or dive into the guides to learn about sprites, animations, collision detection, ECS, and more.</p>"},{"location":"guides/","title":"Guides Overview","text":"<p>Welcome to the Brine2D Guides! These practical, task-focused tutorials will help you build real game features step-by-step.</p>"},{"location":"guides/#what-youll-learn","title":"What You'll Learn","text":"<p>Guides are organized by feature area, each with complete working examples you can copy and adapt for your games.</p>"},{"location":"guides/#guide-categories","title":"Guide Categories","text":""},{"location":"guides/#getting-started","title":"Getting Started","text":"Guide Description Difficulty Quick Start Create your first game in 5 minutes \u2b50 Beginner Project Structure Organize your game project \u2b50 Beginner Configuration Set up game settings and options \u2b50 Beginner"},{"location":"guides/#input-handling","title":"Input Handling","text":"Guide Description Difficulty Keyboard Input Handle keyboard controls \u2b50 Beginner Mouse Input Implement mouse interaction \u2b50 Beginner Gamepad Support Add controller support \u2b50\u2b50 Intermediate Input Layers Priority-based input routing \u2b50\u2b50 Intermediate Text Input Handle text fields and chat \u2b50\u2b50 Intermediate"},{"location":"guides/#rendering-graphics","title":"Rendering &amp; Graphics","text":"Guide Description Difficulty Drawing Basics Shapes, colors, and primitives \u2b50 Beginner Loading Textures Load and display images \u2b50 Beginner Sprite Rendering Draw sprites and sprite sheets \u2b50 Beginner Animation Create sprite animations \u2b50\u2b50 Intermediate Camera System Implement camera movement \u2b50\u2b50 Intermediate Text Rendering Display text and fonts \u2b50 Beginner Particle Effects Add visual effects \u2b50\u2b50\u2b50 Advanced"},{"location":"guides/#audio-sound","title":"Audio &amp; Sound","text":"Guide Description Difficulty Sound Effects Play sounds (jump, shoot, etc.) \u2b50 Beginner Background Music Add looping music \u2b50 Beginner Audio Mixing Control volume and balance \u2b50\u2b50 Intermediate 3D Audio Position-based sound \u2b50\u2b50\u2b50 Advanced"},{"location":"guides/#collision-detection","title":"Collision Detection","text":"Guide Description Difficulty Basic Collision Rectangle and circle collision \u2b50 Beginner Collision Response Bounce, slide, and push \u2b50\u2b50 Intermediate Collision Layers Selective collision filtering \u2b50\u2b50 Intermediate Spatial Partitioning Optimize collision detection \u2b50\u2b50\u2b50 Advanced"},{"location":"guides/#tilemaps-levels","title":"Tilemaps &amp; Levels","text":"Guide Description Difficulty Tiled Integration Load Tiled JSON maps \u2b50\u2b50 Intermediate Tilemap Rendering Efficient tilemap drawing \u2b50\u2b50 Intermediate Tilemap Collision Tile-based collision \u2b50\u2b50 Intermediate Layer Management Background, foreground layers \u2b50\u2b50 Intermediate"},{"location":"guides/#ui-menus","title":"UI &amp; Menus","text":"Guide Description Difficulty Buttons Create clickable buttons \u2b50 Beginner Labels &amp; Text Display UI text \u2b50 Beginner Sliders Volume and setting sliders \u2b50\u2b50 Intermediate Text Input Name entry, chat boxes \u2b50\u2b50 Intermediate Dialogs Modal popup windows \u2b50\u2b50 Intermediate Menus Main menu, pause menu \u2b50\u2b50 Intermediate HUD Health bars, score display \u2b50 Beginner"},{"location":"guides/#game-mechanics","title":"Game Mechanics","text":"Guide Description Difficulty Player Movement WASD, 8-direction, smooth \u2b50 Beginner Jump &amp; Gravity Platformer physics \u2b50\u2b50 Intermediate Shooting Projectile system \u2b50\u2b50 Intermediate Enemy AI Simple enemy behavior \u2b50\u2b50 Intermediate Health System Damage and death \u2b50 Beginner Inventory Item management \u2b50\u2b50\u2b50 Advanced Save/Load Game state persistence \u2b50\u2b50\u2b50 Advanced"},{"location":"guides/#architecture-patterns","title":"Architecture &amp; Patterns","text":"Guide Description Difficulty Component System Entity-component pattern \u2b50\u2b50\u2b50 Advanced State Machines Manage game/entity states \u2b50\u2b50 Intermediate Event System Decouple with events \u2b50\u2b50 Intermediate Object Pooling Reduce allocations \u2b50\u2b50\u2b50 Advanced"},{"location":"guides/#performance-optimization","title":"Performance &amp; Optimization","text":"Guide Description Difficulty Profiling Measure performance \u2b50\u2b50 Intermediate Reducing Allocations Minimize garbage collection \u2b50\u2b50\u2b50 Advanced Draw Call Batching Optimize rendering \u2b50\u2b50\u2b50 Advanced Asset Streaming Load assets on demand \u2b50\u2b50\u2b50 Advanced"},{"location":"guides/#testing-debugging","title":"Testing &amp; Debugging","text":"Guide Description Difficulty Unit Testing Test game logic \u2b50\u2b50 Intermediate Debug Visualization Visualize collisions, paths \u2b50 Beginner Logging Effective log messages \u2b50 Beginner Hot Reload Fast iteration \u2b50\u2b50 Intermediate"},{"location":"guides/#packaging-distribution","title":"Packaging &amp; Distribution","text":"Guide Description Difficulty Publishing Build release versions \u2b50\u2b50 Intermediate Cross-Platform Windows, Linux, macOS \u2b50\u2b50\u2b50 Advanced Installers Create setup programs \u2b50\u2b50 Intermediate"},{"location":"guides/#learning-paths","title":"Learning Paths","text":""},{"location":"guides/#path-1-complete-beginner","title":"Path 1: Complete Beginner","text":"<p>Start here if you're new to game development:</p> <ol> <li>Quick Start - Get something on screen</li> <li>Keyboard Input - Make it interactive</li> <li>Drawing Basics - Understand rendering</li> <li>Loading Textures - Add graphics</li> <li>Player Movement - Create player control</li> </ol> <p>Result: A simple game with a player you can move around!</p>"},{"location":"guides/#path-2-intermediate-developer","title":"Path 2: Intermediate Developer","text":"<p>You've built simple games before:</p> <ol> <li>Sprite Rendering - Work with sprite sheets</li> <li>Animation - Bring sprites to life</li> <li>Basic Collision - Add physics</li> <li>Camera System - Follow the player</li> <li>Tiled Integration - Build levels</li> </ol> <p>Result: A platformer or top-down game with levels!</p>"},{"location":"guides/#path-3-advanced-developer","title":"Path 3: Advanced Developer","text":"<p>You want to optimize and polish:</p> <ol> <li>Component System - Clean architecture</li> <li>Object Pooling - Reduce GC pressure</li> <li>Spatial Partitioning - Fast collision</li> <li>Profiling - Find bottlenecks</li> <li>Asset Streaming - Large game optimization</li> </ol> <p>Result: A polished, performant game ready for release!</p>"},{"location":"guides/#how-to-use-these-guides","title":"How to Use These Guides","text":""},{"location":"guides/#structure","title":"Structure","text":"<p>Each guide follows this format:</p> <ol> <li>Overview - What you'll build</li> <li>Prerequisites - What you need to know first</li> <li>Step-by-Step - Complete walkthrough</li> <li>Complete Code - Copy-paste ready examples</li> <li>Explanation - How it works</li> <li>Common Issues - Troubleshooting</li> <li>Next Steps - Related guides</li> </ol>"},{"location":"guides/#code-examples","title":"Code Examples","text":"<p>All code examples are: - \u2705 Complete - No placeholder comments - \u2705 Tested - Works with Brine2D .NET 10 - \u2705 Commented - Explains key concepts - \u2705 Copy-Paste Ready - Use immediately</p>"},{"location":"guides/#difficulty-levels","title":"Difficulty Levels","text":"Symbol Level Description \u2b50 Beginner No prior experience needed \u2b50\u2b50 Intermediate Some game dev experience helpful \u2b50\u2b50\u2b50 Advanced Requires solid C# and game dev knowledge"},{"location":"guides/#complete-examples","title":"Complete Examples","text":""},{"location":"guides/#example-1-simple-platformer","title":"Example 1: Simple Platformer","text":"<p>Combines these guides: - Player Movement - Jump &amp; Gravity - Basic Collision - Camera System - Tilemap Rendering</p> <p>See Full Tutorial \u2192</p>"},{"location":"guides/#example-2-top-down-shooter","title":"Example 2: Top-Down Shooter","text":"<p>Combines these guides: - Player Movement - Shooting - Enemy AI - Health System - Particle Effects</p> <p>See Full Tutorial \u2192</p>"},{"location":"guides/#example-3-menu-system","title":"Example 3: Menu System","text":"<p>Combines these guides: - Buttons - Sliders - Text Input - Dialogs - Save/Load</p> <p>See Full Tutorial \u2192</p>"},{"location":"guides/#find-what-you-need","title":"Find What You Need","text":""},{"location":"guides/#by-feature","title":"By Feature","text":"<ul> <li>Need to load sprites? \u2192 Loading Textures</li> <li>Want controller support? \u2192 Gamepad Support</li> <li>Adding sound? \u2192 Sound Effects</li> <li>Building UI? \u2192 UI Guides</li> </ul>"},{"location":"guides/#by-problem","title":"By Problem","text":"<ul> <li>\"My game is slow\" \u2192 Performance Guides</li> <li>\"Collisions aren't working\" \u2192 Collision Guides</li> <li>\"How do I organize my code?\" \u2192 Architecture Guides</li> </ul>"},{"location":"guides/#contributing","title":"Contributing","text":"<p>Found something unclear? Want to add a guide?</p> <ol> <li>Check existing guides for style</li> <li>Follow the template structure</li> <li>Include complete code examples</li> <li>Test everything works</li> </ol> <p>Contribution Guidelines \u2192</p>"},{"location":"guides/#need-help","title":"Need Help?","text":"<ul> <li>Discord: Join our community</li> <li>GitHub Issues: Report problems</li> <li>Stack Overflow: Tag <code>brine2d</code></li> <li>Twitter: @Brine2D</li> </ul>"},{"location":"guides/#quick-reference","title":"Quick Reference","text":"I want to... Go to... Move a character Player Movement Handle clicks Mouse Input Play a sound Sound Effects Show a button Buttons Detect collision Basic Collision Load a level Tiled Integration Follow the player Camera System Animate a sprite Animation Display health bar HUD Save progress Save/Load <p>Ready to start building? Pick a guide and let's code!</p> <p>Begin with Quick Start \u2192</p>"},{"location":"guides/audio/getting-started/","title":"Getting Started with Audio","text":"<p>Learn the basics of audio in Brine2D, from setup to playing your first sound effects and music.</p>"},{"location":"guides/audio/getting-started/#overview","title":"Overview","text":"<p>Brine2D provides a complete audio system powered by SDL3_mixer with support for:</p> <ul> <li>Sound Effects - Short audio clips (explosions, jumps, UI sounds)</li> <li>Music - Long-form audio tracks (background music, ambience)</li> <li>Spatial Audio - 2D positional audio with distance and panning</li> <li>Volume Control - Master, music, and sound effect volume</li> <li>Multiple Formats - WAV, MP3, OGG, FLAC support</li> </ul>"},{"location":"guides/audio/getting-started/#setup","title":"Setup","text":""},{"location":"guides/audio/getting-started/#register-audio-service","title":"Register Audio Service","text":"<p>Add SDL3 audio to your game:</p> <pre><code>using Brine2D.Audio.SDL;\n\nvar builder = GameApplication.CreateBuilder(args);\n\n// Add SDL3 audio service\nbuilder.Services.AddSDL3Audio();\n\n// Other services...\nbuilder.Services.AddSDL3Rendering();\nbuilder.Services.AddSDL3Input();\n\nvar game = builder.Build();\nawait game.RunAsync&lt;GameScene&gt;();</code></pre>"},{"location":"guides/audio/getting-started/#inject-iaudioservice","title":"Inject IAudioService","text":"<p>Access audio in your scenes:</p> <pre><code>using Brine2D.Audio;\nusing Brine2D.Core;\n\npublic class GameScene : Scene\n{\n    private readonly IAudioService _audio;\n\n    public GameScene(\n        IAudioService audio,\n        ILogger&lt;GameScene&gt; logger) : base(logger)\n    {\n        _audio = audio;\n    }\n}</code></pre>"},{"location":"guides/audio/getting-started/#audio-assets","title":"Audio Assets","text":""},{"location":"guides/audio/getting-started/#supported-formats","title":"Supported Formats","text":"Format Use Case Notes WAV Sound effects Uncompressed, instant playback MP3 Music Compressed, smaller files OGG Music, sounds Open format, good compression FLAC High-quality music Lossless compression"},{"location":"guides/audio/getting-started/#file-organization","title":"File Organization","text":"<p>Organize audio files in your project:</p> <pre><code>MyGame/\n\u251c\u2500\u2500 assets/\n\u2502   \u251c\u2500\u2500 sounds/\n\u2502   \u2502   \u251c\u2500\u2500 jump.wav\n\u2502   \u2502   \u251c\u2500\u2500 explosion.wav\n\u2502   \u2502   \u251c\u2500\u2500 coin.wav\n\u2502   \u2502   \u2514\u2500\u2500 hit.wav\n\u2502   \u2514\u2500\u2500 music/\n\u2502       \u251c\u2500\u2500 menu.mp3\n\u2502       \u251c\u2500\u2500 level1.mp3\n\u2502       \u2514\u2500\u2500 boss.mp3\n\u251c\u2500\u2500 Program.cs\n\u2514\u2500\u2500 MyGame.csproj</code></pre> <p>Best Practices: - Use WAV for short sound effects (&lt; 2 seconds) - Use MP3/OGG for music (&gt; 30 seconds) - Keep sound effects under 100KB each - Use consistent sample rates (44.1 kHz recommended)</p>"},{"location":"guides/audio/getting-started/#loading-audio","title":"Loading Audio","text":""},{"location":"guides/audio/getting-started/#sound-effects","title":"Sound Effects","text":"<p>Load sound effects during scene initialization:</p> <pre><code>public class GameScene : Scene\n{\n    private ISoundEffect? _jumpSound;\n    private ISoundEffect? _coinSound;\n\n    protected override async Task OnLoadAsync(CancellationToken cancellationToken)\n    {\n        // Load sound effects\n        _jumpSound = await _audio.LoadSoundAsync(\n            \"assets/sounds/jump.wav\", \n            cancellationToken);\n\n        _coinSound = await _audio.LoadSoundAsync(\n            \"assets/sounds/coin.wav\", \n            cancellationToken);\n\n        Logger.LogInformation(\"Sound effects loaded\");\n    }\n}</code></pre>"},{"location":"guides/audio/getting-started/#music","title":"Music","text":"<p>Load music files:</p> <pre><code>public class GameScene : Scene\n{\n    private IMusic? _backgroundMusic;\n\n    protected override async Task OnLoadAsync(CancellationToken cancellationToken)\n    {\n        // Load background music\n        _backgroundMusic = await _audio.LoadMusicAsync(\n            \"assets/music/level1.mp3\", \n            cancellationToken);\n\n        Logger.LogInformation(\"Music loaded\");\n    }\n}</code></pre>"},{"location":"guides/audio/getting-started/#loading-multiple-files","title":"Loading Multiple Files","text":"<p>Load all audio at once:</p> <pre><code>protected override async Task OnLoadAsync(CancellationToken cancellationToken)\n{\n    // Load all sound effects\n    var soundPaths = new[]\n    {\n        \"assets/sounds/jump.wav\",\n        \"assets/sounds/coin.wav\",\n        \"assets/sounds/explosion.wav\",\n        \"assets/sounds/hit.wav\"\n    };\n\n    var soundTasks = soundPaths.Select(path =&gt; \n        _audio.LoadSoundAsync(path, cancellationToken));\n\n    var sounds = await Task.WhenAll(soundTasks);\n\n    _jumpSound = sounds[0];\n    _coinSound = sounds[1];\n    _explosionSound = sounds[2];\n    _hitSound = sounds[3];\n\n    // Load music\n    _backgroundMusic = await _audio.LoadMusicAsync(\n        \"assets/music/level1.mp3\", \n        cancellationToken);\n\n    Logger.LogInformation(\"All audio loaded\");\n}</code></pre>"},{"location":"guides/audio/getting-started/#playing-audio","title":"Playing Audio","text":""},{"location":"guides/audio/getting-started/#sound-effects_1","title":"Sound Effects","text":"<p>Play sound effects in response to events:</p> <pre><code>protected override void OnUpdate(GameTime gameTime)\n{\n    // Play jump sound when spacebar pressed\n    if (_input.IsKeyPressed(Keys.Space) &amp;&amp; _jumpSound != null)\n    {\n        _audio.PlaySound(_jumpSound);\n    }\n\n    // Play coin sound when collecting coins\n    if (CollectedCoin() &amp;&amp; _coinSound != null)\n    {\n        _audio.PlaySound(_coinSound);\n    }\n}</code></pre>"},{"location":"guides/audio/getting-started/#music_1","title":"Music","text":"<p>Play background music:</p> <pre><code>protected override async Task OnLoadAsync(CancellationToken cancellationToken)\n{\n    _backgroundMusic = await _audio.LoadMusicAsync(\n        \"assets/music/level1.mp3\", \n        cancellationToken);\n\n    // Start playing music (loops by default)\n    _audio.PlayMusic(_backgroundMusic);\n}</code></pre>"},{"location":"guides/audio/getting-started/#with-volume","title":"With Volume","text":"<p>Control playback volume:</p> <pre><code>// Play at 50% volume\n_audio.PlaySound(_explosionSound, volume: 0.5f);\n\n// Play at full volume\n_audio.PlaySound(_coinSound, volume: 1.0f);\n\n// Play quietly\n_audio.PlaySound(_footstepSound, volume: 0.2f);</code></pre>"},{"location":"guides/audio/getting-started/#looping-sounds","title":"Looping Sounds","text":"<p>Play sounds repeatedly:</p> <pre><code>// Loop 3 times\n_audio.PlaySound(_engineSound, loops: 3);\n\n// Loop infinitely (-1)\n_audio.PlaySound(_ambientSound, loops: -1);</code></pre>"},{"location":"guides/audio/getting-started/#volume-control","title":"Volume Control","text":""},{"location":"guides/audio/getting-started/#master-volume","title":"Master Volume","text":"<p>Control overall audio volume:</p> <pre><code>// Set master volume (0.0 to 1.0)\n_audio.MasterVolume = 0.8f;\n\n// Get current master volume\nvar currentVolume = _audio.MasterVolume;\n\n// Mute all audio\n_audio.MasterVolume = 0f;</code></pre>"},{"location":"guides/audio/getting-started/#sound-effects-volume","title":"Sound Effects Volume","text":"<p>Control all sound effects:</p> <pre><code>// Set sound effects volume (0.0 to 1.0)\n_audio.SoundVolume = 0.7f;\n\n// Individual sounds are multiplied by this\n// PlaySound(sound, volume: 0.5f) with SoundVolume = 0.7f\n// Results in: 0.5 \u00d7 0.7 = 0.35 final volume</code></pre>"},{"location":"guides/audio/getting-started/#music-volume","title":"Music Volume","text":"<p>Control background music:</p> <pre><code>// Set music volume (0.0 to 1.0)\n_audio.MusicVolume = 0.5f;\n\n// Fade music down\nfor (float t = 1f; t &gt;= 0f; t -= 0.01f)\n{\n    _audio.MusicVolume = t;\n    await Task.Delay(50);\n}</code></pre>"},{"location":"guides/audio/getting-started/#settings-integration","title":"Settings Integration","text":"<p>Save volume preferences:</p> <pre><code>public class SettingsScene : Scene\n{\n    private float _masterVolume = 0.8f;\n    private float _musicVolume = 0.6f;\n    private float _soundVolume = 0.7f;\n\n    private void ApplySettings()\n    {\n        _audio.MasterVolume = _masterVolume;\n        _audio.MusicVolume = _musicVolume;\n        _audio.SoundVolume = _soundVolume;\n\n        // Save to config file\n        SaveSettings();\n    }\n\n    private void LoadSettings()\n    {\n        // Load from config file\n        var settings = LoadFromFile();\n        _masterVolume = settings.MasterVolume;\n        _musicVolume = settings.MusicVolume;\n        _soundVolume = settings.SoundVolume;\n\n        ApplySettings();\n    }\n}</code></pre>"},{"location":"guides/audio/getting-started/#music-playback-control","title":"Music Playback Control","text":""},{"location":"guides/audio/getting-started/#play-and-stop","title":"Play and Stop","text":"<pre><code>// Start music\n_audio.PlayMusic(_backgroundMusic);\n\n// Stop music\n_audio.StopMusic();\n\n// Check if music is playing\nif (_audio.IsMusicPlaying)\n{\n    Logger.LogInfo(\"Music is playing\");\n}</code></pre>"},{"location":"guides/audio/getting-started/#pause-and-resume","title":"Pause and Resume","text":"<pre><code>// Pause music\n_audio.PauseMusic();\n\n// Resume music\n_audio.ResumeMusic();\n\n// Check if paused\nif (_audio.IsMusicPaused)\n{\n    Logger.LogInfo(\"Music is paused\");\n}</code></pre>"},{"location":"guides/audio/getting-started/#music-loops","title":"Music Loops","text":"<pre><code>// Play once (stops after finish)\n_audio.PlayMusic(_bossMusic, loops: 0);\n\n// Play 3 times\n_audio.PlayMusic(_victoryMusic, loops: 3);\n\n// Loop forever (default)\n_audio.PlayMusic(_backgroundMusic, loops: -1);</code></pre>"},{"location":"guides/audio/getting-started/#complete-example","title":"Complete Example","text":"<p>Here's a full scene with audio:</p> <pre><code>using Brine2D.Audio;\nusing Brine2D.Core;\nusing Brine2D.Input;\n\npublic class GameScene : Scene\n{\n    private readonly IAudioService _audio;\n    private readonly IInputService _input;\n\n    private ISoundEffect? _jumpSound;\n    private ISoundEffect? _coinSound;\n    private ISoundEffect? _explosionSound;\n    private IMusic? _backgroundMusic;\n\n    public GameScene(\n        IAudioService audio,\n        IInputService input,\n        ILogger&lt;GameScene&gt; logger) : base(logger)\n    {\n        _audio = audio;\n        _input = input;\n    }\n\n    protected override async Task OnInitializeAsync(CancellationToken cancellationToken)\n    {\n        // Set initial volumes\n        _audio.MasterVolume = 0.8f;\n        _audio.MusicVolume = 0.6f;\n        _audio.SoundVolume = 0.7f;\n    }\n\n    protected override async Task OnLoadAsync(CancellationToken cancellationToken)\n    {\n        // Load sound effects\n        _jumpSound = await _audio.LoadSoundAsync(\n            \"assets/sounds/jump.wav\", cancellationToken);\n        _coinSound = await _audio.LoadSoundAsync(\n            \"assets/sounds/coin.wav\", cancellationToken);\n        _explosionSound = await _audio.LoadSoundAsync(\n            \"assets/sounds/explosion.wav\", cancellationToken);\n\n        // Load and play music\n        _backgroundMusic = await _audio.LoadMusicAsync(\n            \"assets/music/level1.mp3\", cancellationToken);\n        _audio.PlayMusic(_backgroundMusic);\n\n        Logger.LogInformation(\"Audio loaded and music started\");\n    }\n\n    protected override void OnUpdate(GameTime gameTime)\n    {\n        // Play jump sound\n        if (_input.IsKeyPressed(Keys.Space))\n        {\n            _audio.PlaySound(_jumpSound);\n        }\n\n        // Play coin sound at 80% volume\n        if (_input.IsKeyPressed(Keys.C))\n        {\n            _audio.PlaySound(_coinSound, volume: 0.8f);\n        }\n\n        // Play explosion sound\n        if (_input.IsKeyPressed(Keys.E))\n        {\n            _audio.PlaySound(_explosionSound, volume: 1.0f);\n        }\n\n        // Pause/resume music\n        if (_input.IsKeyPressed(Keys.M))\n        {\n            if (_audio.IsMusicPaused)\n            {\n                _audio.ResumeMusic();\n                Logger.LogInfo(\"Music resumed\");\n            }\n            else if (_audio.IsMusicPlaying)\n            {\n                _audio.PauseMusic();\n                Logger.LogInfo(\"Music paused\");\n            }\n        }\n    }\n\n    protected override void OnDispose()\n    {\n        // Stop music when scene ends\n        _audio.StopMusic();\n\n        // Optionally unload audio (will be cleaned up automatically)\n        if (_jumpSound != null) _audio.UnloadSound(_jumpSound);\n        if (_coinSound != null) _audio.UnloadSound(_coinSound);\n        if (_explosionSound != null) _audio.UnloadSound(_explosionSound);\n        if (_backgroundMusic != null) _audio.UnloadMusic(_backgroundMusic);\n    }\n}</code></pre>"},{"location":"guides/audio/getting-started/#common-patterns","title":"Common Patterns","text":""},{"location":"guides/audio/getting-started/#loading-screen-audio","title":"Loading Screen Audio","text":"<p>Load audio during a loading screen:</p> <pre><code>public class LoadingScene : Scene\n{\n    protected override async Task OnLoadAsync(CancellationToken cancellationToken)\n    {\n        // Load all audio for next scene\n        var audioFiles = new[]\n        {\n            (\"jump\", \"assets/sounds/jump.wav\"),\n            (\"coin\", \"assets/sounds/coin.wav\"),\n            (\"music\", \"assets/music/level1.mp3\")\n        };\n\n        int loaded = 0;\n        foreach (var (name, path) in audioFiles)\n        {\n            if (path.EndsWith(\".mp3\") || path.EndsWith(\".ogg\"))\n            {\n                await _audio.LoadMusicAsync(path, cancellationToken);\n            }\n            else\n            {\n                await _audio.LoadSoundAsync(path, cancellationToken);\n            }\n\n            loaded++;\n            UpdateProgress(loaded / (float)audioFiles.Length);\n        }\n\n        // Transition to game scene\n        await _sceneManager.LoadSceneAsync&lt;GameScene&gt;();\n    }\n}</code></pre>"},{"location":"guides/audio/getting-started/#audio-manager","title":"Audio Manager","text":"<p>Create a centralized audio manager:</p> <pre><code>public class AudioManager\n{\n    private readonly IAudioService _audio;\n    private readonly Dictionary&lt;string, ISoundEffect&gt; _sounds = new();\n    private readonly Dictionary&lt;string, IMusic&gt; _music = new();\n\n    public AudioManager(IAudioService audio)\n    {\n        _audio = audio;\n    }\n\n    public async Task LoadSoundAsync(string name, string path, CancellationToken ct = default)\n    {\n        var sound = await _audio.LoadSoundAsync(path, ct);\n        _sounds[name] = sound;\n    }\n\n    public void PlaySound(string name, float volume = 1.0f)\n    {\n        if (_sounds.TryGetValue(name, out var sound))\n        {\n            _audio.PlaySound(sound, volume);\n        }\n    }\n\n    public async Task LoadMusicAsync(string name, string path, CancellationToken ct = default)\n    {\n        var music = await _audio.LoadMusicAsync(path, ct);\n        _music[name] = music;\n    }\n\n    public void PlayMusic(string name)\n    {\n        if (_music.TryGetValue(name, out var music))\n        {\n            _audio.PlayMusic(music);\n        }\n    }\n}</code></pre>"},{"location":"guides/audio/getting-started/#scene-based-music","title":"Scene-Based Music","text":"<p>Change music per scene:</p> <pre><code>public class MenuScene : Scene\n{\n    protected override async Task OnLoadAsync(CancellationToken cancellationToken)\n    {\n        var menuMusic = await _audio.LoadMusicAsync(\n            \"assets/music/menu.mp3\", cancellationToken);\n        _audio.PlayMusic(menuMusic);\n    }\n}\n\npublic class GameScene : Scene\n{\n    protected override async Task OnLoadAsync(CancellationToken cancellationToken)\n    {\n        // Stop menu music, start game music\n        _audio.StopMusic();\n\n        var gameMusic = await _audio.LoadMusicAsync(\n            \"assets/music/level1.mp3\", cancellationToken);\n        _audio.PlayMusic(gameMusic);\n    }\n}</code></pre>"},{"location":"guides/audio/getting-started/#best-practices","title":"Best Practices","text":""},{"location":"guides/audio/getting-started/#do","title":"Do","text":"<ul> <li>Load audio during scene initialization - Not during gameplay</li> <li>Use appropriate formats - WAV for sounds, MP3/OGG for music</li> <li>Respect volume levels - Honor user settings</li> <li>Stop music when changing scenes - Avoid overlapping tracks</li> <li>Unload audio when done - Free memory (or rely on scene cleanup)</li> </ul>"},{"location":"guides/audio/getting-started/#dont","title":"Don't","text":"<ul> <li>Load audio synchronously in Update() - Causes frame drops</li> <li>Play too many sounds at once - Causes audio mud</li> <li>Use uncompressed formats for music - Wastes disk space</li> <li>Forget to handle null sounds - Check if loading succeeded</li> <li>Play music without volume control - Always respect settings</li> </ul>"},{"location":"guides/audio/getting-started/#volume-guidelines","title":"Volume Guidelines","text":"<pre><code>// Master volume: Overall control\n_audio.MasterVolume = 0.8f;  // 80% - reasonable default\n\n// Music volume: Background audio\n_audio.MusicVolume = 0.6f;   // 60% - quieter than effects\n\n// Sound effects volume: Gameplay sounds\n_audio.SoundVolume = 0.7f;   // 70% - clear but not overwhelming\n\n// Individual sounds\n_audio.PlaySound(uiClick, volume: 0.5f);       // UI - subtle\n_audio.PlaySound(footstep, volume: 0.3f);      // Ambient - quiet\n_audio.PlaySound(explosion, volume: 1.0f);     // Important - full volume\n_audio.PlaySound(playerJump, volume: 0.8f);    // Player action - clear</code></pre>"},{"location":"guides/audio/getting-started/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guides/audio/getting-started/#no-sound-playing","title":"No Sound Playing","text":"<p>Problem: Audio doesn't play.</p> <p>Solutions:</p> <pre><code>// 1. Verify audio service is registered\nbuilder.Services.AddSDL3Audio();\n\n// 2. Check file exists\nif (!File.Exists(\"assets/sounds/jump.wav\"))\n{\n    Logger.LogError(\"Sound file not found!\");\n}\n\n// 3. Verify sound loaded successfully\nvar sound = await _audio.LoadSoundAsync(\"assets/sounds/jump.wav\");\nif (sound == null)\n{\n    Logger.LogError(\"Failed to load sound!\");\n}\n\n// 4. Check volume levels\nLogger.LogInfo($\"Master: {_audio.MasterVolume}, Sound: {_audio.SoundVolume}\");</code></pre>"},{"location":"guides/audio/getting-started/#playback-lag","title":"Playback Lag","text":"<p>Problem: Delay between input and sound.</p> <p>Solution: Use WAV files for immediate response:</p> <pre><code>// Good: WAV loads instantly\nvar jumpSound = await _audio.LoadSoundAsync(\"assets/sounds/jump.wav\");\n\n// Bad: MP3 has decode overhead for short sounds\nvar jumpSound = await _audio.LoadSoundAsync(\"assets/sounds/jump.mp3\");</code></pre>"},{"location":"guides/audio/getting-started/#music-wont-loop","title":"Music Won't Loop","text":"<p>Problem: Music plays once and stops.</p> <p>Solution: Set loops to -1 (default):</p> <pre><code>// Music loops by default\n_audio.PlayMusic(backgroundMusic);\n\n// Or explicitly set infinite loop\n_audio.PlayMusic(backgroundMusic, loops: -1);</code></pre>"},{"location":"guides/audio/getting-started/#sounds-too-quiet","title":"Sounds Too Quiet","text":"<p>Problem: Can barely hear audio.</p> <p>Solution: Check volume multipliers:</p> <pre><code>// Sound effects are multiplied:\n// Final Volume = SoundVolume \u00d7 PlaySound volume\n\n_audio.SoundVolume = 0.7f;  // Sound effects at 70%\n_audio.PlaySound(sound, volume: 0.5f);  // 50% of sound effects\n// Result: 0.7 \u00d7 0.5 = 0.35 (35% final volume)\n\n// Fix: Increase base volumes\n_audio.SoundVolume = 1.0f;\n_audio.PlaySound(sound, volume: 0.8f);</code></pre>"},{"location":"guides/audio/getting-started/#next-steps","title":"Next Steps","text":"<p>Now that you understand the basics, explore advanced audio features:</p> <ul> <li>Sound Effects - Advanced sound playback techniques</li> <li>Music Playback - Music control and transitions</li> <li>Spatial Audio - 2D positional audio with distance and panning</li> <li>ECS Audio - Component-based audio sources</li> </ul> <p>Quick Reference:</p> <pre><code>// Setup\nbuilder.Services.AddSDL3Audio();\n\n// Loading\nvar sound = await _audio.LoadSoundAsync(\"path/to/sound.wav\");\nvar music = await _audio.LoadMusicAsync(\"path/to/music.mp3\");\n\n// Playing\n_audio.PlaySound(sound, volume: 0.8f, loops: 0);\n_audio.PlayMusic(music, loops: -1);\n\n// Control\n_audio.MasterVolume = 0.8f;\n_audio.MusicVolume = 0.6f;\n_audio.SoundVolume = 0.7f;\n\n// Music\n_audio.PauseMusic();\n_audio.ResumeMusic();\n_audio.StopMusic();\n\n// Cleanup\n_audio.UnloadSound(sound);\n_audio.UnloadMusic(music);</code></pre>"},{"location":"guides/audio/spatial-audio/","title":"Spatial Audio","text":"<p>Spatial audio simulates sound positioning in 2D space, making your game world feel more immersive with distance-based volume attenuation and stereo panning.</p>"},{"location":"guides/audio/spatial-audio/#what-is-spatial-audio","title":"What is Spatial Audio?","text":"<p>Spatial audio (also called positional audio) adjusts sound based on the distance and direction between a sound source and an audio listener. As entities move in your game world, sounds automatically fade, pan left/right, and change volume to match their spatial relationships.</p> <p>Key Features: - Distance attenuation - Sounds fade as they move away from the listener - Stereo panning - Sounds pan left/right based on horizontal position - Real-time updates - Audio adjusts every frame as entities move - Configurable curves - Linear, quadratic, or custom falloff - ECS integration - Component-based audio sources and listeners</p>"},{"location":"guides/audio/spatial-audio/#basic-concepts","title":"Basic Concepts","text":""},{"location":"guides/audio/spatial-audio/#audio-listener","title":"Audio Listener","text":"<p>The listener represents the \"ears\" in your game world - typically attached to the player or camera.</p> <p>Properties:</p> <ul> <li><code>GlobalSpatialVolume</code> - Master volume for all spatial audio (0.0 to 10.0)</li> <li><code>IsEnabled</code> - Toggle spatial audio processing</li> </ul>"},{"location":"guides/audio/spatial-audio/#audio-source","title":"Audio Source","text":"<p>A positioned sound emitter in your game world - enemies, pickups, environmental effects, etc.</p> <p>Properties:</p> <ul> <li><code>MinDistance</code> - Full volume within this radius</li> <li><code>MaxDistance</code> - Silent beyond this radius</li> <li><code>RolloffFactor</code> - How quickly sound fades (1.0 = linear, 2.0 = quadratic)</li> <li><code>SpatialBlend</code> - Stereo effect strength (0.0 = mono, 1.0 = full stereo)</li> <li><code>Volume</code> - Base volume before spatial processing</li> <li><code>EnableSpatialAudio</code> - Toggle spatial audio for this source</li> </ul>"},{"location":"guides/audio/spatial-audio/#distance-attenuation","title":"Distance Attenuation","text":"<p>Sound volume decreases with distance from the listener:</p> <pre><code>Volume = BaseVolume \u00d7 AttenuationFactor\n\nWhere:\n- AttenuationFactor = 1.0 (full volume) within MinDistance\n- AttenuationFactor = 0.0 (silent) beyond MaxDistance\n- AttenuationFactor = calculated curve between Min/Max</code></pre>"},{"location":"guides/audio/spatial-audio/#stereo-panning","title":"Stereo Panning","text":"<p>Sound position affects left/right speaker balance:</p> <pre><code>Pan = -1.0 (full left) to +1.0 (full right)\n\nCalculated from:\n- Direction vector from listener to source\n- X component determines pan (-1 = left, +1 = right)\n- SpatialBlend controls strength of effect</code></pre>"},{"location":"guides/audio/spatial-audio/#setup","title":"Setup","text":""},{"location":"guides/audio/spatial-audio/#register-audiosystem","title":"Register AudioSystem","text":"<p>AudioSystem processes spatial audio every frame:</p> <pre><code>builder.Services.ConfigureSystemPipelines(pipelines =&gt;\n{\n    pipelines.AddSystem&lt;AudioSystem&gt;();  // Update order: 300\n});</code></pre>"},{"location":"guides/audio/spatial-audio/#create-audio-listener","title":"Create Audio Listener","text":"<p>Typically attached to the player or camera:</p> <pre><code>using Brine2D.Audio.ECS;\n\n// Create player with audio listener\nvar player = _world.CreateEntity(\"Player\");\n\nvar transform = player.AddComponent&lt;TransformComponent&gt;();\ntransform.Position = new Vector2(640, 360);\n\nvar listener = player.AddComponent&lt;AudioListenerComponent&gt;();\nlistener.GlobalSpatialVolume = 1.0f;  // Master spatial audio volume\nlistener.IsEnabled = true;</code></pre>"},{"location":"guides/audio/spatial-audio/#create-audio-source","title":"Create Audio Source","text":"<p>Attach to any entity that should emit sound:</p> <pre><code>// Create enemy with spatial audio\nvar enemy = _world.CreateEntity(\"Enemy\");\n\nvar transform = enemy.AddComponent&lt;TransformComponent&gt;();\ntransform.Position = new Vector2(200, 300);\n\nvar audioSource = enemy.AddComponent&lt;AudioSourceComponent&gt;();\naudioSource.SoundEffect = enemyGrowlSound;\naudioSource.EnableSpatialAudio = true;\n\n// Distance settings\naudioSource.MinDistance = 100f;   // Full volume within 100 pixels\naudioSource.MaxDistance = 500f;   // Silent beyond 500 pixels\naudioSource.RolloffFactor = 1.0f; // Linear falloff\n\n// Stereo settings\naudioSource.SpatialBlend = 1.0f;  // Full stereo panning\n\n// Playback\naudioSource.Volume = 0.7f;\naudioSource.Loop = true;\naudioSource.LoopCount = -1;\naudioSource.PlayOnEnable = true;</code></pre>"},{"location":"guides/audio/spatial-audio/#distance-attenuation_1","title":"Distance Attenuation","text":""},{"location":"guides/audio/spatial-audio/#linear-falloff","title":"Linear Falloff","text":"<p>Sound decreases evenly with distance (most natural):</p> <pre><code>audioSource.RolloffFactor = 1.0f;  // Linear\n\n// Volume decreases smoothly from Min to Max distance\n// Example: At 50% distance, volume is ~50%</code></pre>"},{"location":"guides/audio/spatial-audio/#quadratic-falloff","title":"Quadratic Falloff","text":"<p>Sound decreases rapidly, then slowly (dramatic):</p> <pre><code>audioSource.RolloffFactor = 2.0f;  // Quadratic\n\n// Volume drops quickly near source, gradually far away\n// Example: At 50% distance, volume is ~25%</code></pre>"},{"location":"guides/audio/spatial-audio/#custom-falloff","title":"Custom Falloff","text":"<p>Use intermediate values for custom curves:</p> <pre><code>audioSource.RolloffFactor = 1.5f;  // Exponential-ish\n\n// Smoother curve between linear and quadratic\n// Useful for fine-tuning specific sound types</code></pre>"},{"location":"guides/audio/spatial-audio/#no-falloff","title":"No Falloff","text":"<p>Constant volume within range (on/off):</p> <pre><code>audioSource.RolloffFactor = 0f;  // No falloff\n\n// Full volume from MinDistance to MaxDistance\n// Useful for ambient zones or music triggers</code></pre>"},{"location":"guides/audio/spatial-audio/#distance-configuration","title":"Distance Configuration","text":"<p>Typical distance ranges for different sound types:</p> <pre><code>// Small sound (coins, footsteps)\naudioSource.MinDistance = 50f;\naudioSource.MaxDistance = 200f;\n\n// Medium sound (weapon fire, enemy attacks)\naudioSource.MinDistance = 100f;\naudioSource.MaxDistance = 500f;\n\n// Large sound (explosions, boss roars)\naudioSource.MinDistance = 150f;\naudioSource.MaxDistance = 800f;\n\n// Environmental ambient (waterfalls, wind)\naudioSource.MinDistance = 200f;\naudioSource.MaxDistance = 1000f;</code></pre>"},{"location":"guides/audio/spatial-audio/#stereo-panning_1","title":"Stereo Panning","text":""},{"location":"guides/audio/spatial-audio/#full-stereo","title":"Full Stereo","text":"<p>Sounds pan completely left/right:</p> <pre><code>audioSource.SpatialBlend = 1.0f;  // Full stereo\n\n// Sound to the left plays in left speaker\n// Sound to the right plays in right speaker\n// Maximum spatial awareness</code></pre>"},{"location":"guides/audio/spatial-audio/#partial-stereo","title":"Partial Stereo","text":"<p>Balanced between center and stereo:</p> <pre><code>audioSource.SpatialBlend = 0.5f;  // 50% stereo\n\n// Sound is partially centered\n// Subtle left/right positioning\n// Good for background sounds</code></pre>"},{"location":"guides/audio/spatial-audio/#mono-center","title":"Mono (Center)","text":"<p>No panning, always centered:</p> <pre><code>audioSource.SpatialBlend = 0.0f;  // Mono\n\n// Sound plays equally in both speakers\n// No directional information\n// Good for UI sounds or ambient background</code></pre>"},{"location":"guides/audio/spatial-audio/#panning-examples","title":"Panning Examples","text":"<pre><code>// Directional effects (footsteps, movement)\naudioSource.SpatialBlend = 1.0f;  // Full stereo for clear direction\n\n// Ambient sounds (wind, water)\naudioSource.SpatialBlend = 0.6f;  // Some stereo, mostly centered\n\n// Important sounds (pickups, objectives)\naudioSource.SpatialBlend = 0.8f;  // Strong stereo, easy to locate\n\n// Background music triggers\naudioSource.SpatialBlend = 0.3f;  // Mostly centered, subtle panning</code></pre>"},{"location":"guides/audio/spatial-audio/#complete-examples","title":"Complete Examples","text":""},{"location":"guides/audio/spatial-audio/#enemy-audio","title":"Enemy Audio","text":"<p>Enemy that growls when nearby:</p> <pre><code>public void CreateEnemy(Vector2 position, ISoundEffect growlSound)\n{\n    var enemy = _world.CreateEntity(\"Enemy\");\n\n    // Position\n    var transform = enemy.AddComponent&lt;TransformComponent&gt;();\n    transform.Position = position;\n\n    // Spatial audio\n    var audio = enemy.AddComponent&lt;AudioSourceComponent&gt;();\n    audio.SoundEffect = growlSound;\n    audio.EnableSpatialAudio = true;\n\n    // Threatening medium-distance sound\n    audio.MinDistance = 80f;\n    audio.MaxDistance = 400f;\n    audio.RolloffFactor = 1.5f;  // Drops off faster than linear\n    audio.SpatialBlend = 0.9f;   // Strong directional cue\n    audio.Volume = 0.6f;\n\n    // Loop continuously\n    audio.Loop = true;\n    audio.LoopCount = -1;\n    audio.PlayOnEnable = true;\n}</code></pre>"},{"location":"guides/audio/spatial-audio/#collectible-coin","title":"Collectible Coin","text":"<p>Coin that jingles when player is near:</p> <pre><code>public void CreateCoin(Vector2 position, ISoundEffect jingleSound)\n{\n    var coin = _world.CreateEntity(\"Coin\");\n\n    // Position\n    var transform = coin.AddComponent&lt;TransformComponent&gt;();\n    transform.Position = position;\n\n    // Spatial audio\n    var audio = coin.AddComponent&lt;AudioSourceComponent&gt;();\n    audio.SoundEffect = jingleSound;\n    audio.EnableSpatialAudio = true;\n\n    // Short-range, clear positioning\n    audio.MinDistance = 40f;\n    audio.MaxDistance = 200f;\n    audio.RolloffFactor = 1.0f;  // Linear\n    audio.SpatialBlend = 1.0f;   // Full stereo for easy location\n    audio.Volume = 0.5f;\n\n    // Loop at low rate for presence\n    audio.Loop = true;\n    audio.LoopCount = -1;\n    audio.PlayOnEnable = true;\n}</code></pre>"},{"location":"guides/audio/spatial-audio/#explosion-effect","title":"Explosion Effect","text":"<p>One-shot explosion with spatial positioning:</p> <pre><code>public void CreateExplosion(Vector2 position, ISoundEffect explosionSound)\n{\n    var explosion = _world.CreateEntity(\"Explosion\");\n\n    // Position\n    var transform = explosion.AddComponent&lt;TransformComponent&gt;();\n    transform.Position = position;\n\n    // Spatial audio\n    var audio = explosion.AddComponent&lt;AudioSourceComponent&gt;();\n    audio.SoundEffect = explosionSound;\n    audio.EnableSpatialAudio = true;\n\n    // Long-range, dramatic falloff\n    audio.MinDistance = 150f;\n    audio.MaxDistance = 800f;\n    audio.RolloffFactor = 2.0f;  // Quadratic - loud up close\n    audio.SpatialBlend = 0.8f;   // Mostly directional\n    audio.Volume = 0.9f;\n\n    // One-shot sound\n    audio.Loop = false;\n    audio.TriggerPlay = true;\n\n    // Destroy entity after sound finishes\n    explosion.AddComponent&lt;LifetimeComponent&gt;().Lifetime = 3f;\n}</code></pre>"},{"location":"guides/audio/spatial-audio/#environmental-ambient","title":"Environmental Ambient","text":"<p>Waterfall sound that gets louder as player approaches:</p> <pre><code>public void CreateWaterfall(Vector2 position, ISoundEffect waterfallSound)\n{\n    var waterfall = _world.CreateEntity(\"Waterfall\");\n\n    // Position\n    var transform = waterfall.AddComponent&lt;TransformComponent&gt;();\n    transform.Position = position;\n\n    // Spatial audio\n    var audio = waterfall.AddComponent&lt;AudioSourceComponent&gt;();\n    audio.SoundEffect = waterfallSound;\n    audio.EnableSpatialAudio = true;\n\n    // Large ambient range\n    audio.MinDistance = 200f;\n    audio.MaxDistance = 1000f;\n    audio.RolloffFactor = 1.2f;  // Slightly faster than linear\n    audio.SpatialBlend = 0.5f;   // Subtle panning (omni-directional)\n    audio.Volume = 0.4f;\n\n    // Continuous ambient loop\n    audio.Loop = true;\n    audio.LoopCount = -1;\n    audio.PlayOnEnable = true;\n}</code></pre>"},{"location":"guides/audio/spatial-audio/#runtime-control","title":"Runtime Control","text":""},{"location":"guides/audio/spatial-audio/#dynamic-playback","title":"Dynamic Playback","text":"<p>Control audio sources at runtime:</p> <pre><code>// Start playing\naudioSource.TriggerPlay = true;\n\n// Stop playing\naudioSource.TriggerStop = true;\n\n// Toggle on/off\naudioSource.IsEnabled = !audioSource.IsEnabled;\n\n// Check state\nif (audioSource.IsPlaying)\n{\n    Logger.LogInfo(\"Sound is playing\");\n}</code></pre>"},{"location":"guides/audio/spatial-audio/#adjust-properties","title":"Adjust Properties","text":"<p>Modify spatial properties dynamically:</p> <pre><code>// Change volume based on game state\nif (playerInCombat)\n{\n    ambientAudio.Volume = 0.2f;  // Quieter during combat\n}\nelse\n{\n    ambientAudio.Volume = 0.5f;  // Louder when calm\n}\n\n// Change distance based on power-up\nif (playerHasEnhancedHearing)\n{\n    audio.MaxDistance = 800f;  // Hear further\n}\nelse\n{\n    audio.MaxDistance = 500f;  // Normal hearing\n}\n\n// Change panning for underwater effect\nif (playerUnderwater)\n{\n    audio.SpatialBlend = 0.3f;  // Sounds more muffled/centered\n}\nelse\n{\n    audio.SpatialBlend = 1.0f;  // Normal stereo\n}</code></pre>"},{"location":"guides/audio/spatial-audio/#observe-spatial-values","title":"Observe Spatial Values","text":"<p>Read calculated spatial properties:</p> <pre><code>// Get current spatial volume (after attenuation)\nvar spatialVolume = audioSource.SpatialVolume;\nLogger.LogInfo($\"Current volume: {spatialVolume:F2}\");\n\n// Get current pan value\nvar pan = audioSource.SpatialPan;\nLogger.LogInfo($\"Pan: {pan:F2} ({(pan &lt; 0 ? \"left\" : \"right\")})\");\n\n// Calculate distance to listener\nvar sourcePos = entity.GetComponent&lt;TransformComponent&gt;().Position;\nvar listenerPos = listenerEntity.GetComponent&lt;TransformComponent&gt;().Position;\nvar distance = Vector2.Distance(sourcePos, listenerPos);\nLogger.LogInfo($\"Distance: {distance:F0}\");</code></pre>"},{"location":"guides/audio/spatial-audio/#multiple-listeners","title":"Multiple Listeners","text":"<p>Only one listener is active at a time (first enabled listener found):</p> <pre><code>// Player listener\nvar playerListener = player.AddComponent&lt;AudioListenerComponent&gt;();\nplayerListener.IsEnabled = true;  // Active\n\n// Camera listener (for spectator mode)\nvar cameraListener = camera.AddComponent&lt;AudioListenerComponent&gt;();\ncameraListener.IsEnabled = false;  // Inactive\n\n// Switch to camera listener\nplayerListener.IsEnabled = false;\ncameraListener.IsEnabled = true;</code></pre>"},{"location":"guides/audio/spatial-audio/#advanced-techniques","title":"Advanced Techniques","text":""},{"location":"guides/audio/spatial-audio/#audio-zones","title":"Audio Zones","text":"<p>Create zones that affect audio properties:</p> <pre><code>public class AudioZoneComponent : Component\n{\n    public float VolumeMultiplier { get; set; } = 1.0f;\n    public float MaxDistanceMultiplier { get; set; } = 1.0f;\n}\n\n// System to apply zone effects\npublic class AudioZoneSystem : IUpdateSystem\n{\n    public void Update(GameTime gameTime)\n    {\n        var zones = _world.GetEntitiesWithComponent&lt;AudioZoneComponent&gt;();\n        var sources = _world.GetEntitiesWithComponent&lt;AudioSourceComponent&gt;();\n\n        foreach (var source in sources)\n        {\n            var audioSource = source.GetComponent&lt;AudioSourceComponent&gt;();\n            var sourcePos = source.GetComponent&lt;TransformComponent&gt;().Position;\n\n            // Check if source is in any zone\n            foreach (var zone in zones)\n            {\n                var zoneData = zone.GetComponent&lt;AudioZoneComponent&gt;();\n                var zoneTransform = zone.GetComponent&lt;TransformComponent&gt;();\n\n                if (IsInZone(sourcePos, zoneTransform, zoneData))\n                {\n                    // Apply zone effects\n                    audioSource.Volume *= zoneData.VolumeMultiplier;\n                    audioSource.MaxDistance *= zoneData.MaxDistanceMultiplier;\n                }\n            }\n        }\n    }\n}</code></pre>"},{"location":"guides/audio/spatial-audio/#occlusion","title":"Occlusion","text":"<p>Simple audio occlusion using raycasts:</p> <pre><code>public class AudioOcclusionSystem : IUpdateSystem\n{\n    public void Update(GameTime gameTime)\n    {\n        var listener = FindListener();\n        var sources = _world.GetEntitiesWithComponent&lt;AudioSourceComponent&gt;();\n\n        foreach (var source in sources)\n        {\n            var audioSource = source.GetComponent&lt;AudioSourceComponent&gt;();\n            if (!audioSource.EnableSpatialAudio) continue;\n\n            var sourcePos = source.GetComponent&lt;TransformComponent&gt;().Position;\n            var listenerPos = listener.GetComponent&lt;TransformComponent&gt;().Position;\n\n            // Raycast to check line of sight\n            if (IsOccluded(sourcePos, listenerPos))\n            {\n                // Reduce volume when occluded\n                audioSource.Volume *= 0.5f;\n            }\n        }\n    }\n}</code></pre>"},{"location":"guides/audio/spatial-audio/#distance-based-playback","title":"Distance-Based Playback","text":"<p>Only play sounds when listener is in range:</p> <pre><code>public void UpdateAudioSources(GameTime gameTime)\n{\n    var listenerPos = _listener.GetComponent&lt;TransformComponent&gt;().Position;\n\n    foreach (var entity in _audioSources)\n    {\n        var audio = entity.GetComponent&lt;AudioSourceComponent&gt;();\n        var transform = entity.GetComponent&lt;TransformComponent&gt;();\n\n        var distance = Vector2.Distance(transform.Position, listenerPos);\n\n        // Enable/disable based on max distance\n        if (distance &gt; audio.MaxDistance * 1.2f)  // 20% buffer\n        {\n            // Too far, stop playing to save CPU\n            audio.IsEnabled = false;\n        }\n        else if (distance &lt; audio.MaxDistance)\n        {\n            // In range, ensure playing\n            audio.IsEnabled = true;\n        }\n    }\n}</code></pre>"},{"location":"guides/audio/spatial-audio/#priority-system","title":"Priority System","text":"<p>Limit concurrent sounds with priority:</p> <pre><code>public class AudioPriorityComponent : Component\n{\n    public int Priority { get; set; } = 0;  // Higher = more important\n}\n\npublic class AudioPrioritySystem : IUpdateSystem\n{\n    private const int MaxConcurrentSounds = 32;\n\n    public void Update(GameTime gameTime)\n    {\n        var sources = _world.GetEntitiesWithComponent&lt;AudioSourceComponent&gt;()\n            .Where(e =&gt; e.GetComponent&lt;AudioSourceComponent&gt;().IsPlaying)\n            .OrderByDescending(e =&gt; e.GetComponent&lt;AudioPriorityComponent&gt;()?.Priority ?? 0)\n            .ToList();\n\n        // Disable low-priority sounds if over limit\n        for (int i = MaxConcurrentSounds; i &lt; sources.Count; i++)\n        {\n            sources[i].GetComponent&lt;AudioSourceComponent&gt;().IsEnabled = false;\n        }\n    }\n}</code></pre>"},{"location":"guides/audio/spatial-audio/#performance-optimization","title":"Performance Optimization","text":""},{"location":"guides/audio/spatial-audio/#update-frequency","title":"Update Frequency","text":"<p>Spatial audio updates every frame, but you can reduce frequency for distant sources:</p> <pre><code>public class OptimizedAudioSystem : IUpdateSystem\n{\n    private float _updateTimer = 0f;\n    private const float DistantUpdateInterval = 0.1f;  // 10 updates/second\n\n    public void Update(GameTime gameTime)\n    {\n        _updateTimer += (float)gameTime.DeltaTime;\n\n        var listener = FindListener();\n        var listenerPos = listener.GetComponent&lt;TransformComponent&gt;().Position;\n\n        foreach (var entity in _audioSources)\n        {\n            var audio = entity.GetComponent&lt;AudioSourceComponent&gt;();\n            var sourcePos = entity.GetComponent&lt;TransformComponent&gt;().Position;\n            var distance = Vector2.Distance(sourcePos, listenerPos);\n\n            // Update near sources every frame\n            if (distance &lt; audio.MaxDistance * 0.5f)\n            {\n                UpdateSpatialAudio(audio, entity, listener);\n            }\n            // Update distant sources less frequently\n            else if (_updateTimer &gt;= DistantUpdateInterval)\n            {\n                UpdateSpatialAudio(audio, entity, listener);\n            }\n        }\n\n        if (_updateTimer &gt;= DistantUpdateInterval)\n        {\n            _updateTimer = 0f;\n        }\n    }\n}</code></pre>"},{"location":"guides/audio/spatial-audio/#culling-distant-sources","title":"Culling Distant Sources","text":"<p>Disable sources beyond a threshold:</p> <pre><code>// In AudioSourceComponent configuration\naudioSource.MaxDistance = 500f;  // Audible range\n\n// Disable if beyond 1.5x max distance\nvar cullDistance = audioSource.MaxDistance * 1.5f;\nif (distance &gt; cullDistance)\n{\n    audioSource.IsEnabled = false;\n}</code></pre>"},{"location":"guides/audio/spatial-audio/#spatial-audio-overhead","title":"Spatial Audio Overhead","text":"<p>Typical performance impact:</p> Source Count Update Time Impact on 60 FPS 10 sources 0.05ms Negligible 50 sources 0.2ms &lt; 2% 100 sources 0.4ms &lt; 3% <p>Optimization Tips: - Disable <code>EnableSpatialAudio</code> for non-positional sounds (music, UI) - Use larger <code>MinDistance</code> to reduce calculations in crowded areas - Set <code>SpatialBlend = 0</code> for ambient sounds that don't need panning - Cull or disable distant sources beyond hearing range</p>"},{"location":"guides/audio/spatial-audio/#best-practices","title":"Best Practices","text":""},{"location":"guides/audio/spatial-audio/#do","title":"Do","text":"<ul> <li>Use spatial audio for diegetic sounds - In-world sounds (enemies, pickups, effects)</li> <li>Disable for non-diegetic sounds - UI, music, narration</li> <li>Match distances to game scale - Larger worlds need larger distances</li> <li>Test with headphones - Stereo panning is clearest with headphones</li> <li>Use appropriate falloff curves - Linear for most cases, quadratic for dramatic effects</li> <li>Set reasonable volume levels - Spatial audio multiplies base volume</li> </ul>"},{"location":"guides/audio/spatial-audio/#dont","title":"Don't","text":"<ul> <li>Enable spatial audio globally - Only for positioned sounds</li> <li>Use tiny MinDistance values - Causes abrupt volume changes</li> <li>Use huge MaxDistance values - Wastes CPU on inaudible sounds</li> <li>Forget to set SpatialBlend - Defaults to 0 (mono)</li> <li>Overlap too many sources - Can cause audio mud</li> </ul>"},{"location":"guides/audio/spatial-audio/#distance-guidelines","title":"Distance Guidelines","text":"<pre><code>// Small game world (platformer, puzzle)\naudioSource.MinDistance = 50f;\naudioSource.MaxDistance = 300f;\n\n// Medium game world (top-down adventure)\naudioSource.MinDistance = 100f;\naudioSource.MaxDistance = 600f;\n\n// Large game world (open-world, RTS)\naudioSource.MinDistance = 200f;\naudioSource.MaxDistance = 1200f;</code></pre>"},{"location":"guides/audio/spatial-audio/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guides/audio/spatial-audio/#no-spatial-audio","title":"No Spatial Audio","text":"<p>Problem: Sounds don't fade or pan.</p> <p>Solutions:</p> <pre><code>// 1. Ensure AudioSystem is registered\nbuilder.Services.ConfigureSystemPipelines(pipelines =&gt;\n{\n    pipelines.AddSystem&lt;AudioSystem&gt;();\n});\n\n// 2. Enable spatial audio on source\naudioSource.EnableSpatialAudio = true;\n\n// 3. Set non-zero SpatialBlend for panning\naudioSource.SpatialBlend = 1.0f;\n\n// 4. Ensure listener exists and is enabled\nvar listener = player.AddComponent&lt;AudioListenerComponent&gt;();\nlistener.IsEnabled = true;</code></pre>"},{"location":"guides/audio/spatial-audio/#sounds-cut-off-abruptly","title":"Sounds Cut Off Abruptly","text":"<p>Problem: Audio stops suddenly instead of fading.</p> <p>Solution: Increase MaxDistance:</p> <pre><code>// Before (too small)\naudioSource.MaxDistance = 100f;  // Abrupt cutoff\n\n// After (smooth fade)\naudioSource.MaxDistance = 400f;  // Gradual fade</code></pre>"},{"location":"guides/audio/spatial-audio/#sounds-too-quiet","title":"Sounds Too Quiet","text":"<p>Problem: All spatial audio is barely audible.</p> <p>Solution: Check listener global volume:</p> <pre><code>// Ensure listener volume is reasonable\nlistener.GlobalSpatialVolume = 1.0f;  // Full volume\n\n// Or boost individual sources\naudioSource.Volume = 0.8f;  // Louder base volume</code></pre>"},{"location":"guides/audio/spatial-audio/#panning-feels-wrong","title":"Panning Feels Wrong","text":"<p>Problem: Sounds pan opposite to expected direction.</p> <p>Solution: Verify coordinate system:</p> <pre><code>// Brine2D uses:\n// X+ = Right, Y+ = Down\n\n// Sound to the right of listener should pan right\nif (sourcePos.X &gt; listenerPos.X)\n{\n    // Expected: pan &gt; 0 (right)\n    Logger.LogInfo($\"Pan: {audioSource.SpatialPan}\");\n}</code></pre>"},{"location":"guides/audio/spatial-audio/#too-many-audio-sources","title":"Too Many Audio Sources","text":"<p>Problem: Performance degrades with many sources.</p> <p>Solution: Implement culling:</p> <pre><code>// Disable sources beyond hearing range\nif (distance &gt; audioSource.MaxDistance * 1.2f)\n{\n    audioSource.IsEnabled = false;\n}\n\n// Or use priority system to limit concurrent sounds\nLimitConcurrentSounds(maxCount: 32);</code></pre>"},{"location":"guides/audio/spatial-audio/#see-also","title":"See Also","text":"<ul> <li>Sound Effects - Basic sound playback</li> <li>Music Playback - Background music</li> <li>Audio System - ECS audio processing</li> <li>Components - Audio component reference</li> </ul> <p>Next Steps: - Add AudioListenerComponent to your player - Create spatial audio sources for enemies and pickups - Experiment with different falloff curves - Test with headphones for best stereo effect</p>"},{"location":"guides/ecs/components/","title":"ECS Components","text":"<p>Components are the building blocks of Brine2D's Entity Component System. Unlike pure data-oriented ECS frameworks, Brine2D uses a hybrid approach where components can contain both data and logic, giving you flexibility for typical game development with optional performance optimization through systems.</p>"},{"location":"guides/ecs/components/#what-are-components","title":"What Are Components?","text":"<p>Components are classes that inherit from <code>Component</code> and represent characteristics, behaviors, or attributes of entities. They can hold state AND logic.</p> <pre><code>using Brine2D.Core;\nusing Brine2D.ECS;\nusing System.Numerics;\n\n// \u2705 Simple data component\npublic class TransformComponent : Component\n{\n    public Vector2 Position { get; set; }\n    public float Rotation { get; set; }\n    public Vector2 Scale { get; set; } = Vector2.One;\n}\n\n// \u2705 Component with logic (perfectly fine!)\npublic class LifetimeComponent : Component\n{\n    public float Lifetime { get; set; }\n    public bool AutoDestroy { get; set; } = true;\n\n    protected internal override void OnUpdate(GameTime gameTime)\n    {\n        if (!IsEnabled) return;\n\n        Lifetime -= (float)gameTime.DeltaTime;\n\n        if (Lifetime &lt;= 0 &amp;&amp; AutoDestroy)\n        {\n            Entity?.Destroy();\n        }\n    }\n}</code></pre> <p>Key principle: Components can be simple data containers or self-contained behaviors - use what makes sense for your game!</p>"},{"location":"guides/ecs/components/#basic-component-structure","title":"Basic Component Structure","text":""},{"location":"guides/ecs/components/#minimal-component","title":"Minimal Component","text":"<p>The simplest component inherits from <code>Component</code>:</p> <pre><code>using Brine2D.ECS;\n\npublic class HealthComponent : Component\n{\n    public float Current { get; set; }\n    public float Max { get; set; }\n\n    public float Percentage =&gt; Current / Max;\n    public bool IsDead =&gt; Current &lt;= 0;\n}</code></pre>"},{"location":"guides/ecs/components/#component-lifecycle","title":"Component Lifecycle","text":"<p>Components have several lifecycle hooks you can override:</p> <pre><code>public class MyComponent : Component\n{\n    protected internal override void OnAdded()\n    {\n        // Called when component is added to an entity\n        Logger.LogInformation(\"Component added!\");\n    }\n\n    protected internal override void OnRemoved()\n    {\n        // Called when component is removed\n        Logger.LogInformation(\"Component removed!\");\n    }\n\n    protected internal override void OnEnabled()\n    {\n        // Called when component is enabled\n        Logger.LogInformation(\"Component enabled!\");\n    }\n\n    protected internal override void OnDisabled()\n    {\n        // Called when component is disabled\n        Logger.LogInformation(\"Component disabled!\");\n    }\n\n    protected internal override void OnUpdate(GameTime gameTime)\n    {\n        // Called every frame if enabled\n        // Your logic here!\n    }\n}</code></pre>"},{"location":"guides/ecs/components/#using-components","title":"Using Components","text":"<pre><code>// Add component\nvar health = entity.AddComponent&lt;HealthComponent&gt;();\nhealth.Current = 100;\nhealth.Max = 100;\n\n// Get component\nvar health = entity.GetComponent&lt;HealthComponent&gt;();\nif (health != null)\n{\n    Console.WriteLine($\"Health: {health.Current}/{health.Max}\");\n}\n\n// Check if entity has component\nif (entity.HasComponent&lt;HealthComponent&gt;())\n{\n    // ...\n}\n\n// Remove component\nentity.RemoveComponent&lt;HealthComponent&gt;();\n\n// Enable/disable component\nhealth.IsEnabled = false; // Component won't update\nhealth.IsEnabled = true;  // Component resumes updating</code></pre>"},{"location":"guides/ecs/components/#component-types","title":"Component Types","text":""},{"location":"guides/ecs/components/#data-only-components","title":"Data-Only Components","text":"<p>Purpose: Store state with no logic (processed by systems)</p> <pre><code>// Simple position/rotation\npublic class TransformComponent : Component\n{\n    public Vector2 Position { get; set; }\n    public float Rotation { get; set; }\n    public Vector2 Scale { get; set; } = Vector2.One;\n}\n\n// Movement velocity\npublic class VelocityComponent : Component\n{\n    public Vector2 Velocity { get; set; }\n    public float MaxSpeed { get; set; }\n    public float Friction { get; set; }\n\n    public void SetDirection(Vector2 direction, float speed)\n    {\n        Velocity = direction * speed;\n    }\n}\n\n// Sprite rendering data\npublic class SpriteComponent : Component\n{\n    public string TexturePath { get; set; } = string.Empty;\n    public Color Tint { get; set; } = Color.White;\n    public Vector2 Origin { get; set; } = Vector2.Zero;\n}</code></pre> <p>When to use: When you want systems to process multiple entities efficiently.</p>"},{"location":"guides/ecs/components/#behavior-components","title":"Behavior Components","text":"<p>Purpose: Self-contained logic that updates every frame</p> <pre><code>// Timer that fires events\npublic class TimerComponent : Component\n{\n    public float Duration { get; set; }\n    public float Elapsed { get; private set; }\n    public bool IsComplete { get; private set; }\n\n    public event Action? OnComplete;\n\n    protected internal override void OnUpdate(GameTime gameTime)\n    {\n        if (!IsEnabled || IsComplete) return;\n\n        Elapsed += (float)gameTime.DeltaTime;\n\n        if (Elapsed &gt;= Duration)\n        {\n            IsComplete = true;\n            OnComplete?.Invoke();\n        }\n    }\n}\n\n// Auto-destroy after time\npublic class LifetimeComponent : Component\n{\n    public float Lifetime { get; set; }\n    public bool AutoDestroy { get; set; } = true;\n\n    protected internal override void OnUpdate(GameTime gameTime)\n    {\n        if (!IsEnabled) return;\n\n        Lifetime -= (float)gameTime.DeltaTime;\n\n        if (Lifetime &lt;= 0 &amp;&amp; AutoDestroy)\n        {\n            Entity?.Destroy();\n        }\n    }\n}\n\n// Follow another entity\npublic class FollowComponent : Component\n{\n    public Entity? Target { get; set; }\n    public float Speed { get; set; } = 5f;\n    public float MinDistance { get; set; } = 10f;\n\n    protected internal override void OnUpdate(GameTime gameTime)\n    {\n        if (!IsEnabled || Target == null) return;\n\n        var myTransform = Entity?.GetComponent&lt;TransformComponent&gt;();\n        var targetTransform = Target.GetComponent&lt;TransformComponent&gt;();\n\n        if (myTransform == null || targetTransform == null) return;\n\n        var direction = targetTransform.Position - myTransform.Position;\n        var distance = direction.Length();\n\n        if (distance &gt; MinDistance)\n        {\n            direction = Vector2.Normalize(direction);\n            myTransform.Position += direction * Speed * (float)gameTime.DeltaTime;\n        }\n    }\n}</code></pre> <p>When to use: For simple, self-contained behaviors that don't need optimization.</p>"},{"location":"guides/ecs/components/#controller-components","title":"Controller Components","text":"<p>Purpose: Handle input or AI for entities</p> <pre><code>// Player input controller\npublic class PlayerControllerComponent : Component\n{\n    public float MoveSpeed { get; set; } = 200f;\n    public InputMode InputMode { get; set; } = InputMode.Keyboard;\n    public int GamepadIndex { get; set; } = 0;\n    public bool NormalizeDiagonals { get; set; } = true;\n\n    public Vector2 InputDirection { get; set; }\n\n    // Logic is in PlayerControllerSystem for performance\n}\n\n// AI controller\npublic class AIControllerComponent : Component\n{\n    public AIBehavior Behavior { get; set; }\n    public float MoveSpeed { get; set; } = 100f;\n    public string TargetTag { get; set; } = \"Player\";\n    public float DetectionRange { get; set; } = 300f;\n    public float StopDistance { get; set; } = 50f;\n\n    // Logic is in AISystem for performance\n}\n\npublic enum AIBehavior\n{\n    Idle,\n    Patrol,\n    Chase,\n    Flee,\n    Attack\n}</code></pre> <p>When to use: When you need systems to process many entities efficiently (pathfinding, AI, etc.).</p>"},{"location":"guides/ecs/components/#reference-components","title":"Reference Components","text":"<p>Purpose: Hold references to external objects or other entities</p> <pre><code>// Camera follow\npublic class CameraFollowComponent : Component\n{\n    public string CameraName { get; set; } = \"main\";\n    public float Smoothing { get; set; } = 5f;\n    public Vector2 Offset { get; set; }\n}\n\n// Collision detection\npublic class ColliderComponent : Component\n{\n    public ICollider? Shape { get; set; }\n    public bool IsTrigger { get; set; }\n}\n\n// Audio source\npublic class AudioSourceComponent : Component\n{\n    public ISoundEffect? SoundEffect { get; set; }\n    public IMusic? Music { get; set; }\n    public float Volume { get; set; } = 1.0f;\n    public int LoopCount { get; set; } = 0;\n    public bool PlayOnEnable { get; set; }\n\n    public bool TriggerPlay { get; set; }\n    public bool TriggerStop { get; set; }\n    public bool IsPlaying { get; set; }\n}</code></pre>"},{"location":"guides/ecs/components/#when-to-use-components-vs-systems","title":"When to Use Components vs Systems","text":""},{"location":"guides/ecs/components/#use-component-logic-when","title":"Use Component Logic When:","text":"<ul> <li>\u2705 Behavior is simple and self-contained</li> <li>\u2705 Only a few entities have this component</li> <li>\u2705 Logic is unique to each entity (timers, follow targets)</li> <li>\u2705 You want quick prototyping without creating systems</li> </ul> <pre><code>// Perfect for component logic\npublic class RotateComponent : Component\n{\n    public float Speed { get; set; } = 1f;\n\n    protected internal override void OnUpdate(GameTime gameTime)\n    {\n        var transform = Entity?.GetComponent&lt;TransformComponent&gt;();\n        if (transform != null)\n        {\n            transform.Rotation += Speed * (float)gameTime.DeltaTime;\n        }\n    }\n}</code></pre>"},{"location":"guides/ecs/components/#use-systems-when","title":"Use Systems When:","text":"<ul> <li>\u2705 Many entities (10+) need the same processing</li> <li>\u2705 Logic can be batched for performance</li> <li>\u2705 Complex queries across multiple entities</li> <li>\u2705 You need specific execution order</li> </ul> <pre><code>// Better as a system for performance\npublic class VelocitySystem : IUpdateSystem\n{\n    private readonly IEntityWorld _world;\n    public int UpdateOrder =&gt; 100;\n\n    public void Update(GameTime gameTime)\n    {\n        var deltaTime = (float)gameTime.DeltaTime;\n\n        // Process ALL entities with Transform + Velocity efficiently\n        var entities = _world.GetEntitiesWithComponents&lt;TransformComponent, VelocityComponent&gt;();\n\n        foreach (var entity in entities)\n        {\n            var transform = entity.GetComponent&lt;TransformComponent&gt;()!;\n            var velocity = entity.GetComponent&lt;VelocityComponent&gt;()!;\n\n            transform.Position += velocity.Velocity * deltaTime;\n        }\n    }\n}</code></pre>"},{"location":"guides/ecs/components/#design-patterns","title":"Design Patterns","text":""},{"location":"guides/ecs/components/#composition-over-inheritance","title":"Composition Over Inheritance","text":"<p>Combine components for flexible behavior:</p> <pre><code>// Create a player\nvar player = world.CreateEntity(\"Player\");\nplayer.AddComponent&lt;TransformComponent&gt;();\nplayer.AddComponent&lt;SpriteComponent&gt;();\nplayer.AddComponent&lt;PlayerControllerComponent&gt;();\nplayer.AddComponent&lt;HealthComponent&gt;();\n\n// Create a flying enemy\nvar flyingEnemy = world.CreateEntity(\"FlyingEnemy\");\nflyingEnemy.AddComponent&lt;TransformComponent&gt;();\nflyingEnemy.AddComponent&lt;SpriteComponent&gt;();\nflyingEnemy.AddComponent&lt;AIControllerComponent&gt;();\nflyingEnemy.AddComponent&lt;HealthComponent&gt;();\nflyingEnemy.AddComponent&lt;FlyingMovementComponent&gt;();\n\n// Create a boss (reuse + extend)\nvar boss = world.CreateEntity(\"Boss\");\nboss.AddComponent&lt;TransformComponent&gt;();\nboss.AddComponent&lt;SpriteComponent&gt;();\nboss.AddComponent&lt;AIControllerComponent&gt;();\nboss.AddComponent&lt;HealthComponent&gt;();\nboss.AddComponent&lt;FlyingMovementComponent&gt;();\nboss.AddComponent&lt;BossAbilitiesComponent&gt;(); // Unique behavior</code></pre>"},{"location":"guides/ecs/components/#component-communication","title":"Component Communication","text":"<p>Components can interact with each other:</p> <pre><code>public class DamageOnContactComponent : Component\n{\n    public float Damage { get; set; } = 10f;\n    public string TargetTag { get; set; } = \"Player\";\n\n    protected internal override void OnUpdate(GameTime gameTime)\n    {\n        if (!IsEnabled) return;\n\n        var collider = Entity?.GetComponent&lt;ColliderComponent&gt;();\n        if (collider == null) return;\n\n        // Check collision (simplified)\n        foreach (var other in GetNearbyEntities())\n        {\n            if (other.Tags.Contains(TargetTag))\n            {\n                var health = other.GetComponent&lt;HealthComponent&gt;();\n                if (health != null)\n                {\n                    health.Current -= Damage;\n                }\n            }\n        }\n    }\n}</code></pre>"},{"location":"guides/ecs/components/#using-events","title":"Using Events","text":"<p>Components can fire events:</p> <pre><code>public class HealthComponent : Component\n{\n    private float _current;\n\n    public float Current\n    {\n        get =&gt; _current;\n        set\n        {\n            var oldValue = _current;\n            _current = value;\n\n            if (_current &lt;= 0 &amp;&amp; oldValue &gt; 0)\n            {\n                OnDeath?.Invoke();\n            }\n        }\n    }\n\n    public float Max { get; set; }\n\n    public event Action? OnDeath;\n    public event Action&lt;float&gt;? OnDamageTaken;\n\n    public void TakeDamage(float amount)\n    {\n        Current -= amount;\n        OnDamageTaken?.Invoke(amount);\n    }\n}\n\n// Subscribe to events\nvar health = entity.GetComponent&lt;HealthComponent&gt;();\nhealth.OnDeath += () =&gt; Logger.LogInformation(\"Entity died!\");\nhealth.OnDamageTaken += (amount) =&gt; Logger.LogInformation($\"Took {amount} damage!\");</code></pre>"},{"location":"guides/ecs/components/#built-in-components","title":"Built-in Components","text":"<p>Brine2D provides several utility components:</p>"},{"location":"guides/ecs/components/#transformcomponent","title":"TransformComponent","text":"<pre><code>var transform = entity.AddComponent&lt;TransformComponent&gt;();\ntransform.Position = new Vector2(100, 200);\ntransform.Rotation = MathF.PI / 4; // 45 degrees\ntransform.Scale = new Vector2(2, 2); // 2x scale\n\n// Parent-child hierarchy\nchildEntity.SetParent(parentEntity);\nchildEntity.SetParent(null); // Unparent</code></pre>"},{"location":"guides/ecs/components/#timercomponent","title":"TimerComponent","text":"<pre><code>var timer = entity.AddComponent&lt;TimerComponent&gt;();\ntimer.Duration = 3f; // 3 seconds\ntimer.OnComplete += () =&gt; Logger.LogInformation(\"Timer finished!\");</code></pre>"},{"location":"guides/ecs/components/#lifetimecomponent","title":"LifetimeComponent","text":"<pre><code>var lifetime = entity.AddComponent&lt;LifetimeComponent&gt;();\nlifetime.Lifetime = 5f; // Auto-destroy after 5 seconds\nlifetime.AutoDestroy = true;</code></pre>"},{"location":"guides/ecs/components/#tweencomponent","title":"TweenComponent","text":"<pre><code>var tween = entity.AddComponent&lt;TweenComponent&gt;();\ntween.Type = TweenType.Position;\ntween.StartPosition = new Vector2(0, 0);\ntween.EndPosition = new Vector2(100, 100);\ntween.Duration = 1f;\ntween.Easing = EasingType.EaseInOutQuad;\ntween.Loop = false;\ntween.PingPong = false;</code></pre>"},{"location":"guides/ecs/components/#velocitycomponent","title":"VelocityComponent","text":"<pre><code>var velocity = entity.AddComponent&lt;VelocityComponent&gt;();\nvelocity.MaxSpeed = 200f;\nvelocity.Friction = 5f;\nvelocity.SetDirection(Vector2.UnitX, 100f); // Move right at 100 pixels/sec</code></pre>"},{"location":"guides/ecs/components/#performance-considerations","title":"Performance Considerations","text":""},{"location":"guides/ecs/components/#component-updates","title":"Component Updates","text":"<p>Components update in the order they were added. If you have many entities:</p> <pre><code>// \u26a0\ufe0f Acceptable for &lt;50 entities\npublic class SimpleComponent : Component\n{\n    protected internal override void OnUpdate(GameTime gameTime)\n    {\n        // Simple logic here\n    }\n}\n\n// \u2705 Better for 50+ entities - use a system instead\npublic class OptimizedComponent : Component\n{\n    // Just data, no OnUpdate\n    public float Value { get; set; }\n}\n\npublic class OptimizedSystem : IUpdateSystem\n{\n    public int UpdateOrder =&gt; 100;\n\n    public void Update(GameTime gameTime)\n    {\n        // Batch process all entities\n        var entities = _world.GetEntitiesWithComponent&lt;OptimizedComponent&gt;();\n        foreach (var entity in entities)\n        {\n            // Process efficiently\n        }\n    }\n}</code></pre>"},{"location":"guides/ecs/components/#enabledisable-components","title":"Enable/Disable Components","text":"<p>Disable components to skip updates:</p> <pre><code>// Temporarily disable without removing\ncomponent.IsEnabled = false;\n\n// Re-enable later\ncomponent.IsEnabled = true;</code></pre>"},{"location":"guides/ecs/components/#testing-components","title":"Testing Components","text":"<p>Components are easy to test:</p> <pre><code>[Test]\npublic void Timer_CompletesAfterDuration()\n{\n    var entity = new Entity();\n    var timer = entity.AddComponent&lt;TimerComponent&gt;();\n    timer.Duration = 1f;\n\n    bool completed = false;\n    timer.OnComplete += () =&gt; completed = true;\n\n    // Simulate 1 second of updates\n    for (int i = 0; i &lt; 60; i++)\n    {\n        timer.OnUpdate(new GameTime(TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(1f/60f)));\n    }\n\n    Assert.IsTrue(completed);\n}\n\n[Test]\npublic void Lifetime_DestroysEntity()\n{\n    var world = new EntityWorld();\n    var entity = world.CreateEntity();\n\n    var lifetime = entity.AddComponent&lt;LifetimeComponent&gt;();\n    lifetime.Lifetime = 0.5f;\n    lifetime.AutoDestroy = true;\n\n    // Simulate time passing\n    lifetime.OnUpdate(new GameTime(TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(1)));\n\n    Assert.IsFalse(world.Entities.Contains(entity));\n}</code></pre>"},{"location":"guides/ecs/components/#quick-reference","title":"Quick Reference","text":""},{"location":"guides/ecs/components/#component-checklist","title":"Component Checklist","text":"<p>When designing a component, ask:</p> <ul> <li>\u2705 Is it a class inheriting from <code>Component</code>?</li> <li>\u2705 Does it represent one concept? (single responsibility)</li> <li>\u2705 Is the logic simple enough for <code>OnUpdate()</code>? (or should it be a system?)</li> <li>\u2705 Does it use lifecycle hooks appropriately?</li> <li>\u2705 Can it be tested easily?</li> </ul>"},{"location":"guides/ecs/components/#common-component-types","title":"Common Component Types","text":"Type Example Use Case Data-Only <code>TransformComponent</code> Processed by systems Behavior <code>LifetimeComponent</code> Self-contained logic Controller <code>PlayerControllerComponent</code> Input/AI (used by systems) Reference <code>AudioSourceComponent</code> External objects Utility <code>TimerComponent</code> Reusable helpers"},{"location":"guides/ecs/components/#next-steps","title":"Next Steps","text":"<p>Now that you understand components, learn how to process them efficiently:</p> <ul> <li> <p>Systems Guide</p> <p>Learn to create systems for performance-critical logic</p> <p> Systems Guide</p> </li> <li> <p>Entities Guide</p> <p>Master entity creation and management</p> <p> Entities Guide</p> </li> <li> <p>ECS Concepts</p> <p>Deeper dive into ECS architecture</p> <p> ECS Concepts</p> </li> </ul> <p>Remember: Brine2D's hybrid ECS gives you flexibility - use component logic for simplicity, systems for performance. Choose what fits your needs!</p>"},{"location":"guides/ecs/entities/","title":"ECS Entities","text":"<p>Entities are the fundamental building blocks of Brine2D's ECS. They're lightweight containers that hold components and represent game objects. Think of them as rows in a database or GameObjects in Unity, but simpler and more flexible.</p>"},{"location":"guides/ecs/entities/#what-are-entities","title":"What Are Entities?","text":"<p>Entities are containers with: - Unique ID (Guid) - Optional name (for debugging) - Tags (for grouping/querying) - Components (data and behavior) - Lifecycle state (active/inactive)</p> <pre><code>using Brine2D.ECS;\n\nvar player = world.CreateEntity(\"Player\");\n\nConsole.WriteLine(player.Id);       // Guid: \"123e4567-e89b-12d3...\"\nConsole.WriteLine(player.Name);     // \"Player\"\nConsole.WriteLine(player.IsActive); // true\nConsole.WriteLine(player.Tags);     // HashSet&lt;string&gt;</code></pre>"},{"location":"guides/ecs/entities/#creating-entities","title":"Creating Entities","text":""},{"location":"guides/ecs/entities/#basic-creation","title":"Basic Creation","text":"<pre><code>// Simple entity\nvar entity = world.CreateEntity();\n\n// Entity with name\nvar player = world.CreateEntity(\"Player\");\n\n// Add tags for grouping\nplayer.Tags.Add(\"Player\");\nplayer.Tags.Add(\"Controllable\");</code></pre>"},{"location":"guides/ecs/entities/#adding-components","title":"Adding Components","text":"<pre><code>// Method 1: Add and configure separately\nvar transform = player.AddComponent&lt;TransformComponent&gt;();\ntransform.Position = new Vector2(100, 200);\ntransform.Rotation = 0;\n\n// Method 2: Add and configure inline\nplayer.AddComponent&lt;VelocityComponent&gt;().MaxSpeed = 200f;\n\n// Method 3: Fluent syntax (chainable)\nvar enemy = world.CreateEntity(\"Enemy\")\n    .AddComponent&lt;TransformComponent&gt;()\n    .AddComponent&lt;VelocityComponent&gt;()\n    .AddComponent&lt;SpriteComponent&gt;()\n    .AddComponent&lt;HealthComponent&gt;();</code></pre>"},{"location":"guides/ecs/entities/#using-prefabs","title":"Using Prefabs","text":"<p>For reusable entity templates:</p> <pre><code>using Brine2D.ECS;\n\n// Create prefab\nvar bulletPrefab = new EntityPrefab(\"Bullet\");\nbulletPrefab.Tags.Add(\"Projectile\");\n\nbulletPrefab.AddComponent&lt;TransformComponent&gt;();\nbulletPrefab.AddComponent&lt;VelocityComponent&gt;(v =&gt; v.MaxSpeed = 500f);\nbulletPrefab.AddComponent&lt;SpriteComponent&gt;(s =&gt; s.TexturePath = \"assets/bullet.png\");\nbulletPrefab.AddComponent&lt;LifetimeComponent&gt;(l =&gt; l.Lifetime = 3f);\n\n// Register prefab\nprefabLibrary.Register(bulletPrefab);\n\n// Instantiate many times\nfor (int i = 0; i &lt; 10; i++)\n{\n    var bullet = bulletPrefab.Instantiate(world, new Vector2(i * 50, 100));\n}</code></pre>"},{"location":"guides/ecs/entities/#entity-lifecycle","title":"Entity Lifecycle","text":"<p>Entities have several states and lifecycle events:</p> <pre><code>stateDiagram-v2\n    [*] --&gt; Created: CreateEntity()\n    Created --&gt; Initialized: OnInitialize()\n    Initialized --&gt; Active: IsActive = true\n    Active --&gt; Inactive: IsActive = false\n    Inactive --&gt; Active: IsActive = true\n    Active --&gt; Destroyed: Destroy()\n    Inactive --&gt; Destroyed: Destroy()\n    Destroyed --&gt; [*]\n\n    Active --&gt; Active: OnUpdate() every frame</code></pre>"},{"location":"guides/ecs/entities/#lifecycle-methods","title":"Lifecycle Methods","text":"<pre><code>public class MyEntity : Entity\n{\n    protected internal override void OnInitialize()\n    {\n        // Called once when entity is created\n        // Set up initial state\n    }\n\n    protected internal override void OnUpdate(GameTime gameTime)\n    {\n        // Called every frame if entity is active\n        // Updates all enabled components\n    }\n\n    protected internal override void OnDestroy()\n    {\n        // Called when entity is destroyed\n        // Clean up resources\n    }\n}</code></pre>"},{"location":"guides/ecs/entities/#entity-events","title":"Entity Events","text":"<pre><code>var entity = world.CreateEntity(\"Player\");\n\n// Subscribe to entity events\nentity.OnComponentAdded += (e, component) =&gt;\n{\n    Logger.LogInformation($\"Added {component.GetType().Name}\");\n};\n\nentity.OnComponentRemoved += (e, component) =&gt;\n{\n    Logger.LogInformation($\"Removed {component.GetType().Name}\");\n};\n\nentity.OnDestroyed += (e) =&gt;\n{\n    Logger.LogInformation($\"Entity {e.Name} destroyed\");\n};</code></pre>"},{"location":"guides/ecs/entities/#managing-entities","title":"Managing Entities","text":""},{"location":"guides/ecs/entities/#activatingdeactivating","title":"Activating/Deactivating","text":"<pre><code>// Disable entity (stops updates, keeps in world)\nentity.IsActive = false;\n\n// Re-enable entity\nentity.IsActive = true;\n\n// Check state\nif (entity.IsActive)\n{\n    // Entity is updating\n}</code></pre> <p>When deactivated: - Entity remains in world - Components don't update - Still queryable - Still renders (unless system checks <code>IsActive</code>)</p>"},{"location":"guides/ecs/entities/#destroying-entities","title":"Destroying Entities","text":"<pre><code>// Method 1: Via entity\nentity.Destroy();\n\n// Method 2: Via world\nworld.DestroyEntity(entity);\n\n// Destruction:\n// - Fires OnDestroy event\n// - Calls OnRemoved on all components\n// - Removes from world\n// - Cannot be reused</code></pre>"},{"location":"guides/ecs/entities/#parent-child-relationships","title":"Parent-Child Relationships","text":"<pre><code>// Create parent\nvar player = world.CreateEntity(\"Player\");\nplayer.AddComponent&lt;TransformComponent&gt;();\n\n// Create child\nvar weapon = world.CreateEntity(\"Sword\");\nweapon.AddComponent&lt;TransformComponent&gt;();\n\n// Set parent (requires transform hierarchy)\nweapon.SetParent(player);\n\n// Unparent\nweapon.SetParent(null);\n\n// When parent is destroyed, children are also destroyed</code></pre>"},{"location":"guides/ecs/entities/#querying-entities","title":"Querying Entities","text":"<p>Brine2D provides several ways to find entities:</p>"},{"location":"guides/ecs/entities/#get-all-entities","title":"Get All Entities","text":"<pre><code>// Get all entities in world\nvar allEntities = world.Entities;\n\nforeach (var entity in allEntities)\n{\n    Console.WriteLine(entity.Name);\n}</code></pre>"},{"location":"guides/ecs/entities/#query-by-component","title":"Query by Component","text":"<pre><code>// Get entities with specific component\nvar withHealth = world.GetEntitiesWithComponent&lt;HealthComponent&gt;();\n\nforeach (var entity in withHealth)\n{\n    var health = entity.GetComponent&lt;HealthComponent&gt;()!;\n    Console.WriteLine($\"{entity.Name}: {health.Current}/{health.Max}\");\n}</code></pre>"},{"location":"guides/ecs/entities/#query-by-multiple-components","title":"Query by Multiple Components","text":"<pre><code>// Get entities with Transform AND Velocity\nvar moving = world.GetEntitiesWithComponents&lt;TransformComponent, VelocityComponent&gt;();\n\nforeach (var entity in moving)\n{\n    var transform = entity.GetComponent&lt;TransformComponent&gt;()!;\n    var velocity = entity.GetComponent&lt;VelocityComponent&gt;()!;\n\n    // Process moving entity\n}</code></pre>"},{"location":"guides/ecs/entities/#query-by-tag","title":"Query by Tag","text":"<pre><code>// Get all enemies\nvar enemies = world.GetEntitiesByTag(\"Enemy\");\n\n// Get entities with multiple tags (AND logic)\nvar bossEnemies = world.GetEntitiesByTag(\"Enemy\")\n    .Where(e =&gt; e.Tags.Contains(\"Boss\"));</code></pre>"},{"location":"guides/ecs/entities/#find-specific-entity","title":"Find Specific Entity","text":"<pre><code>// Find by name\nvar player = world.GetEntityByName(\"Player\");\n\n// Find by ID\nvar entity = world.GetEntityById(someGuid);\n\n// Find by predicate (custom logic)\nvar boss = world.FindEntity(e =&gt; \n    e.Tags.Contains(\"Enemy\") &amp;&amp; \n    e.Name.Contains(\"Boss\") &amp;&amp;\n    e.GetComponent&lt;HealthComponent&gt;()?.Max &gt; 500\n);</code></pre>"},{"location":"guides/ecs/entities/#entity-patterns","title":"Entity Patterns","text":""},{"location":"guides/ecs/entities/#factory-pattern","title":"Factory Pattern","text":"<p>Create entities through factory methods:</p> <pre><code>public class EntityFactory\n{\n    private readonly IEntityWorld _world;\n    private readonly ITextureLoader _textureLoader;\n\n    public EntityFactory(IEntityWorld world, ITextureLoader textureLoader)\n    {\n        _world = world;\n        _textureLoader = textureLoader;\n    }\n\n    public Entity CreatePlayer(Vector2 position)\n    {\n        var player = _world.CreateEntity(\"Player\");\n        player.Tags.Add(\"Player\");\n        player.Tags.Add(\"Controllable\");\n\n        player.AddComponent&lt;TransformComponent&gt;().Position = position;\n        player.AddComponent&lt;VelocityComponent&gt;().MaxSpeed = 200f;\n        player.AddComponent&lt;PlayerControllerComponent&gt;();\n        player.AddComponent&lt;HealthComponent&gt;().Max = 100;\n\n        var sprite = player.AddComponent&lt;SpriteComponent&gt;();\n        sprite.TexturePath = \"assets/player.png\";\n\n        return player;\n    }\n\n    public Entity CreateEnemy(Vector2 position, EnemyType type)\n    {\n        var enemy = _world.CreateEntity($\"Enemy_{type}\");\n        enemy.Tags.Add(\"Enemy\");\n\n        enemy.AddComponent&lt;TransformComponent&gt;().Position = position;\n        enemy.AddComponent&lt;VelocityComponent&gt;();\n        enemy.AddComponent&lt;AIControllerComponent&gt;().Behavior = AIBehavior.Chase;\n\n        switch (type)\n        {\n            case EnemyType.Weak:\n                enemy.AddComponent&lt;HealthComponent&gt;().Max = 30;\n                break;\n            case EnemyType.Strong:\n                enemy.AddComponent&lt;HealthComponent&gt;().Max = 100;\n                break;\n            case EnemyType.Boss:\n                enemy.AddComponent&lt;HealthComponent&gt;().Max = 500;\n                enemy.Tags.Add(\"Boss\");\n                break;\n        }\n\n        return enemy;\n    }\n\n    public Entity CreateBullet(Vector2 position, Vector2 direction)\n    {\n        var bullet = _world.CreateEntity(\"Bullet\");\n        bullet.Tags.Add(\"Projectile\");\n\n        bullet.AddComponent&lt;TransformComponent&gt;().Position = position;\n        bullet.AddComponent&lt;VelocityComponent&gt;().Velocity = direction * 500f;\n        bullet.AddComponent&lt;LifetimeComponent&gt;().Lifetime = 3f;\n\n        return bullet;\n    }\n}\n\npublic enum EnemyType\n{\n    Weak,\n    Strong,\n    Boss\n}</code></pre>"},{"location":"guides/ecs/entities/#builder-pattern","title":"Builder Pattern","text":"<p>Fluent API for entity construction:</p> <pre><code>public class EntityBuilder\n{\n    private readonly IEntityWorld _world;\n    private readonly Entity _entity;\n\n    public EntityBuilder(IEntityWorld world, string name = \"\")\n    {\n        _world = world;\n        _entity = world.CreateEntity(name);\n    }\n\n    public EntityBuilder WithTag(string tag)\n    {\n        _entity.Tags.Add(tag);\n        return this;\n    }\n\n    public EntityBuilder WithTransform(Vector2 position)\n    {\n        _entity.AddComponent&lt;TransformComponent&gt;().Position = position;\n        return this;\n    }\n\n    public EntityBuilder WithVelocity(float maxSpeed)\n    {\n        _entity.AddComponent&lt;VelocityComponent&gt;().MaxSpeed = maxSpeed;\n        return this;\n    }\n\n    public EntityBuilder WithSprite(string texturePath)\n    {\n        _entity.AddComponent&lt;SpriteComponent&gt;().TexturePath = texturePath;\n        return this;\n    }\n\n    public EntityBuilder WithHealth(float max)\n    {\n        var health = _entity.AddComponent&lt;HealthComponent&gt;();\n        health.Max = max;\n        health.Current = max;\n        return this;\n    }\n\n    public EntityBuilder WithComponent&lt;T&gt;() where T : Component, new()\n    {\n        _entity.AddComponent&lt;T&gt;();\n        return this;\n    }\n\n    public EntityBuilder WithComponent&lt;T&gt;(Action&lt;T&gt; configure) where T : Component, new()\n    {\n        var component = _entity.AddComponent&lt;T&gt;();\n        configure(component);\n        return this;\n    }\n\n    public Entity Build() =&gt; _entity;\n}\n\n// Usage\nvar player = new EntityBuilder(world, \"Player\")\n    .WithTag(\"Player\")\n    .WithTag(\"Controllable\")\n    .WithTransform(new Vector2(400, 300))\n    .WithVelocity(200f)\n    .WithSprite(\"assets/player.png\")\n    .WithHealth(100)\n    .WithComponent&lt;PlayerControllerComponent&gt;()\n    .Build();</code></pre>"},{"location":"guides/ecs/entities/#object-pool-pattern","title":"Object Pool Pattern","text":"<p>Reuse entities instead of creating/destroying:</p> <pre><code>public class EntityPool\n{\n    private readonly IEntityWorld _world;\n    private readonly Queue&lt;Entity&gt; _pool = new();\n    private readonly EntityPrefab _prefab;\n\n    public EntityPool(IEntityWorld world, EntityPrefab prefab, int initialSize = 10)\n    {\n        _world = world;\n        _prefab = prefab;\n\n        // Pre-create entities\n        for (int i = 0; i &lt; initialSize; i++)\n        {\n            var entity = prefab.Instantiate(world, Vector2.Zero);\n            entity.IsActive = false;\n            _pool.Enqueue(entity);\n        }\n    }\n\n    public Entity Spawn(Vector2 position)\n    {\n        Entity entity;\n\n        if (_pool.Count &gt; 0)\n        {\n            // Reuse from pool\n            entity = _pool.Dequeue();\n            entity.IsActive = true;\n        }\n        else\n        {\n            // Create new\n            entity = _prefab.Instantiate(_world, position);\n        }\n\n        // Reset position\n        var transform = entity.GetComponent&lt;TransformComponent&gt;();\n        if (transform != null)\n        {\n            transform.Position = position;\n        }\n\n        return entity;\n    }\n\n    public void Despawn(Entity entity)\n    {\n        // Reset state\n        var velocity = entity.GetComponent&lt;VelocityComponent&gt;();\n        if (velocity != null)\n        {\n            velocity.Velocity = Vector2.Zero;\n        }\n\n        // Deactivate and return to pool\n        entity.IsActive = false;\n        _pool.Enqueue(entity);\n    }\n}\n\n// Usage\nvar bulletPool = new EntityPool(world, bulletPrefab, 50);\n\n// Spawn bullet\nvar bullet = bulletPool.Spawn(playerPosition);\n\n// Later, despawn instead of destroy\nbulletPool.Despawn(bullet);</code></pre>"},{"location":"guides/ecs/entities/#entity-groups","title":"Entity Groups","text":"<p>Organize entities into logical groups:</p> <pre><code>public class EntityGroup\n{\n    private readonly HashSet&lt;Entity&gt; _entities = new();\n\n    public string Name { get; }\n    public IReadOnlyCollection&lt;Entity&gt; Entities =&gt; _entities;\n\n    public EntityGroup(string name)\n    {\n        Name = name;\n    }\n\n    public void Add(Entity entity)\n    {\n        _entities.Add(entity);\n        entity.OnDestroyed += OnEntityDestroyed;\n    }\n\n    public void Remove(Entity entity)\n    {\n        _entities.Remove(entity);\n        entity.OnDestroyed -= OnEntityDestroyed;\n    }\n\n    private void OnEntityDestroyed(Entity entity)\n    {\n        _entities.Remove(entity);\n    }\n\n    public void DestroyAll()\n    {\n        foreach (var entity in _entities.ToList())\n        {\n            entity.Destroy();\n        }\n        _entities.Clear();\n    }\n\n    public void SetActiveAll(bool active)\n    {\n        foreach (var entity in _entities)\n        {\n            entity.IsActive = active;\n        }\n    }\n}\n\n// Usage\nvar enemyGroup = new EntityGroup(\"Enemies\");\n\nfor (int i = 0; i &lt; 10; i++)\n{\n    var enemy = factory.CreateEnemy(randomPosition, EnemyType.Weak);\n    enemyGroup.Add(enemy);\n}\n\n// Later...\nenemyGroup.DestroyAll(); // Destroy all enemies at once</code></pre>"},{"location":"guides/ecs/entities/#advanced-querying","title":"Advanced Querying","text":""},{"location":"guides/ecs/entities/#filtering-queries","title":"Filtering Queries","text":"<pre><code>// Get all active enemies with low health\nvar weakEnemies = world.GetEntitiesByTag(\"Enemy\")\n    .Where(e =&gt; e.IsActive)\n    .Where(e =&gt;\n    {\n        var health = e.GetComponent&lt;HealthComponent&gt;();\n        return health != null &amp;&amp; health.Percentage &lt; 0.3f;\n    });\n\n// Get all projectiles moving right\nvar rightMoving = world.GetEntitiesWithComponents&lt;VelocityComponent&gt;()\n    .Where(e =&gt; e.Tags.Contains(\"Projectile\"))\n    .Where(e =&gt; e.GetComponent&lt;VelocityComponent&gt;()!.Velocity.X &gt; 0);</code></pre>"},{"location":"guides/ecs/entities/#spatial-queries","title":"Spatial Queries","text":"<pre><code>public static class EntityQueryExtensions\n{\n    public static IEnumerable&lt;Entity&gt; WithinRadius(\n        this IEnumerable&lt;Entity&gt; entities,\n        Vector2 center,\n        float radius)\n    {\n        var radiusSquared = radius * radius;\n\n        return entities.Where(e =&gt;\n        {\n            var transform = e.GetComponent&lt;TransformComponent&gt;();\n            if (transform == null) return false;\n\n            var distanceSquared = Vector2.DistanceSquared(transform.Position, center);\n            return distanceSquared &lt;= radiusSquared;\n        });\n    }\n\n    public static IEnumerable&lt;Entity&gt; InRectangle(\n        this IEnumerable&lt;Entity&gt; entities,\n        RectangleF bounds)\n    {\n        return entities.Where(e =&gt;\n        {\n            var transform = e.GetComponent&lt;TransformComponent&gt;();\n            return transform != null &amp;&amp; bounds.Contains(transform.Position);\n        });\n    }\n}\n\n// Usage\nvar nearbyEnemies = world.GetEntitiesByTag(\"Enemy\")\n    .WithinRadius(playerPosition, 200f);\n\nvar visibleEntities = world.GetEntitiesWithComponent&lt;SpriteComponent&gt;()\n    .InRectangle(cameraViewport);</code></pre>"},{"location":"guides/ecs/entities/#component-based-filtering","title":"Component-Based Filtering","text":"<pre><code>// Get entities that have Health AND Transform but NOT Dead tag\nvar aliveEntities = world.GetEntitiesWithComponents&lt;HealthComponent, TransformComponent&gt;()\n    .Where(e =&gt; !e.Tags.Contains(\"Dead\"));\n\n// Get entities with optional components\nvar entities = world.GetEntitiesWithComponent&lt;TransformComponent&gt;();\n\nforeach (var entity in entities)\n{\n    var transform = entity.GetComponent&lt;TransformComponent&gt;()!;\n    var velocity = entity.GetComponent&lt;VelocityComponent&gt;(); // Optional\n\n    if (velocity != null)\n    {\n        // Has velocity\n    }\n    else\n    {\n        // Stationary\n    }\n}</code></pre>"},{"location":"guides/ecs/entities/#performance-tips","title":"Performance Tips","text":""},{"location":"guides/ecs/entities/#query-caching","title":"Query Caching","text":"<p>Cache queries when possible:</p> <pre><code>public class EnemyManager\n{\n    private readonly IEntityWorld _world;\n    private List&lt;Entity&gt;? _cachedEnemies;\n    private bool _isDirty = true;\n\n    public EnemyManager(IEntityWorld world)\n    {\n        _world = world;\n\n        // Invalidate cache on entity changes\n        _world.OnEntityCreated += _ =&gt; _isDirty = true;\n        _world.OnEntityDestroyed += _ =&gt; _isDirty = true;\n    }\n\n    public IEnumerable&lt;Entity&gt; GetEnemies()\n    {\n        if (_isDirty || _cachedEnemies == null)\n        {\n            _cachedEnemies = _world.GetEntitiesByTag(\"Enemy\").ToList();\n            _isDirty = false;\n        }\n\n        return _cachedEnemies;\n    }\n}</code></pre>"},{"location":"guides/ecs/entities/#minimize-lookups","title":"Minimize Lookups","text":"<pre><code>// \u274c Slow - multiple component lookups\nforeach (var entity in entities)\n{\n    if (entity.HasComponent&lt;HealthComponent&gt;())\n    {\n        var health = entity.GetComponent&lt;HealthComponent&gt;();\n        var transform = entity.GetComponent&lt;TransformComponent&gt;();\n        // Process...\n    }\n}\n\n// \u2705 Fast - query for both components upfront\nvar entities = world.GetEntitiesWithComponents&lt;HealthComponent, TransformComponent&gt;();\n\nforeach (var entity in entities)\n{\n    var health = entity.GetComponent&lt;HealthComponent&gt;()!;\n    var transform = entity.GetComponent&lt;TransformComponent&gt;()!;\n    // Process...\n}</code></pre>"},{"location":"guides/ecs/entities/#use-tags-wisely","title":"Use Tags Wisely","text":"<p>Tags are faster than component checks:</p> <pre><code>// \u2705 Fast - tag check\nif (entity.Tags.Contains(\"Enemy\"))\n{\n    // ...\n}\n\n// \u26a0\ufe0f Slower - component check\nif (entity.HasComponent&lt;EnemyComponent&gt;())\n{\n    // ...\n}</code></pre>"},{"location":"guides/ecs/entities/#debugging-entities","title":"Debugging Entities","text":""},{"location":"guides/ecs/entities/#entity-inspector","title":"Entity Inspector","text":"<pre><code>public static class EntityDebugger\n{\n    public static void PrintEntity(Entity entity)\n    {\n        Console.WriteLine($\"=== Entity: {entity.Name} ===\");\n        Console.WriteLine($\"ID: {entity.Id}\");\n        Console.WriteLine($\"Active: {entity.IsActive}\");\n        Console.WriteLine($\"Tags: {string.Join(\", \", entity.Tags)}\");\n        Console.WriteLine(\"Components:\");\n\n        foreach (var component in entity.GetAllComponents())\n        {\n            var enabled = component.IsEnabled ? \"\u2713\" : \"\u2717\";\n            Console.WriteLine($\"  [{enabled}] {component.GetType().Name}\");\n        }\n    }\n\n    public static void PrintWorldStats(IEntityWorld world)\n    {\n        Console.WriteLine($\"=== World Statistics ===\");\n        Console.WriteLine($\"Total Entities: {world.Entities.Count}\");\n        Console.WriteLine($\"Active Entities: {world.Entities.Count(e =&gt; e.IsActive)}\");\n\n        // Count by tag\n        var tagCounts = world.Entities\n            .SelectMany(e =&gt; e.Tags)\n            .GroupBy(t =&gt; t)\n            .Select(g =&gt; new { Tag = g.Key, Count = g.Count() });\n\n        Console.WriteLine(\"Entities by Tag:\");\n        foreach (var tagCount in tagCounts)\n        {\n            Console.WriteLine($\"  {tagCount.Tag}: {tagCount.Count}\");\n        }\n    }\n}\n\n// Usage\nEntityDebugger.PrintEntity(player);\nEntityDebugger.PrintWorldStats(world);</code></pre>"},{"location":"guides/ecs/entities/#quick-reference","title":"Quick Reference","text":""},{"location":"guides/ecs/entities/#entity-creation","title":"Entity Creation","text":"<pre><code>var entity = world.CreateEntity(\"Name\");\nentity.Tags.Add(\"Tag\");\nentity.AddComponent&lt;MyComponent&gt;();</code></pre>"},{"location":"guides/ecs/entities/#entity-queries","title":"Entity Queries","text":"<pre><code>world.Entities                                    // All entities\nworld.GetEntityByName(\"Player\")                   // By name\nworld.GetEntityById(guid)                         // By ID\nworld.GetEntitiesByTag(\"Enemy\")                   // By tag\nworld.GetEntitiesWithComponent&lt;T&gt;()               // By component\nworld.GetEntitiesWithComponents&lt;T1, T2&gt;()         // By multiple\nworld.FindEntity(e =&gt; /* predicate */)            // By condition</code></pre>"},{"location":"guides/ecs/entities/#entity-management","title":"Entity Management","text":"<pre><code>entity.IsActive = false;                          // Deactivate\nentity.Destroy();                                 // Destroy\nworld.DestroyEntity(entity);                      // Destroy via world\nentity.OnDestroyed += handler;                    // Subscribe to events</code></pre>"},{"location":"guides/ecs/entities/#next-steps","title":"Next Steps","text":"<p>Now that you understand entities, explore related topics:</p> <ul> <li> <p>Components Guide</p> <p>Learn how to create and use components</p> <p> Components Guide</p> </li> <li> <p>Systems Guide</p> <p>Write systems that process entities efficiently</p> <p> Systems Guide</p> </li> <li> <p>ECS Concepts</p> <p>Understand the big picture</p> <p> ECS Concepts</p> </li> </ul> <p>Remember: Entities are simple containers. The real power comes from combining components to create complex behaviors through composition!</p>"},{"location":"guides/ecs/getting-started/","title":"Getting Started with ECS","text":"<p>Learn how to build games with Brine2D's hybrid Entity Component System (ECS) in this hands-on guide. We'll create a simple game with a player that can move around and collect coins.</p>"},{"location":"guides/ecs/getting-started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Completed the Quick Start guide</li> <li>Basic understanding of C# and .NET</li> <li>Brine2D installed (see Installation)</li> </ul> <p>Recommended: Read ECS Concepts first to understand the architecture.</p>"},{"location":"guides/ecs/getting-started/#what-youll-build","title":"What You'll Build","text":"<p>By the end of this guide, you'll have:</p> <ul> <li>\u2705 A player entity controlled with WASD</li> <li>\u2705 Collectible coin entities  </li> <li>\u2705 Score tracking</li> <li>\u2705 Simple rendering with automatic frame management</li> <li>\u2705 Automatic ECS system execution</li> <li>\u2705 Understanding of Brine2D's hybrid ECS</li> </ul> <p>Estimated time: 15-20 minutes</p>"},{"location":"guides/ecs/getting-started/#understanding-brine2ds-hybrid-ecs","title":"Understanding Brine2D's Hybrid ECS","text":"<p>Brine2D uses a hybrid object-based ECS that gives you flexibility:</p> <ul> <li>Components are classes (not structs) that can contain logic</li> <li>Components can self-update via <code>OnUpdate()</code> for simple behaviors</li> <li>Systems are optional - use them when you need performance for many entities</li> <li>Systems run automatically via lifecycle hooks</li> <li>Familiar object-oriented patterns - easier to learn than pure data-oriented ECS</li> </ul> <pre><code>// \u2705 Simple component with logic (perfectly fine!)\npublic class RotateComponent : Component\n{\n    public float Speed { get; set; } = 1f;\n\n    protected internal override void OnUpdate(GameTime gameTime)\n    {\n        var transform = Entity?.GetComponent&lt;TransformComponent&gt;();\n        if (transform != null)\n        {\n            transform.Rotation += Speed * (float)gameTime.DeltaTime;\n        }\n    }\n}\n\n// \u2705 Data-only component (processed by systems for performance)\npublic class VelocityComponent : Component\n{\n    public Vector2 Velocity { get; set; }\n    public float MaxSpeed { get; set; }\n}</code></pre>"},{"location":"guides/ecs/getting-started/#step-1-install-ecs-package","title":"Step 1: Install ECS Package","text":"<p>First, add the ECS package to your project:</p> <pre><code>dotnet add package Brine2D.ECS</code></pre> <p>Desktop Package Includes ECS</p> <p>If you installed <code>Brine2D.Desktop</code>, you already have ECS included!</p>"},{"location":"guides/ecs/getting-started/#step-2-define-components","title":"Step 2: Define Components","text":"<p>Components are classes that inherit from <code>Component</code>.</p> <p>Create a new file <code>Components.cs</code>:</p> <pre><code>using System.Numerics;\nusing Brine2D.Core;\nusing Brine2D.ECS;\n\n// Position in the world (data-only, processed by VelocitySystem)\npublic class TransformComponent : Component\n{\n    public Vector2 Position { get; set; }\n    public float Rotation { get; set; }\n    public Vector2 Scale { get; set; } = Vector2.One;\n}\n\n// Movement velocity (data-only, processed by VelocitySystem)\npublic class VelocityComponent : Component\n{\n    public Vector2 Velocity { get; set; }\n    public float MaxSpeed { get; set; } = 200f;\n    public float Friction { get; set; } = 5f;\n}\n\n// Input controller (data-only, processed by PlayerControllerSystem)\npublic class PlayerControllerComponent : Component\n{\n    public float MoveSpeed { get; set; } = 200f;\n    public Vector2 InputDirection { get; set; }\n}\n\n// Score tracking\npublic class ScoreComponent : Component\n{\n    public int Current { get; set; }\n}\n\n// Coin marker (we'll use this to identify coins)\npublic class CoinComponent : Component\n{\n    public int Value { get; set; } = 10;\n}\n\n// Auto-destroy after time (has logic!)\npublic class LifetimeComponent : Component\n{\n    public float Remaining { get; set; }\n\n    protected internal override void OnUpdate(GameTime gameTime)\n    {\n        if (!IsEnabled) return;\n\n        Remaining -= (float)gameTime.DeltaTime;\n\n        if (Remaining &lt;= 0)\n        {\n            Entity?.Destroy();\n        }\n    }\n}</code></pre> <p>Component Design Tips</p> <ul> <li>\u2705 Inherit from <code>Component</code> base class</li> <li>\u2705 Use properties for data</li> <li>\u2705 Override <code>OnUpdate()</code> for simple behaviors</li> <li>\u2705 Use systems for processing many entities efficiently</li> </ul>"},{"location":"guides/ecs/getting-started/#step-3-create-simple-game-logic","title":"Step 3: Create Simple Game Logic","text":"<p>For this tutorial, we'll use component logic for simplicity. In production, you'd use systems for better performance.</p> <p>Add player movement logic:</p> <pre><code>// Player input handling (self-contained component)\npublic class SimplePlayerController : Component\n{\n    public float MoveSpeed { get; set; } = 200f;\n    private IInputService? _input;\n\n    protected internal override void OnAdded()\n    {\n        // Get input service from DI\n        var world = Entity?.World;\n        if (world?.Services != null)\n        {\n            _input = world.Services.GetService(typeof(IInputService)) as IInputService;\n        }\n    }\n\n    protected internal override void OnUpdate(GameTime gameTime)\n    {\n        if (!IsEnabled || _input == null) return;\n\n        var transform = Entity?.GetComponent&lt;TransformComponent&gt;();\n        if (transform == null) return;\n\n        // Read input\n        var movement = Vector2.Zero;\n        if (_input.IsKeyDown(Keys.W)) movement.Y -= 1;\n        if (_input.IsKeyDown(Keys.S)) movement.Y += 1;\n        if (_input.IsKeyDown(Keys.A)) movement.X -= 1;\n        if (_input.IsKeyDown(Keys.D)) movement.X += 1;\n\n        // Apply movement\n        if (movement != Vector2.Zero)\n        {\n            movement = Vector2.Normalize(movement);\n            transform.Position += movement * MoveSpeed * (float)gameTime.DeltaTime;\n        }\n    }\n}\n\n// Coin collection logic\npublic class CoinCollectorComponent : Component\n{\n    public float CollectionRadius { get; set; } = 30f;\n\n    protected internal override void OnUpdate(GameTime gameTime)\n    {\n        if (!IsEnabled) return;\n\n        var myTransform = Entity?.GetComponent&lt;TransformComponent&gt;();\n        var myScore = Entity?.GetComponent&lt;ScoreComponent&gt;();\n\n        if (myTransform == null || myScore == null) return;\n\n        // Find all coins\n        var world = Entity?.World;\n        if (world == null) return;\n\n        var coins = world.GetEntitiesWithComponent&lt;CoinComponent&gt;();\n        var coinsToRemove = new List&lt;Entity&gt;();\n\n        foreach (var coin in coins)\n        {\n            var coinTransform = coin.GetComponent&lt;TransformComponent&gt;();\n            var coinComponent = coin.GetComponent&lt;CoinComponent&gt;();\n\n            if (coinTransform == null || coinComponent == null) continue;\n\n            // Check distance\n            var distance = Vector2.Distance(myTransform.Position, coinTransform.Position);\n\n            if (distance &lt; CollectionRadius)\n            {\n                myScore.Current += coinComponent.Value;\n                coinsToRemove.Add(coin);\n            }\n        }\n\n        // Remove collected coins\n        foreach (var coin in coinsToRemove)\n        {\n            world.DestroyEntity(coin);\n        }\n    }\n}</code></pre>"},{"location":"guides/ecs/getting-started/#step-4-create-the-game-scene","title":"Step 4: Create the Game Scene","text":"<p>Now let's put it all together in a scene with automatic execution:</p> <pre><code>using Brine2D.Core;\nusing Brine2D.ECS;\nusing Brine2D.Input;\nusing Brine2D.Rendering;\nusing Microsoft.Extensions.Logging;\nusing System.Numerics;\n\npublic class ECSGameScene : Scene\n{\n    private readonly IRenderer _renderer;\n    private readonly IInputService _input;\n    private readonly IGameContext _gameContext;\n    private readonly IEntityWorld _world;\n\n    private Entity? _player;\n\n    public ECSGameScene(\n        IRenderer renderer,\n        IInputService input,\n        IGameContext gameContext,\n        IEntityWorld world,\n        ILogger&lt;ECSGameScene&gt; logger\n    ) : base(logger)\n    {\n        _renderer = renderer;\n        _input = input;\n        _gameContext = gameContext;\n        _world = world;\n    }\n\n    protected override void OnInitialize()\n    {\n        Logger.LogInformation(\"Initializing ECS Game\");\n\n        // Create player\n        _player = _world.CreateEntity(\"Player\");\n        _player.Tags.Add(\"Player\");\n\n        var playerTransform = _player.AddComponent&lt;TransformComponent&gt;();\n        playerTransform.Position = new Vector2(400, 300);\n\n        _player.AddComponent&lt;SimplePlayerController&gt;().MoveSpeed = 200f;\n        _player.AddComponent&lt;CoinCollectorComponent&gt;();\n        _player.AddComponent&lt;ScoreComponent&gt;();\n\n        Logger.LogInformation(\"Player created\");\n\n        // Create coins in a grid\n        for (int x = 0; x &lt; 5; x++)\n        {\n            for (int y = 0; y &lt; 4; y++)\n            {\n                var coin = _world.CreateEntity($\"Coin_{x}_{y}\");\n                coin.Tags.Add(\"Coin\");\n\n                var coinTransform = coin.AddComponent&lt;TransformComponent&gt;();\n                coinTransform.Position = new Vector2(\n                    100 + x * 150,\n                    100 + y * 120\n                );\n\n                var coinComponent = coin.AddComponent&lt;CoinComponent&gt;();\n                coinComponent.Value = 10;\n            }\n        }\n\n        Logger.LogInformation(\"Created 20 coins\");\n    }\n\n    protected override void OnUpdate(GameTime gameTime)\n    {\n        // Check for quit\n        if (_input.IsKeyPressed(Keys.Escape))\n        {\n            _gameContext.RequestExit();\n        }\n\n        // NO MANUAL CALLS NEEDED!\n        // Component logic (SimplePlayerController, CoinCollectorComponent) \n        // runs automatically via lifecycle hooks!\n    }\n\n    protected override void OnRender(GameTime gameTime)\n    {\n        // Just draw - no Clear/BeginFrame/EndFrame needed\n\n        // Render player\n        if (_player != null)\n        {\n            var transform = _player.GetComponent&lt;TransformComponent&gt;();\n            if (transform != null)\n            {\n                _renderer.DrawCircleFilled(\n                    transform.Position.X,\n                    transform.Position.Y,\n                    16,\n                    Color.Green\n                );\n            }\n        }\n\n        // Render coins\n        var coins = _world.GetEntitiesWithComponent&lt;CoinComponent&gt;();\n        foreach (var coin in coins)\n        {\n            var transform = coin.GetComponent&lt;TransformComponent&gt;();\n            if (transform != null)\n            {\n                _renderer.DrawCircleFilled(\n                    transform.Position.X,\n                    transform.Position.Y,\n                    8,\n                    Color.Yellow\n                );\n            }\n        }\n\n        // Draw score\n        var score = _player?.GetComponent&lt;ScoreComponent&gt;();\n        if (score != null)\n        {\n            _renderer.DrawText($\"Score: {score.Current}\", 10, 10, Color.White);\n            _renderer.DrawText(\"WASD to move, ESC to quit\", 10, 30, Color.Gray);\n        }\n    }\n}</code></pre> <p> Notice: Clean &amp; Simple!</p> <p>The scene is incredibly clean:</p> <ul> <li>No manual <code>_world.Update()</code> call - runs automatically!</li> <li>No manual <code>Clear()</code>, <code>BeginFrame()</code>, <code>EndFrame()</code> - automatic!</li> <li>Component <code>OnUpdate()</code> methods run automatically</li> <li>Just focus on your game logic!</li> </ul>"},{"location":"guides/ecs/getting-started/#step-5-register-ecs-and-run","title":"Step 5: Register ECS and Run","text":"<p>Update your <code>Program.cs</code>:</p> <pre><code>using Brine2D.ECS;\nusing Brine2D.Hosting;\nusing Brine2D.Input.SDL;\nusing Brine2D.Rendering.SDL;\n\nvar builder = GameApplication.CreateBuilder(args);\n\n// Configure rendering\nbuilder.Services.AddSDL3Rendering(options =&gt;\n{\n    options.WindowTitle = \"ECS Game - Coin Collector\";\n    options.WindowWidth = 800;\n    options.WindowHeight = 600;\n    options.VSync = true;\n});\n\n// Add input\nbuilder.Services.AddSDL3Input();\n\n// Add ECS\nbuilder.Services.AddObjectECS();\n\n// Register the ECS scene\nbuilder.Services.AddScene&lt;ECSGameScene&gt;();\n\nvar game = builder.Build();\n\n// Run the ECS scene\nawait game.RunAsync&lt;ECSGameScene&gt;();</code></pre>"},{"location":"guides/ecs/getting-started/#step-6-run-your-game","title":"Step 6: Run Your Game","text":"<pre><code>dotnet run</code></pre> <p>What you should see: - A green circle (player) in the center - 20 yellow circles (coins) in a grid - Score counter at top-left - Player moves with WASD - Coins disappear when collected - Score increases by 10 per coin</p> <p>Congratulations! You just built your first hybrid ECS game with automatic execution!</p>"},{"location":"guides/ecs/getting-started/#understanding-what-you-built","title":"Understanding What You Built","text":""},{"location":"guides/ecs/getting-started/#automatic-execution","title":"Automatic Execution","text":"<p>Everything runs automatically via lifecycle hooks:</p> <pre><code>protected override void OnUpdate(GameTime gameTime)\n{\n    // Component OnUpdate() methods run automatically!\n    // _world.Update() called automatically by SceneManager!\n    // Just add your custom scene logic here\n\n    if (_input.IsKeyPressed(Keys.Escape))\n    {\n        _gameContext.RequestExit();\n    }\n}\n\nprotected override void OnRender(GameTime gameTime)\n{\n    // Frame management automatic!\n    // Clear/BeginFrame/EndFrame called by SceneManager!\n    // Just draw your stuff\n\n    _renderer.DrawCircleFilled(...);\n}</code></pre> <p>No boilerplate - just game logic!</p>"},{"location":"guides/ecs/getting-started/#entity-creation","title":"Entity Creation","text":"<pre><code>var player = _world.CreateEntity(\"Player\");\nplayer.Tags.Add(\"Player\");\n\nvar transform = player.AddComponent&lt;TransformComponent&gt;();\ntransform.Position = new Vector2(400, 300);\n\nplayer.AddComponent&lt;SimplePlayerController&gt;();</code></pre> <p>What happens: 1. <code>CreateEntity()</code> - Creates a new entity object 2. <code>.Tags.Add()</code> - Tag for querying/identification 3. <code>.AddComponent&lt;T&gt;()</code> - Adds components to the entity 4. Components automatically update every frame via lifecycle hooks</p>"},{"location":"guides/ecs/getting-started/#component-lifecycle","title":"Component Lifecycle","text":"<pre><code>public class MyComponent : Component\n{\n    protected internal override void OnAdded()\n    {\n        // Initialize when added\n    }\n\n    protected internal override void OnUpdate(GameTime gameTime)\n    {\n        // Update every frame automatically!\n    }\n\n    protected internal override void OnRemoved()\n    {\n        // Clean up when removed\n    }\n}</code></pre>"},{"location":"guides/ecs/getting-started/#querying-entities","title":"Querying Entities","text":"<pre><code>// Get all entities with a specific component\nvar coins = _world.GetEntitiesWithComponent&lt;CoinComponent&gt;();\n\n// Get entities with multiple components\nvar moving = _world.GetEntitiesWithComponents&lt;TransformComponent, VelocityComponent&gt;();\n\n// Find entity by tag\nvar player = _world.GetEntitiesByTag(\"Player\").FirstOrDefault();\n\nvar targets = _world.Query()\n    .With&lt;HealthComponent&gt;()\n    .WithTag(\"Enemy\")\n    .Without&lt;DeadComponent&gt;()\n    .Execute();</code></pre>"},{"location":"guides/ecs/getting-started/#using-systems-for-performance","title":"Using Systems for Performance","text":"<p>When you have many entities (50+), use systems for better performance:</p> <pre><code>// 1. Register systems in Program.cs\nbuilder.Services.ConfigureSystemPipelines(pipelines =&gt;\n{\n    pipelines.AddSystem&lt;PlayerControllerSystem&gt;();\n    pipelines.AddSystem&lt;VelocitySystem&gt;();\n});\n\n// 2. Systems run automatically via lifecycle hooks!\n// No manual calls needed in your scene - just works!</code></pre> <ul> <li><code>PlayerControllerSystem</code> processes input (UpdateOrder: 10)</li> <li><code>VelocitySystem</code> applies movement (UpdateOrder: 100)</li> <li>All via automatic lifecycle hooks!</li> </ul> <p>See the Systems Guide for more details.</p>"},{"location":"guides/ecs/getting-started/#what-you-learned","title":"What You Learned","text":"<p>\u2705 Components - Classes that inherit from <code>Component</code> and can contain logic \u2705 Entities - Objects that hold components \u2705 Component Lifecycle - <code>OnAdded()</code>, <code>OnUpdate()</code>, <code>OnRemoved()</code> \u2705 Queries - Finding entities by component or tag \u2705 Systems - Optional performance optimization \u2705 Automatic Execution - Components/systems run via lifecycle hooks \u2705 Automatic Frame Management - No manual Clear/BeginFrame/EndFrame</p>"},{"location":"guides/ecs/getting-started/#next-steps","title":"Next Steps","text":"<p>Ready to dive deeper into ECS?</p> <ul> <li> <p>Systems Guide</p> <p>Write efficient systems for performance</p> <p> Systems Guide</p> </li> <li> <p>Queries Guide</p> <p>Master the advanced query system</p> <p> Queries Guide</p> </li> <li> <p>Components Guide</p> <p>Learn component design patterns</p> <p> Components Guide</p> </li> <li> <p>FeatureDemos</p> <p>See Query System Demo in action</p> <p> View Demos</p> </li> </ul> <p>You're now ready to build games with Brine2D's hybrid ECS! Use component logic for simplicity, systems for performance. Everything runs automatically!</p>"},{"location":"guides/ecs/queries/","title":"ECS Queries","text":"<p>Queries are how you find and filter entities in Brine2D's ECS. Think of them like LINQ or SQL queries - you specify what you're looking for, and the ECS returns matching entities efficiently.</p>"},{"location":"guides/ecs/queries/#what-are-queries","title":"What Are Queries?","text":"<p>Queries find entities based on: - Components they have (With/Without) - Tags they contain - Properties and conditions (Where) - Fluent API for complex searches - Cached queries for zero-allocation performance</p> <pre><code>// Find all entities with Health component\nvar withHealth = world.GetEntitiesWithComponent&lt;HealthComponent&gt;();\n\n// Find all enemies\nvar enemies = world.GetEntitiesByTag(\"Enemy\");\n\n// Fluent query API\nvar weakEnemies = world.Query()\n    .With&lt;HealthComponent&gt;()\n    .With&lt;TransformComponent&gt;()\n    .Without&lt;DeadComponent&gt;()\n    .WithTag(\"Enemy\")\n    .Where(e =&gt;\n    {\n        var health = e.GetComponent&lt;HealthComponent&gt;();\n        return health.CurrentHealth &lt; 50;\n    })\n    .Execute();</code></pre>"},{"location":"guides/ecs/queries/#advanced-query-system","title":"Advanced Query System","text":"<p>Brine2D introduces a powerful fluent query API for building complex entity searches.</p>"},{"location":"guides/ecs/queries/#fluent-query-api","title":"Fluent Query API","text":"<p>Build queries with a chainable, readable syntax:</p> <pre><code>using Brine2D.ECS.Query;\n\n// Find low-health enemies near the player\nvar dangerousEnemies = _world.Query()\n    .With&lt;EnemyComponent&gt;()\n    .With&lt;HealthComponent&gt;()\n    .With&lt;TransformComponent&gt;()\n    .Without&lt;DeadComponent&gt;()\n    .WithTag(\"Boss\")\n    .Where(e =&gt; \n    {\n        var health = e.GetComponent&lt;HealthComponent&gt;();\n        var transform = e.GetComponent&lt;TransformComponent&gt;();\n        var distance = Vector2.Distance(transform.Position, playerPosition);\n\n        return health.CurrentHealth &lt; 50 &amp;&amp; distance &lt; 200f;\n    })\n    .Execute();\n\nforeach (var enemy in dangerousEnemies)\n{\n    Logger.LogInformation(\"Dangerous enemy: {Name}\", enemy.Name);\n}</code></pre>"},{"location":"guides/ecs/queries/#query-builder-methods","title":"Query Builder Methods","text":"Method Description Example <code>With&lt;T&gt;()</code> Requires component <code>.With&lt;HealthComponent&gt;()</code> <code>Without&lt;T&gt;()</code> Excludes component <code>.Without&lt;DeadComponent&gt;()</code> <code>WithTag(string)</code> Requires tag <code>.WithTag(\"Enemy\")</code> <code>WithoutTag(string)</code> Excludes tag <code>.WithoutTag(\"Dead\")</code> <code>Where(predicate)</code> Custom filter <code>.Where(e =&gt; e.IsActive)</code> <code>Execute()</code> Run query <code>.Execute()</code>"},{"location":"guides/ecs/queries/#cached-queries-for-performance","title":"Cached Queries for Performance","text":"<p>Cached queries are pre-compiled and automatically updated - perfect for systems that run every frame:</p> <pre><code>public class MovementSystem : GameSystem\n{\n    private readonly CachedQuery&lt;TransformComponent, VelocityComponent&gt; _movingEntities;\n\n    public MovementSystem(IEntityWorld world) : base(world, 100)\n    {\n        // Create cached query (updates automatically when entities change)\n        _movingEntities = world.CreateCachedQuery&lt;TransformComponent, VelocityComponent&gt;();\n    }\n\n    public override void Update(GameTime gameTime)\n    {\n        var deltaTime = (float)gameTime.DeltaTime;\n\n        // Zero-allocation iteration!\n        foreach (var (transform, velocity) in _movingEntities)\n        {\n            transform.Position += velocity.Velocity * deltaTime;\n        }\n    }\n}</code></pre> <p>Benefits: - \u2705 Zero allocation - No garbage collection pressure - \u2705 Automatic updates - Stays in sync with world changes - \u2705 Type-safe - Compile-time component checking - \u2705 Fast iteration - Direct component access</p>"},{"location":"guides/ecs/queries/#multi-component-cached-queries","title":"Multi-Component Cached Queries","text":"<p>Query up to 5 components simultaneously:</p> <pre><code>// 2 components\nvar query2 = world.CreateCachedQuery&lt;TransformComponent, VelocityComponent&gt;();\n\n// 3 components\nvar query3 = world.CreateCachedQuery&lt;TransformComponent, SpriteComponent, AnimatorComponent&gt;();\n\n// 4 components\nvar query4 = world.CreateCachedQuery&lt;TransformComponent, HealthComponent, AIComponent, VelocityComponent&gt;();\n\n// 5 components\nvar query5 = world.CreateCachedQuery&lt;TransformComponent, HealthComponent, VelocityComponent, SpriteComponent, AIComponent&gt;();\n\n// Use with tuple deconstruction\nforeach (var (transform, sprite, animator) in query3)\n{\n    // All components guaranteed to exist\n    animator.Update(deltaTime);\n    sprite.CurrentFrame = animator.CurrentFrame;\n}</code></pre>"},{"location":"guides/ecs/queries/#query-performance-comparison","title":"Query Performance Comparison","text":"<pre><code>// \u274c Slow - Creates new list every frame\npublic override void Update(GameTime gameTime)\n{\n    var moving = _world.GetEntitiesWithComponents&lt;TransformComponent, VelocityComponent&gt;();\n\n    foreach (var entity in moving)\n    {\n        var transform = entity.GetComponent&lt;TransformComponent&gt;();\n        var velocity = entity.GetComponent&lt;VelocityComponent&gt;();\n        transform.Position += velocity.Velocity * deltaTime;\n    }\n}\n\n// \u2705 Fast - Cached query, zero allocation\npublic override void Update(GameTime gameTime)\n{\n    foreach (var (transform, velocity) in _movingEntities)\n    {\n        transform.Position += velocity.Velocity * deltaTime;\n    }\n}</code></pre>"},{"location":"guides/ecs/queries/#complex-query-example","title":"Complex Query Example","text":"<p>Combining fluent API with cached queries:</p> <pre><code>public class CombatSystem : GameSystem\n{\n    private readonly CachedQuery&lt;TransformComponent, HealthComponent&gt; _damageable;\n    private Entity _player;\n\n    public override void Update(GameTime gameTime)\n    {\n        var playerTransform = _player.GetComponent&lt;TransformComponent&gt;();\n        var attackRange = 100f;\n\n        // Find targets with fluent API\n        var targets = _world.Query()\n            .With&lt;HealthComponent&gt;()\n            .With&lt;TransformComponent&gt;()\n            .WithTag(\"Enemy\")\n            .Without&lt;DeadComponent&gt;()\n            .Where(e =&gt;\n            {\n                var transform = e.GetComponent&lt;TransformComponent&gt;();\n                var distance = Vector2.Distance(transform.Position, playerTransform.Position);\n                return distance &lt; attackRange;\n            })\n            .Execute();\n\n        foreach (var target in targets)\n        {\n            ApplyDamage(target, 10);\n        }\n    }\n}</code></pre>"},{"location":"guides/ecs/queries/#basic-queries","title":"Basic Queries","text":""},{"location":"guides/ecs/queries/#query-all-entities","title":"Query All Entities","text":"<pre><code>// Get all entities in the world\nIReadOnlyList&lt;Entity&gt; allEntities = world.Entities;\n\nforeach (var entity in allEntities)\n{\n    Console.WriteLine($\"{entity.Name} ({entity.Id})\");\n}</code></pre>"},{"location":"guides/ecs/queries/#query-by-single-component","title":"Query by Single Component","text":"<pre><code>// Get all entities with a specific component\nvar withHealth = world.GetEntitiesWithComponent&lt;HealthComponent&gt;();\n\nforeach (var entity in withHealth)\n{\n    var health = entity.GetComponent&lt;HealthComponent&gt;()!;\n    Console.WriteLine($\"{entity.Name}: {health.Current}/{health.Max} HP\");\n}</code></pre>"},{"location":"guides/ecs/queries/#query-by-multiple-components","title":"Query by Multiple Components","text":"<pre><code>// Get entities that have BOTH components\nvar moving = world.GetEntitiesWithComponents&lt;TransformComponent, VelocityComponent&gt;();\n\nforeach (var entity in moving)\n{\n    var transform = entity.GetComponent&lt;TransformComponent&gt;()!;\n    var velocity = entity.GetComponent&lt;VelocityComponent&gt;()!;\n\n    Console.WriteLine($\"{entity.Name} at {transform.Position}, moving {velocity.Velocity}\");\n}</code></pre>"},{"location":"guides/ecs/queries/#query-by-tag","title":"Query by Tag","text":"<pre><code>// Get all entities with a specific tag\nvar enemies = world.GetEntitiesByTag(\"Enemy\");\n\nforeach (var enemy in enemies)\n{\n    Console.WriteLine($\"Enemy: {enemy.Name}\");\n}\n\n// Check multiple tags (manual filtering)\nvar bossEnemies = world.GetEntitiesByTag(\"Enemy\")\n    .Where(e =&gt; e.Tags.Contains(\"Boss\"));</code></pre>"},{"location":"guides/ecs/queries/#finding-specific-entities","title":"Finding Specific Entities","text":""},{"location":"guides/ecs/queries/#find-by-name","title":"Find by Name","text":"<pre><code>// Find first entity with exact name\nvar player = world.GetEntityByName(\"Player\");\n\nif (player != null)\n{\n    Console.WriteLine($\"Found player: {player.Id}\");\n}</code></pre>"},{"location":"guides/ecs/queries/#find-by-id","title":"Find by ID","text":"<pre><code>// Find entity by unique ID\nGuid entityId = someEntity.Id;\nvar found = world.GetEntityById(entityId);\n\nif (found != null)\n{\n    Console.WriteLine($\"Found entity: {found.Name}\");\n}</code></pre>"},{"location":"guides/ecs/queries/#find-by-predicate","title":"Find by Predicate","text":"<pre><code>// Find first entity matching custom condition\nvar boss = world.FindEntity(e =&gt; \n    e.Tags.Contains(\"Enemy\") &amp;&amp; \n    e.Name.Contains(\"Boss\") &amp;&amp;\n    e.IsActive\n);\n\nif (boss != null)\n{\n    Console.WriteLine($\"Found boss: {boss.Name}\");\n}</code></pre>"},{"location":"guides/ecs/queries/#filtering-queries","title":"Filtering Queries","text":""},{"location":"guides/ecs/queries/#linq-style-filtering","title":"LINQ-Style Filtering","text":"<pre><code>using System.Linq;\n\n// Get active enemies with low health\nvar weakEnemies = world.GetEntitiesByTag(\"Enemy\")\n    .Where(e =&gt; e.IsActive)\n    .Where(e =&gt;\n    {\n        var health = e.GetComponent&lt;HealthComponent&gt;();\n        return health != null &amp;&amp; health.Percentage &lt; 0.3f;\n    });\n\n// Get all projectiles moving right\nvar rightMoving = world.GetEntitiesWithComponent&lt;VelocityComponent&gt;()\n    .Where(e =&gt; e.Tags.Contains(\"Projectile\"))\n    .Where(e =&gt; e.GetComponent&lt;VelocityComponent&gt;()!.Velocity.X &gt; 0);\n\n// Get enemies within view distance of player\nvar nearbyEnemies = world.GetEntitiesByTag(\"Enemy\")\n    .Where(e =&gt;\n    {\n        var enemyTransform = e.GetComponent&lt;TransformComponent&gt;();\n        var playerTransform = player.GetComponent&lt;TransformComponent&gt;();\n\n        if (enemyTransform == null || playerTransform == null) return false;\n\n        var distance = Vector2.Distance(enemyTransform.Position, playerTransform.Position);\n        return distance &lt; 500f;\n    });</code></pre>"},{"location":"guides/ecs/queries/#spatial-queries","title":"Spatial Queries","text":""},{"location":"guides/ecs/queries/#distance-based-queries","title":"Distance-Based Queries","text":"<pre><code>// Extension method for radius queries\npublic static class SpatialQueryExtensions\n{\n    public static IEnumerable&lt;Entity&gt; WithinRadius(\n        this IEnumerable&lt;Entity&gt; entities,\n        Vector2 center,\n        float radius)\n    {\n        var radiusSquared = radius * radius;\n\n        return entities.Where(e =&gt;\n        {\n            var transform = e.GetComponent&lt;TransformComponent&gt;();\n            if (transform == null) return false;\n\n            // Use DistanceSquared for better performance (avoid sqrt)\n            var distanceSquared = Vector2.DistanceSquared(transform.Position, center);\n            return distanceSquared &lt;= radiusSquared;\n        });\n    }\n}\n\n// Usage\nvar playerPos = player.GetComponent&lt;TransformComponent&gt;()!.Position;\nvar nearbyEnemies = world.GetEntitiesByTag(\"Enemy\")\n    .WithinRadius(playerPos, 200f);</code></pre>"},{"location":"guides/ecs/queries/#query-performance-tips","title":"Query Performance Tips","text":""},{"location":"guides/ecs/queries/#dos-and-donts","title":"Do's and Don'ts","text":"<pre><code>// \u2705 DO: Use cached queries in systems\nvar _cachedQuery = world.CreateCachedQuery&lt;TransformComponent, VelocityComponent&gt;();\n\n// \u274c DON'T: Query every frame without caching\nvar moving = world.GetEntitiesWithComponents&lt;TransformComponent, VelocityComponent&gt;();\n\n// \u2705 DO: Use fluent API for complex queries\nvar targets = world.Query()\n    .With&lt;HealthComponent&gt;()\n    .WithTag(\"Enemy\")\n    .Without&lt;DeadComponent&gt;()\n    .Execute();\n\n// \u274c DON'T: Chain LINQ Where clauses unnecessarily\nvar targets = world.Entities\n    .Where(e =&gt; e.HasComponent&lt;HealthComponent&gt;())\n    .Where(e =&gt; e.Tags.Contains(\"Enemy\"))\n    .Where(e =&gt; !e.Tags.Contains(\"Dead\"));\n\n// \u2705 DO: Use Any() for existence checks\nvar hasEnemies = world.GetEntitiesByTag(\"Enemy\").Any();\n\n// \u274c DON'T: Use Count() for existence checks\nvar hasEnemies = world.GetEntitiesByTag(\"Enemy\").Count() &gt; 0;</code></pre>"},{"location":"guides/ecs/queries/#quick-reference","title":"Quick Reference","text":""},{"location":"guides/ecs/queries/#fluent-query-api_1","title":"Fluent Query API","text":"<pre><code>world.Query()                                       // Start query builder\n    .With&lt;T&gt;()                                      // Require component\n    .Without&lt;T&gt;()                                   // Exclude component\n    .WithTag(\"tag\")                                 // Require tag\n    .WithoutTag(\"tag\")                              // Exclude tag\n    .Where(e =&gt; condition)                          // Custom filter\n    .Execute()                                      // Run query</code></pre>"},{"location":"guides/ecs/queries/#cached-queries","title":"Cached Queries","text":"<pre><code>world.CreateCachedQuery&lt;T&gt;()                        // 1 component\nworld.CreateCachedQuery&lt;T1, T2&gt;()                   // 2 components\nworld.CreateCachedQuery&lt;T1, T2, T3&gt;()               // 3 components\nworld.CreateCachedQuery&lt;T1, T2, T3, T4&gt;()           // 4 components\nworld.CreateCachedQuery&lt;T1, T2, T3, T4, T5&gt;()       // 5 components</code></pre>"},{"location":"guides/ecs/queries/#basic-queries_1","title":"Basic Queries","text":"<pre><code>world.Entities                                      // All entities\nworld.GetEntityByName(\"Player\")                     // By name\nworld.GetEntityById(guid)                           // By ID\nworld.GetEntitiesByTag(\"Enemy\")                     // By tag\nworld.GetEntitiesWithComponent&lt;T&gt;()                 // By component\nworld.GetEntitiesWithComponents&lt;T1, T2&gt;()           // By multiple components\nworld.FindEntity(e =&gt; /* condition */)              // By predicate</code></pre>"},{"location":"guides/ecs/queries/#see-it-in-action","title":"See It In Action","text":"<p>Check out the Query System Demo in FeatureDemos to see advanced queries in action!</p> <pre><code>cd samples/FeatureDemos\ndotnet run\n# Select \"1\" for Query System Demo</code></pre>"},{"location":"guides/ecs/queries/#next-steps","title":"Next Steps","text":"<p>Now that you've mastered queries, explore related topics:</p> <ul> <li> <p>FeatureDemos</p> <p>See Query System Demo in action</p> <p> View Demos</p> </li> <li> <p>Systems Guide</p> <p>Use queries in systems for performance</p> <p> Systems Guide</p> </li> <li> <p>Components Guide</p> <p>Design effective components for querying</p> <p> Components Guide</p> </li> </ul> <p>Remember: Use cached queries in systems that run every frame, and fluent API for complex one-time searches. Always profile your queries!</p>"},{"location":"guides/ecs/systems/","title":"ECS Systems","text":"<p>Systems are optional performance optimizations in Brine2D's hybrid ECS. While components can contain logic via <code>OnUpdate()</code>, systems let you batch-process many entities efficiently. Think of them as specialized processors that run on specific component combinations.</p>"},{"location":"guides/ecs/systems/#when-to-use-systems","title":"When to Use Systems","text":""},{"location":"guides/ecs/systems/#use-systems-when","title":"Use Systems When:","text":"<ul> <li>\u2705 Many entities (50+) need the same processing</li> <li>\u2705 Performance matters - batching is faster than individual updates</li> <li>\u2705 Execution order is critical - systems have explicit ordering</li> <li>\u2705 Cross-entity queries - need to compare/interact multiple entities</li> </ul>"},{"location":"guides/ecs/systems/#stick-with-component-logic-when","title":"Stick with Component Logic When:","text":"<ul> <li>\u2705 Few entities (&lt;50) with this behavior</li> <li>\u2705 Simple, self-contained logic (timers, lifetime, etc.)</li> <li>\u2705 Rapid prototyping - faster to write than systems</li> <li>\u2705 Unique per entity - not batched processing</li> </ul> <pre><code>// \u2705 Good for component logic\npublic class LifetimeComponent : Component\n{\n    public float Lifetime { get; set; }\n\n    protected internal override void OnUpdate(GameTime gameTime)\n    {\n        Lifetime -= (float)gameTime.DeltaTime;\n        if (Lifetime &lt;= 0) Entity?.Destroy();\n    }\n}\n\n// \u2705 Better as a system (many entities)\npublic class VelocitySystem : IUpdateSystem\n{\n    public int UpdateOrder =&gt; 100;\n\n    public void Update(GameTime gameTime)\n    {\n        var entities = _world.GetEntitiesWithComponents&lt;TransformComponent, VelocityComponent&gt;();\n        var deltaTime = (float)gameTime.DeltaTime;\n\n        foreach (var entity in entities)\n        {\n            var transform = entity.GetComponent&lt;TransformComponent&gt;()!;\n            var velocity = entity.GetComponent&lt;VelocityComponent&gt;()!;\n\n            transform.Position += velocity.Velocity * deltaTime;\n        }\n    }\n}</code></pre>"},{"location":"guides/ecs/systems/#system-types","title":"System Types","text":"<p>Brine2D supports two types of systems:</p>"},{"location":"guides/ecs/systems/#update-systems-iupdatesystem","title":"Update Systems (IUpdateSystem)","text":"<p>Run during the update phase (game logic):</p> <pre><code>using Brine2D.Core;\nusing Brine2D.ECS;\nusing Brine2D.ECS.Systems;\n\npublic class VelocitySystem : IUpdateSystem\n{\n    private readonly IEntityWorld _world;\n\n    public int UpdateOrder =&gt; 100; // Lower = earlier\n\n    public VelocitySystem(IEntityWorld world)\n    {\n        _world = world;\n    }\n\n    public void Update(GameTime gameTime)\n    {\n        var deltaTime = (float)gameTime.DeltaTime;\n        var entities = _world.GetEntitiesWithComponents&lt;TransformComponent, VelocityComponent&gt;();\n\n        foreach (var entity in entities)\n        {\n            var transform = entity.GetComponent&lt;TransformComponent&gt;()!;\n            var velocity = entity.GetComponent&lt;VelocityComponent&gt;()!;\n\n            // Apply velocity\n            transform.Position += velocity.Velocity * deltaTime;\n\n            // Apply friction\n            if (velocity.Friction &gt; 0)\n            {\n                var speed = velocity.Velocity.Length();\n                if (speed &gt; 0)\n                {\n                    var newSpeed = Math.Max(0, speed - velocity.Friction * deltaTime);\n                    velocity.Velocity *= newSpeed / speed;\n                }\n            }\n        }\n    }\n}</code></pre>"},{"location":"guides/ecs/systems/#render-systems-irendersystem","title":"Render Systems (IRenderSystem)","text":"<p>Run during the render phase (drawing):</p> <pre><code>using Brine2D.ECS.Systems;\nusing Brine2D.Rendering;\nusing Brine2D.Rendering.ECS;\n\npublic class SpriteRenderingSystem : IRenderSystem\n{\n    private readonly IEntityWorld _world;\n    private readonly ITextureLoader _textureLoader;\n    private readonly Dictionary&lt;string, ITexture&gt; _textureCache = new();\n\n    public int RenderOrder =&gt; 0; // Lower = drawn first (background)\n\n    public SpriteRenderingSystem(IEntityWorld world, ITextureLoader textureLoader)\n    {\n        _world = world;\n        _textureLoader = textureLoader;\n    }\n\n    public void Render(IRenderer renderer)\n    {\n        var entities = _world.GetEntitiesWithComponents&lt;TransformComponent, SpriteComponent&gt;();\n\n        foreach (var entity in entities)\n        {\n            var transform = entity.GetComponent&lt;TransformComponent&gt;()!;\n            var sprite = entity.GetComponent&lt;SpriteComponent&gt;()!;\n\n            if (!sprite.IsEnabled) continue;\n\n            // Load texture if needed\n            if (!_textureCache.ContainsKey(sprite.TexturePath))\n            {\n                // Handle async loading here\n            }\n\n            var texture = _textureCache.GetValueOrDefault(sprite.TexturePath);\n            if (texture == null) continue;\n\n            // Draw sprite\n            renderer.DrawTexture(\n                texture,\n                transform.Position.X,\n                transform.Position.Y,\n                texture.Width,\n                texture.Height\n            );\n        }\n    }\n}</code></pre>"},{"location":"guides/ecs/systems/#hybrid-systems-both-update-and-render","title":"Hybrid Systems (Both Update and Render)","text":"<p>Systems can implement both interfaces:</p> <pre><code>public class ParticleSystem : IUpdateSystem, IRenderSystem\n{\n    private readonly IEntityWorld _world;\n\n    public int UpdateOrder =&gt; 200;\n    public int RenderOrder =&gt; 500; // Draw on top\n\n    public ParticleSystem(IEntityWorld world)\n    {\n        _world = world;\n    }\n\n    public void Update(GameTime gameTime)\n    {\n        // Update particle physics\n        var emitters = _world.GetEntitiesWithComponent&lt;ParticleEmitterComponent&gt;();\n\n        foreach (var entity in emitters)\n        {\n            var emitter = entity.GetComponent&lt;ParticleEmitterComponent&gt;()!;\n            if (!emitter.IsEnabled) continue;\n\n            // Spawn particles, update lifetimes, etc.\n            UpdateParticles(emitter, gameTime);\n        }\n    }\n\n    public void Render(IRenderer renderer)\n    {\n        // Render particles\n        var emitters = _world.GetEntitiesWithComponent&lt;ParticleEmitterComponent&gt;();\n\n        foreach (var entity in emitters)\n        {\n            var emitter = entity.GetComponent&lt;ParticleEmitterComponent&gt;()!;\n            var transform = entity.GetComponent&lt;TransformComponent&gt;();\n\n            RenderParticles(renderer, emitter, transform);\n        }\n    }\n\n    private void UpdateParticles(ParticleEmitterComponent emitter, GameTime gameTime) { /* ... */ }\n    private void RenderParticles(IRenderer renderer, ParticleEmitterComponent emitter, TransformComponent? transform) { /* ... */ }\n}</code></pre>"},{"location":"guides/ecs/systems/#system-execution-order","title":"System Execution Order","text":"<p>Systems run in priority order based on <code>UpdateOrder</code> or <code>RenderOrder</code>:</p>"},{"location":"guides/ecs/systems/#update-pipeline-order","title":"Update Pipeline Order","text":"<pre><code>builder.Services.ConfigureSystemPipelines(pipelines =&gt;\n{\n    // Order matters! Lower numbers run first\n    pipelines.AddSystem&lt;PlayerControllerSystem&gt;();  // UpdateOrder: 10  (input)\n    pipelines.AddSystem&lt;AISystem&gt;();                // UpdateOrder: 50  (AI decisions)\n    pipelines.AddSystem&lt;VelocitySystem&gt;();          // UpdateOrder: 100 (apply movement)\n    pipelines.AddSystem&lt;PhysicsSystem&gt;();           // UpdateOrder: 200 (collision)\n    pipelines.AddSystem&lt;CameraSystem&gt;();            // UpdateOrder: 400 (camera follow)\n    pipelines.AddSystem&lt;AudioSystem&gt;();             // UpdateOrder: 300 (audio)\n});</code></pre> <p>Execution: 1. Input systems read controls 2. AI systems make decisions 3. Movement systems apply velocity 4. Physics systems resolve collisions 5. Audio systems play sounds 6. Camera systems update view</p>"},{"location":"guides/ecs/systems/#render-pipeline-order","title":"Render Pipeline Order","text":"<pre><code>builder.Services.ConfigureSystemPipelines(pipelines =&gt;\n{\n    // Lower = background, Higher = foreground\n    pipelines.AddSystem&lt;BackgroundSystem&gt;();      // RenderOrder: -100\n    pipelines.AddSystem&lt;SpriteRenderingSystem&gt;(); // RenderOrder: 0\n    pipelines.AddSystem&lt;ParticleSystem&gt;();        // RenderOrder: 500\n    pipelines.AddSystem&lt;DebugRenderer&gt;();         // RenderOrder: 1000\n});</code></pre> <p>Rendering: 1. Background layer 2. Sprites (entities) 3. Particle effects 4. Debug overlays (on top)</p>"},{"location":"guides/ecs/systems/#registering-systems","title":"Registering Systems","text":""},{"location":"guides/ecs/systems/#aspnet-style-pipeline-configuration","title":"ASP.NET-Style Pipeline Configuration","text":"<p>The automatic approach - systems run via lifecycle hooks:</p> <pre><code>using Brine2D.ECS;\nusing Brine2D.ECS.Systems;\nusing Brine2D.Rendering.ECS;\nusing Brine2D.Input.ECS;\n\nvar builder = GameApplication.CreateBuilder(args);\n\n// Register ECS\nbuilder.Services.AddObjectECS();\nbuilder.Services.AddECSRendering();\nbuilder.Services.AddECSInput();\n\n// Configure system pipelines (like ASP.NET middleware!)\nbuilder.Services.ConfigureSystemPipelines(pipelines =&gt;\n{\n    // Update systems\n    pipelines.AddSystem&lt;PlayerControllerSystem&gt;();\n    pipelines.AddSystem&lt;AISystem&gt;();\n    pipelines.AddSystem&lt;VelocitySystem&gt;();\n    pipelines.AddSystem&lt;PhysicsSystem&gt;();\n\n    // Render systems\n    pipelines.AddSystem&lt;SpriteRenderingSystem&gt;();\n    pipelines.AddSystem&lt;ParticleSystem&gt;(); // Auto-added to both pipelines!\n\n    // Custom systems\n    pipelines.AddSystem&lt;MyCustomSystem&gt;();\n});\n\nvar game = builder.Build();\nawait game.RunAsync&lt;MyScene&gt;();</code></pre> <p>Systems Execute Automatically!</p> <p>Once registered, systems run automatically via lifecycle hooks: - Update systems run during <code>SceneManager.Update()</code> (PostUpdate hook) - Render systems run during <code>SceneManager.Render()</code> (PreRender hook)</p> <p>No manual pipeline calls needed in your scenes!</p>"},{"location":"guides/ecs/systems/#scenes-dont-need-pipeline-calls-anymore","title":"Scenes Don't Need Pipeline Calls Anymore!","text":"<p>Old way (manual): <pre><code>// \u274c OLD - Don't do this anymore!\npublic class MyScene : Scene\n{\n    private readonly UpdatePipeline _updatePipeline;\n    private readonly RenderPipeline _renderPipeline;\n\n    protected override void OnUpdate(GameTime gameTime)\n    {\n        _updatePipeline.Execute(gameTime);  // Manual call\n        _world.Update(gameTime);\n    }\n\n    protected override void OnRender(GameTime gameTime)\n    {\n        _renderer.BeginFrame();\n        _renderPipeline.Execute(_renderer);  // Manual call\n        _renderer.EndFrame();\n    }\n}</code></pre></p> <p>New way (automatic): <pre><code>// \u2705 NEW - Clean and simple!\npublic class MyScene : Scene\n{\n    private readonly IRenderer _renderer;\n    private readonly IEntityWorld _world;\n\n    protected override void OnInitialize()\n    {\n        _renderer.ClearColor = new Color(40, 40, 60);\n\n        // Create entities - systems will process them automatically\n        var player = _world.CreateEntity(\"Player\");\n        player.AddComponent&lt;TransformComponent&gt;();\n        player.AddComponent&lt;VelocityComponent&gt;();\n        player.AddComponent&lt;PlayerControllerComponent&gt;();\n    }\n\n    protected override void OnUpdate(GameTime gameTime)\n    {\n        // Just your scene-specific logic\n        CheckWinCondition();\n\n        // Systems run automatically via lifecycle hooks!\n    }\n\n    protected override void OnRender(GameTime gameTime)\n    {\n        // Frame management automatic!\n        // Sprites already rendered by SpriteRenderingSystem!\n\n        // Just draw scene-specific UI\n        _renderer.DrawText($\"Score: {_score}\", 10, 10, Color.White);\n    }\n}</code></pre></p> <p>Benefits: - \u2705 No boilerplate pipeline calls - \u2705 Cleaner scenes (like ASP.NET controllers) - \u2705 Can't forget to execute systems - \u2705 Automatic execution order</p>"},{"location":"guides/ecs/systems/#power-user-manual-pipeline-control","title":"Power User: Manual Pipeline Control","text":"<p>For advanced scenarios, you can opt out and control pipelines manually:</p> <pre><code>public class AdvancedScene : Scene\n{\n    // Disable automatic execution\n    public override bool EnableLifecycleHooks =&gt; false;\n\n    private readonly UpdatePipeline _updatePipeline;\n    private readonly RenderPipeline _renderPipeline;\n    private readonly IEntityWorld _world;\n\n    public AdvancedScene(\n        UpdatePipeline updatePipeline,\n        RenderPipeline renderPipeline,\n        IEntityWorld world,\n        ILogger&lt;AdvancedScene&gt; logger\n    ) : base(logger)\n    {\n        _updatePipeline = updatePipeline;\n        _renderPipeline = renderPipeline;\n        _world = world;\n    }\n\n    protected override void OnUpdate(GameTime gameTime)\n    {\n        // Manual control - pause systems on condition\n        if (!_isPaused)\n        {\n            _updatePipeline.Execute(gameTime);\n            _world.Update(gameTime);\n        }\n    }\n\n    protected override void OnRender(GameTime gameTime)\n    {\n        // Manual rendering control\n        _renderPipeline.Execute(_renderer);\n    }\n}</code></pre> <p>Use cases: - Pausing systems conditionally - Frame-by-frame debugging - Custom execution timing - Multiple pipeline passes</p> <p>See Scene Management for details.</p>"},{"location":"guides/ecs/systems/#built-in-systems","title":"Built-in Systems","text":"<p>Brine2D provides several pre-built systems:</p>"},{"location":"guides/ecs/systems/#velocitysystem","title":"VelocitySystem","text":"<p>Applies velocity to transform positions with friction:</p> <pre><code>// Automatically registered with AddObjectECS()\n// UpdateOrder: 100\n// Runs automatically via lifecycle hooks!\n\n// Usage: Just add components!\nvar entity = world.CreateEntity();\nentity.AddComponent&lt;TransformComponent&gt;().Position = new Vector2(100, 100);\nentity.AddComponent&lt;VelocityComponent&gt;().Velocity = new Vector2(50, 0);</code></pre>"},{"location":"guides/ecs/systems/#physicssystem","title":"PhysicsSystem","text":"<p>Handles collision detection and response:</p> <pre><code>// UpdateOrder: 200\n// Runs automatically!\n\nvar entity = world.CreateEntity();\nentity.AddComponent&lt;TransformComponent&gt;();\nentity.AddComponent&lt;VelocityComponent&gt;();\nentity.AddComponent&lt;ColliderComponent&gt;().Shape = new BoxCollider(32, 32);</code></pre>"},{"location":"guides/ecs/systems/#aisystem","title":"AISystem","text":"<p>Processes AI behaviors (chase, patrol, flee):</p> <pre><code>// UpdateOrder: 50\n// Runs automatically!\n\nvar enemy = world.CreateEntity();\nenemy.AddComponent&lt;TransformComponent&gt;();\nenemy.AddComponent&lt;VelocityComponent&gt;();\n\nvar ai = enemy.AddComponent&lt;AIControllerComponent&gt;();\nai.Behavior = AIBehavior.Chase;\nai.TargetTag = \"Player\";\nai.MoveSpeed = 100f;</code></pre>"},{"location":"guides/ecs/systems/#playercontrollersystem","title":"PlayerControllerSystem","text":"<p>Handles player input and applies to velocity:</p> <pre><code>// Requires: Brine2D.Input.ECS\n// UpdateOrder: 10\n// Runs automatically!\n\nvar player = world.CreateEntity();\nplayer.AddComponent&lt;TransformComponent&gt;();\nplayer.AddComponent&lt;VelocityComponent&gt;();\n\nvar controller = player.AddComponent&lt;PlayerControllerComponent&gt;();\ncontroller.MoveSpeed = 200f;\ncontroller.InputMode = InputMode.KeyboardAndGamepad;</code></pre>"},{"location":"guides/ecs/systems/#spriterenderingsystem","title":"SpriteRenderingSystem","text":"<p>Renders sprites efficiently:</p> <pre><code>// Requires: Brine2D.Rendering.ECS\n// RenderOrder: 0\n// Renders automatically!\n\nvar entity = world.CreateEntity();\nentity.AddComponent&lt;TransformComponent&gt;();\n\nvar sprite = entity.AddComponent&lt;SpriteComponent&gt;();\nsprite.TexturePath = \"assets/player.png\";\nsprite.Tint = Color.White;</code></pre>"},{"location":"guides/ecs/systems/#camerasystem","title":"CameraSystem","text":"<p>Updates camera to follow entities:</p> <pre><code>// UpdateOrder: 400\n// Runs automatically!\n\nvar player = world.CreateEntity();\nplayer.AddComponent&lt;TransformComponent&gt;();\n\nvar cameraFollow = player.AddComponent&lt;CameraFollowComponent&gt;();\ncameraFollow.CameraName = \"main\";\ncameraFollow.Smoothing = 5f;</code></pre>"},{"location":"guides/ecs/systems/#audiosystem","title":"AudioSystem","text":"<p>Plays sounds and music from components:</p> <pre><code>// Requires: Brine2D.Audio.ECS\n// UpdateOrder: 300\n// Runs automatically!\n\nvar entity = world.CreateEntity();\n\nvar audio = entity.AddComponent&lt;AudioSourceComponent&gt;();\naudio.SoundEffect = jumpSound;\naudio.Volume = 1.0f;\naudio.TriggerPlay = true; // Play now!</code></pre>"},{"location":"guides/ecs/systems/#creating-custom-systems","title":"Creating Custom Systems","text":""},{"location":"guides/ecs/systems/#update-system-example","title":"Update System Example","text":"<pre><code>using Brine2D.Core;\nusing Brine2D.ECS;\nusing Brine2D.ECS.Systems;\nusing System.Numerics;\n\npublic class GravitySystem : IUpdateSystem\n{\n    private readonly IEntityWorld _world;\n\n    public int UpdateOrder =&gt; 150; // After input, before physics\n\n    public GravitySystem(IEntityWorld world)\n    {\n        _world = world;\n    }\n\n    public void Update(GameTime gameTime)\n    {\n        var deltaTime = (float)gameTime.DeltaTime;\n\n        // Get all entities affected by gravity\n        var entities = _world.GetEntitiesWithComponents&lt;VelocityComponent, GravityComponent&gt;();\n\n        foreach (var entity in entities)\n        {\n            var velocity = entity.GetComponent&lt;VelocityComponent&gt;()!;\n            var gravity = entity.GetComponent&lt;GravityComponent&gt;()!;\n\n            if (!gravity.IsEnabled) continue;\n\n            // Apply gravity force\n            velocity.Velocity += new Vector2(0, gravity.Force) * deltaTime;\n        }\n    }\n}\n\n// Supporting component\npublic class GravityComponent : Component\n{\n    public float Force { get; set; } = 980f; // Pixels per second squared\n}\n\n// Register it\nbuilder.Services.ConfigureSystemPipelines(pipelines =&gt;\n{\n    pipelines.AddSystem&lt;GravitySystem&gt;(); // Runs automatically!\n});</code></pre>"},{"location":"guides/ecs/systems/#render-system-example","title":"Render System Example","text":"<pre><code>using Brine2D.ECS.Systems;\nusing Brine2D.Rendering;\nusing Brine2D.Rendering.ECS;\n\npublic class HealthBarSystem : IRenderSystem\n{\n    private readonly IEntityWorld _world;\n\n    public int RenderOrder =&gt; 100; // After sprites, before UI\n\n    public HealthBarSystem(IEntityWorld world)\n    {\n        _world = world;\n    }\n\n    public void Render(IRenderer renderer)\n    {\n        var entities = _world.GetEntitiesWithComponents&lt;TransformComponent, HealthComponent&gt;();\n\n        foreach (var entity in entities)\n        {\n            var transform = entity.GetComponent&lt;TransformComponent&gt;()!;\n            var health = entity.GetComponent&lt;HealthComponent&gt;()!;\n\n            if (!health.IsEnabled) continue;\n\n            // Draw health bar above entity\n            var barWidth = 32f;\n            var barHeight = 4f;\n            var barX = transform.Position.X - barWidth / 2;\n            var barY = transform.Position.Y - 20;\n\n            // Background (red)\n            renderer.DrawRectangle(barX, barY, barWidth, barHeight, new Color(255, 0, 0));\n\n            // Foreground (green)\n            var fillWidth = barWidth * health.Percentage;\n            renderer.DrawRectangle(barX, barY, fillWidth, barHeight, new Color(0, 255, 0));\n        }\n    }\n}\n\n// Register it\nbuilder.Services.ConfigureSystemPipelines(pipelines =&gt;\n{\n    pipelines.AddSystem&lt;HealthBarSystem&gt;(); // Renders automatically!\n});</code></pre>"},{"location":"guides/ecs/systems/#system-patterns","title":"System Patterns","text":""},{"location":"guides/ecs/systems/#query-caching","title":"Query Caching","text":"<p>Cache entity queries for better performance:</p> <pre><code>public class OptimizedSystem : IUpdateSystem\n{\n    private readonly IEntityWorld _world;\n    private List&lt;Entity&gt;? _cachedEntities;\n    private bool _needsRefresh = true;\n\n    public int UpdateOrder =&gt; 100;\n\n    public OptimizedSystem(IEntityWorld world)\n    {\n        _world = world;\n\n        // Refresh cache when entities change\n        _world.OnEntityCreated += _ =&gt; _needsRefresh = true;\n        _world.OnEntityDestroyed += _ =&gt; _needsRefresh = true;\n        _world.OnComponentAdded += (_, _) =&gt; _needsRefresh = true;\n        _world.OnComponentRemoved += (_, _) =&gt; _needsRefresh = true;\n    }\n\n    public void Update(GameTime gameTime)\n    {\n        if (_needsRefresh || _cachedEntities == null)\n        {\n            _cachedEntities = _world\n                .GetEntitiesWithComponents&lt;TransformComponent, VelocityComponent&gt;()\n                .ToList();\n            _needsRefresh = false;\n        }\n\n        // Process cached entities\n        foreach (var entity in _cachedEntities)\n        {\n            // ...\n        }\n    }\n}</code></pre>"},{"location":"guides/ecs/systems/#system-communication","title":"System Communication","text":"<p>Systems can communicate via events:</p> <pre><code>// Event definition\npublic class CollisionEvent\n{\n    public Entity Entity1 { get; set; }\n    public Entity Entity2 { get; set; }\n}\n\n// System 1: Detects collisions\npublic class CollisionDetectionSystem : IUpdateSystem\n{\n    private readonly IEntityWorld _world;\n    private readonly EventBus _eventBus;\n\n    public int UpdateOrder =&gt; 200;\n\n    public void Update(GameTime gameTime)\n    {\n        // Detect collisions...\n\n        if (collision)\n        {\n            _eventBus.Publish(new CollisionEvent\n            {\n                Entity1 = entityA,\n                Entity2 = entityB\n            });\n        }\n    }\n}\n\n// System 2: Responds to collisions\npublic class CollisionResponseSystem : IUpdateSystem\n{\n    public int UpdateOrder =&gt; 201; // After detection\n\n    public CollisionResponseSystem(EventBus eventBus)\n    {\n        eventBus.Subscribe&lt;CollisionEvent&gt;(OnCollision);\n    }\n\n    private void OnCollision(CollisionEvent evt)\n    {\n        // Handle collision response\n    }\n\n    public void Update(GameTime gameTime) { }\n}</code></pre>"},{"location":"guides/ecs/systems/#performance-tips","title":"Performance Tips","text":""},{"location":"guides/ecs/systems/#minimize-component-lookups","title":"Minimize Component Lookups","text":"<pre><code>// \u274c Slow - multiple lookups per entity\npublic void Update(GameTime gameTime)\n{\n    var entities = _world.GetEntitiesWithComponent&lt;TransformComponent&gt;();\n\n    foreach (var entity in entities)\n    {\n        if (entity.HasComponent&lt;VelocityComponent&gt;()) // Lookup 1\n        {\n            var transform = entity.GetComponent&lt;TransformComponent&gt;(); // Lookup 2\n            var velocity = entity.GetComponent&lt;VelocityComponent&gt;(); // Lookup 3\n            // ...\n        }\n    }\n}\n\n// \u2705 Fast - query for both components, single lookup each\npublic void Update(GameTime gameTime)\n{\n    var entities = _world.GetEntitiesWithComponents&lt;TransformComponent, VelocityComponent&gt;();\n\n    foreach (var entity in entities)\n    {\n        var transform = entity.GetComponent&lt;TransformComponent&gt;()!; // Lookup 1\n        var velocity = entity.GetComponent&lt;VelocityComponent&gt;()!;   // Lookup 2\n        // ...\n    }\n}</code></pre>"},{"location":"guides/ecs/systems/#use-enabled-flags","title":"Use Enabled Flags","text":"<p>Skip disabled components:</p> <pre><code>public void Update(GameTime gameTime)\n{\n    var entities = _world.GetEntitiesWithComponent&lt;MyComponent&gt;();\n\n    foreach (var entity in entities)\n    {\n        var component = entity.GetComponent&lt;MyComponent&gt;()!;\n\n        if (!component.IsEnabled) continue; // Skip disabled\n\n        // Process component\n    }\n}</code></pre>"},{"location":"guides/ecs/systems/#batch-processing","title":"Batch Processing","text":"<p>Process entities in batches for cache efficiency:</p> <pre><code>public void Update(GameTime gameTime)\n{\n    var entities = _world.GetEntitiesWithComponents&lt;TransformComponent, VelocityComponent&gt;();\n    var deltaTime = (float)gameTime.DeltaTime;\n\n    // Batch process all positions\n    foreach (var entity in entities)\n    {\n        var transform = entity.GetComponent&lt;TransformComponent&gt;()!;\n        var velocity = entity.GetComponent&lt;VelocityComponent&gt;()!;\n\n        transform.Position += velocity.Velocity * deltaTime;\n    }\n}</code></pre>"},{"location":"guides/ecs/systems/#quick-reference","title":"Quick Reference","text":""},{"location":"guides/ecs/systems/#system-checklist","title":"System Checklist","text":"<p>When creating a system, consider:</p> <ul> <li>\u2705 Does it implement <code>IUpdateSystem</code> or <code>IRenderSystem</code>?</li> <li>\u2705 Is the <code>UpdateOrder</code>/<code>RenderOrder</code> appropriate?</li> <li>\u2705 Does it query the right component combination?</li> <li>\u2705 Are component lookups minimized?</li> <li>\u2705 Are disabled components skipped?</li> <li>\u2705 Is it registered via <code>ConfigureSystemPipelines()</code>?</li> <li>\u2705 Can it be tested in isolation?</li> </ul>"},{"location":"guides/ecs/systems/#system-order-guidelines","title":"System Order Guidelines","text":"Order Range Purpose Examples 0-50 Input &amp; AI <code>PlayerControllerSystem</code>, <code>AISystem</code> 50-150 Physics Setup <code>GravitySystem</code>, <code>ForceSystem</code> 150-200 Movement <code>VelocitySystem</code> 200-300 Collision <code>PhysicsSystem</code>, <code>CollisionSystem</code> 300-500 Effects <code>AudioSystem</code>, <code>ParticleSystem</code> 500+ Camera &amp; UI <code>CameraSystem</code>"},{"location":"guides/ecs/systems/#next-steps","title":"Next Steps","text":"<p>Now that you understand systems, explore related topics:</p> <p>Scene Management - See how systems run automatically Components Guide - Learn when to use component logic vs systems Entities Guide - Master entity queries and management ECS Concepts - Deep dive into ECS architecture</p> <p>Remember: Systems are optional performance optimizations in Brine2D's hybrid ECS. Once registered via <code>ConfigureSystemPipelines()</code>, they run automatically via lifecycle hooks - no manual calls needed! For simple behaviors, component logic is often simpler and faster to develop.</p>"},{"location":"guides/events/window-events/","title":"Window Events","text":"<p>Learn how to respond to window state changes like resizing, minimizing, and focus events using Brine2D's event system.</p>"},{"location":"guides/events/window-events/#overview","title":"Overview","text":"<p>Window events allow your game to respond to changes in the window state, enabling responsive UI, dynamic resolution, and better user experience.</p> <p>What you'll learn:</p> <ul> <li>Subscribing to window events</li> <li>Handling window resize</li> <li>Responsive UI and camera adjustment</li> <li>Window lifecycle management</li> <li>Best practices for window event handling</li> </ul> <p>New in v0.7.0: - <code>EventBus</code> moved to <code>Brine2D.Core</code> for global accessibility - Built-in window event support - Automatic viewport updates in renderers</p>"},{"location":"guides/events/window-events/#prerequisites","title":"Prerequisites","text":"<ul> <li>Understanding of Dependency Injection</li> <li>Familiarity with Scenes</li> <li>Basic knowledge of EventBus (optional)</li> </ul>"},{"location":"guides/events/window-events/#quick-example","title":"Quick Example","text":""},{"location":"guides/events/window-events/#responding-to-window-resize","title":"Responding to Window Resize","text":"<pre><code>using Brine2D.Core;\nusing Brine2D.SDL.Common.Events;\nusing Microsoft.Extensions.Logging;\n\npublic class ResponsiveScene : Scene\n{\n    private readonly EventBus? _eventBus;\n    private readonly IRenderer _renderer;\n\n    private int _windowWidth = 1280;\n    private int _windowHeight = 720;\n\n    public ResponsiveScene(\n        EventBus? eventBus,\n        IRenderer renderer,\n        ILogger&lt;ResponsiveScene&gt; logger) : base(logger)\n    {\n        _eventBus = eventBus;\n        _renderer = renderer;\n    }\n\n    protected override void OnInitialize()\n    {\n        // Subscribe to window resize events\n        _eventBus?.Subscribe&lt;WindowResizedEvent&gt;(OnWindowResized);\n    }\n\n    private void OnWindowResized(WindowResizedEvent evt)\n    {\n        Logger.LogInformation(\"Window resized to {Width}x{Height}\", \n            evt.Width, evt.Height);\n\n        _windowWidth = evt.Width;\n        _windowHeight = evt.Height;\n\n        // Update UI layout\n        UpdateUILayout();\n    }\n\n    private void UpdateUILayout()\n    {\n        // Reposition UI elements based on new window size\n        // e.g., center menu, scale HUD, etc.\n    }\n\n    protected override void OnDispose()\n    {\n        // Always unsubscribe!\n        _eventBus?.Unsubscribe&lt;WindowResizedEvent&gt;(OnWindowResized);\n    }\n}</code></pre>"},{"location":"guides/events/window-events/#available-window-events","title":"Available Window Events","text":""},{"location":"guides/events/window-events/#windowresizedevent","title":"WindowResizedEvent","text":"<p>Raised when the window dimensions change.</p> <p>Event Definition:</p> <pre><code>// In Brine2D.SDL.Common.Events namespace\npublic record WindowResizedEvent(int Width, int Height);</code></pre> <p>When triggered: - User manually resizes window - Window maximized/restored - Fullscreen toggled - Display resolution changed</p> <p>Example:</p> <pre><code>_eventBus?.Subscribe&lt;WindowResizedEvent&gt;(evt =&gt;\n{\n    Logger.LogInformation(\"New size: {Width}x{Height}\", evt.Width, evt.Height);\n\n    // Renderer viewport is automatically updated\n    // Your code handles UI/camera adjustments\n});</code></pre>"},{"location":"guides/events/window-events/#setup-and-registration","title":"Setup and Registration","text":""},{"location":"guides/events/window-events/#register-eventbus","title":"Register EventBus","text":"<pre><code>using Brine2D.Core;\nusing Brine2D.Hosting;\nusing Brine2D.Rendering.SDL;\n\nvar builder = GameApplication.CreateBuilder(args);\n\n// Register EventBus (optional, but needed for custom events)\nbuilder.Services.AddSingleton&lt;EventBus&gt;();\n\n// Renderer automatically receives EventBus\nbuilder.Services.AddSDL3Rendering(options =&gt;\n{\n    builder.Configuration.GetSection(\"Rendering\").Bind(options);\n    options.Resizable = true;  // Enable window resizing\n});\n\nbuilder.Services.AddScene&lt;GameScene&gt;();\n\nvar game = builder.Build();\nawait game.RunAsync&lt;GameScene&gt;();</code></pre> <p>Note: If you don't register <code>EventBus</code>, the renderer still works but you won't receive window events in your scenes.</p>"},{"location":"guides/events/window-events/#subscribing-to-events","title":"Subscribing to Events","text":""},{"location":"guides/events/window-events/#method-1-in-oninitialize-recommended","title":"Method 1: In OnInitialize (Recommended)","text":"<pre><code>public class GameScene : Scene\n{\n    private readonly EventBus? _eventBus;\n\n    public GameScene(EventBus? eventBus, ILogger&lt;GameScene&gt; logger) : base(logger)\n    {\n        _eventBus = eventBus;\n    }\n\n    protected override void OnInitialize()\n    {\n        // Subscribe during initialization\n        _eventBus?.Subscribe&lt;WindowResizedEvent&gt;(OnWindowResized);\n    }\n\n    private void OnWindowResized(WindowResizedEvent evt)\n    {\n        // Handle resize\n    }\n\n    protected override void OnDispose()\n    {\n        // IMPORTANT: Always unsubscribe!\n        _eventBus?.Unsubscribe&lt;WindowResizedEvent&gt;(OnWindowResized);\n    }\n}</code></pre>"},{"location":"guides/events/window-events/#method-2-lambda-expression","title":"Method 2: Lambda Expression","text":"<pre><code>protected override void OnInitialize()\n{\n    _eventBus?.Subscribe&lt;WindowResizedEvent&gt;(evt =&gt;\n    {\n        Logger.LogInformation(\"Resized to {Width}x{Height}\", evt.Width, evt.Height);\n        UpdateLayout(evt.Width, evt.Height);\n    });\n}</code></pre> <p>\u26a0\ufe0f Warning: Lambda expressions are harder to unsubscribe from. Use named methods when possible.</p>"},{"location":"guides/events/window-events/#common-use-cases","title":"Common Use Cases","text":""},{"location":"guides/events/window-events/#1-responsive-ui-layout","title":"1. Responsive UI Layout","text":"<pre><code>public class MenuScene : Scene\n{\n    private readonly EventBus? _eventBus;\n    private readonly UICanvas _uiCanvas;\n\n    private UIButton _playButton;\n    private UIButton _settingsButton;\n    private UIButton _exitButton;\n\n    protected override void OnInitialize()\n    {\n        _eventBus?.Subscribe&lt;WindowResizedEvent&gt;(OnWindowResized);\n\n        // Initial layout\n        LayoutUI(_windowWidth, _windowHeight);\n    }\n\n    private void OnWindowResized(WindowResizedEvent evt)\n    {\n        LayoutUI(evt.Width, evt.Height);\n    }\n\n    private void LayoutUI(int width, int height)\n    {\n        // Center menu vertically and horizontally\n        var centerX = width / 2f;\n        var centerY = height / 2f;\n\n        var buttonWidth = 200f;\n        var buttonHeight = 50f;\n        var buttonSpacing = 60f;\n\n        _playButton.Position = new Vector2(\n            centerX - buttonWidth / 2,\n            centerY - buttonSpacing);\n\n        _settingsButton.Position = new Vector2(\n            centerX - buttonWidth / 2,\n            centerY);\n\n        _exitButton.Position = new Vector2(\n            centerX - buttonWidth / 2,\n            centerY + buttonSpacing);\n    }\n\n    protected override void OnDispose()\n    {\n        _eventBus?.Unsubscribe&lt;WindowResizedEvent&gt;(OnWindowResized);\n    }\n}</code></pre>"},{"location":"guides/events/window-events/#2-camera-viewport-adjustment","title":"2. Camera Viewport Adjustment","text":"<pre><code>using Brine2D.Rendering;\n\npublic class GameScene : Scene\n{\n    private readonly EventBus? _eventBus;\n    private readonly IRenderer _renderer;\n\n    private Camera2D? _camera;\n\n    protected override void OnInitialize()\n    {\n        // Create camera\n        _camera = new Camera2D(1280, 720)\n        {\n            Position = new Vector2(0, 0),\n            Zoom = 1.0f\n        };\n\n        _renderer.Camera = _camera;\n\n        // Subscribe to resize\n        _eventBus?.Subscribe&lt;WindowResizedEvent&gt;(OnWindowResized);\n    }\n\n    private void OnWindowResized(WindowResizedEvent evt)\n    {\n        if (_camera != null)\n        {\n            // Update camera viewport\n            _camera.ViewportWidth = evt.Width;\n            _camera.ViewportHeight = evt.Height;\n\n            Logger.LogInformation(\"Camera viewport updated to {Width}x{Height}\",\n                evt.Width, evt.Height);\n        }\n    }\n\n    protected override void OnDispose()\n    {\n        _eventBus?.Unsubscribe&lt;WindowResizedEvent&gt;(OnWindowResized);\n    }\n}</code></pre>"},{"location":"guides/events/window-events/#3-dynamic-resolution-scaling","title":"3. Dynamic Resolution Scaling","text":"<pre><code>public class PerformanceScene : Scene\n{\n    private readonly EventBus? _eventBus;\n\n    private float _renderScale = 1.0f;\n    private int _targetWidth = 1280;\n    private int _targetHeight = 720;\n\n    protected override void OnInitialize()\n    {\n        _eventBus?.Subscribe&lt;WindowResizedEvent&gt;(OnWindowResized);\n    }\n\n    private void OnWindowResized(WindowResizedEvent evt)\n    {\n        // Calculate scale factor\n        var widthScale = evt.Width / (float)_targetWidth;\n        var heightScale = evt.Height / (float)_targetHeight;\n\n        // Use smallest scale to maintain aspect ratio\n        _renderScale = Math.Min(widthScale, heightScale);\n\n        Logger.LogInformation(\"Render scale adjusted to {Scale:F2}\", _renderScale);\n\n        // Adjust rendering resolution\n        AdjustRenderResolution(_renderScale);\n    }\n\n    private void AdjustRenderResolution(float scale)\n    {\n        // Scale sprite sizes, font sizes, etc.\n        // Useful for maintaining performance on lower-end hardware\n    }\n\n    protected override void OnDispose()\n    {\n        _eventBus?.Unsubscribe&lt;WindowResizedEvent&gt;(OnWindowResized);\n    }\n}</code></pre>"},{"location":"guides/events/window-events/#4-hud-repositioning","title":"4. HUD Repositioning","text":"<pre><code>public class GameplayScene : Scene\n{\n    private readonly EventBus? _eventBus;\n    private readonly UICanvas _uiCanvas;\n\n    private UILabel _scoreLabel;\n    private UILabel _healthLabel;\n    private UILabel _fpsLabel;\n\n    protected override void OnInitialize()\n    {\n        _eventBus?.Subscribe&lt;WindowResizedEvent&gt;(OnWindowResized);\n\n        // Initial HUD layout\n        PositionHUD(_windowWidth, _windowHeight);\n    }\n\n    private void OnWindowResized(WindowResizedEvent evt)\n    {\n        PositionHUD(evt.Width, evt.Height);\n    }\n\n    private void PositionHUD(int width, int height)\n    {\n        // Top-left: Score\n        _scoreLabel.Position = new Vector2(10, 10);\n\n        // Top-right: FPS\n        _fpsLabel.Position = new Vector2(width - 100, 10);\n\n        // Bottom-left: Health\n        _healthLabel.Position = new Vector2(10, height - 40);\n    }\n\n    protected override void OnDispose()\n    {\n        _eventBus?.Unsubscribe&lt;WindowResizedEvent&gt;(OnWindowResized);\n    }\n}</code></pre>"},{"location":"guides/events/window-events/#5-aspect-ratio-maintenance","title":"5. Aspect Ratio Maintenance","text":"<pre><code>public class AspectRatioScene : Scene\n{\n    private readonly EventBus? _eventBus;\n    private readonly IRenderer _renderer;\n\n    private const float TargetAspectRatio = 16f / 9f;  // 16:9\n\n    private Rectangle _renderArea;\n\n    protected override void OnInitialize()\n    {\n        _eventBus?.Subscribe&lt;WindowResizedEvent&gt;(OnWindowResized);\n\n        // Calculate initial render area\n        CalculateRenderArea(_windowWidth, _windowHeight);\n    }\n\n    private void OnWindowResized(WindowResizedEvent evt)\n    {\n        CalculateRenderArea(evt.Width, evt.Height);\n    }\n\n    private void CalculateRenderArea(int windowWidth, int windowHeight)\n    {\n        var windowAspect = windowWidth / (float)windowHeight;\n\n        if (windowAspect &gt; TargetAspectRatio)\n        {\n            // Window is wider than target - letterbox sides\n            var renderWidth = (int)(windowHeight * TargetAspectRatio);\n            var offsetX = (windowWidth - renderWidth) / 2;\n\n            _renderArea = new Rectangle(offsetX, 0, renderWidth, windowHeight);\n        }\n        else\n        {\n            // Window is taller than target - letterbox top/bottom\n            var renderHeight = (int)(windowWidth / TargetAspectRatio);\n            var offsetY = (windowHeight - renderHeight) / 2;\n\n            _renderArea = new Rectangle(0, offsetY, windowWidth, renderHeight);\n        }\n\n        Logger.LogInformation(\"Render area: {X}, {Y}, {Width}x{Height}\",\n            _renderArea.X, _renderArea.Y, _renderArea.Width, _renderArea.Height);\n    }\n\n    protected override void OnRender(GameTime gameTime)\n    {\n        _renderer.Clear(Color.Black);\n        _renderer.BeginFrame();\n\n        // Draw letterbox bars (black)\n        // Your game renders within _renderArea\n\n        _renderer.EndFrame();\n    }\n\n    protected override void OnDispose()\n    {\n        _eventBus?.Unsubscribe&lt;WindowResizedEvent&gt;(OnWindowResized);\n    }\n}</code></pre>"},{"location":"guides/events/window-events/#best-practices","title":"Best Practices","text":""},{"location":"guides/events/window-events/#do","title":"DO","text":"<ol> <li>Always unsubscribe in OnDispose</li> </ol> <pre><code>protected override void OnDispose()\n{\n    _eventBus?.Unsubscribe&lt;WindowResizedEvent&gt;(OnWindowResized);\n}</code></pre> <ol> <li>Use named methods for event handlers</li> </ol> <pre><code>// \u2705 Good - easy to unsubscribe\n_eventBus?.Subscribe&lt;WindowResizedEvent&gt;(OnWindowResized);\n\nprivate void OnWindowResized(WindowResizedEvent evt)\n{\n    // Handle event\n}</code></pre> <ol> <li>Check for null EventBus</li> </ol> <pre><code>// \u2705 Good - EventBus is optional\n_eventBus?.Subscribe&lt;WindowResizedEvent&gt;(OnWindowResized);</code></pre> <ol> <li>Subscribe in OnInitialize</li> </ol> <pre><code>// \u2705 Good - consistent lifecycle\nprotected override void OnInitialize()\n{\n    _eventBus?.Subscribe&lt;WindowResizedEvent&gt;(OnWindowResized);\n}</code></pre> <ol> <li>Enable window resizing if needed</li> </ol> <pre><code>// \u2705 In configuration\noptions.Resizable = true;</code></pre>"},{"location":"guides/events/window-events/#dont","title":"DON'T","text":"<ol> <li>Don't forget to unsubscribe</li> </ol> <pre><code>// \u274c Bad - memory leak!\nprotected override void OnDispose()\n{\n    // Forgot to unsubscribe!\n}</code></pre> <ol> <li>Don't use lambdas without storing reference</li> </ol> <pre><code>// \u274c Bad - can't unsubscribe\n_eventBus?.Subscribe&lt;WindowResizedEvent&gt;(evt =&gt;\n{\n    // Can't unsubscribe this!\n});</code></pre> <ol> <li>Don't subscribe multiple times</li> </ol> <pre><code>// \u274c Bad - duplicate subscriptions\nprotected override void OnInitialize()\n{\n    _eventBus?.Subscribe&lt;WindowResizedEvent&gt;(OnWindowResized);\n    _eventBus?.Subscribe&lt;WindowResizedEvent&gt;(OnWindowResized);  // Duplicate!\n}</code></pre> <ol> <li>Don't assume EventBus exists</li> </ol> <pre><code>// \u274c Bad - might be null\n_eventBus.Subscribe&lt;WindowResizedEvent&gt;(OnWindowResized);\n\n// \u2705 Good - null-conditional\n_eventBus?.Subscribe&lt;WindowResizedEvent&gt;(OnWindowResized);</code></pre>"},{"location":"guides/events/window-events/#advanced-patterns","title":"Advanced Patterns","text":""},{"location":"guides/events/window-events/#debouncing-resize-events","title":"Debouncing Resize Events","text":"<p>Handle resize events after user finishes resizing:</p> <pre><code>public class DebouncedResizeScene : Scene\n{\n    private readonly EventBus? _eventBus;\n\n    private DateTime _lastResizeTime;\n    private int _pendingWidth;\n    private int _pendingHeight;\n    private bool _resizePending;\n\n    private const double DebounceMs = 500;  // Wait 500ms after last resize\n\n    protected override void OnInitialize()\n    {\n        _eventBus?.Subscribe&lt;WindowResizedEvent&gt;(OnWindowResized);\n    }\n\n    private void OnWindowResized(WindowResizedEvent evt)\n    {\n        // Store resize event\n        _lastResizeTime = DateTime.UtcNow;\n        _pendingWidth = evt.Width;\n        _pendingHeight = evt.Height;\n        _resizePending = true;\n    }\n\n    protected override void OnUpdate(GameTime gameTime)\n    {\n        if (_resizePending)\n        {\n            var elapsed = (DateTime.UtcNow - _lastResizeTime).TotalMilliseconds;\n\n            if (elapsed &gt;= DebounceMs)\n            {\n                // User stopped resizing - apply changes\n                ApplyResize(_pendingWidth, _pendingHeight);\n                _resizePending = false;\n            }\n        }\n    }\n\n    private void ApplyResize(int width, int height)\n    {\n        Logger.LogInformation(\"Applying resize to {Width}x{Height}\", width, height);\n\n        // Expensive operations here (e.g., regenerate UI, reload assets)\n    }\n\n    protected override void OnDispose()\n    {\n        _eventBus?.Unsubscribe&lt;WindowResizedEvent&gt;(OnWindowResized);\n    }\n}</code></pre>"},{"location":"guides/events/window-events/#multi-scene-event-handling","title":"Multi-Scene Event Handling","text":"<p>Share window state across scenes:</p> <pre><code>// Shared service\npublic class WindowStateService\n{\n    public int Width { get; private set; } = 1280;\n    public int Height { get; private set; } = 720;\n\n    public event Action&lt;int, int&gt;? SizeChanged;\n\n    public void UpdateSize(int width, int height)\n    {\n        Width = width;\n        Height = height;\n        SizeChanged?.Invoke(width, height);\n    }\n}</code></pre> <pre><code>// Register as singleton\nbuilder.Services.AddSingleton&lt;WindowStateService&gt;();\n\n// Initialize with EventBus\nbuilder.Services.AddSingleton(provider =&gt;\n{\n    var windowState = new WindowStateService();\n    var eventBus = provider.GetService&lt;EventBus&gt;();\n\n    eventBus?.Subscribe&lt;WindowResizedEvent&gt;(evt =&gt;\n    {\n        windowState.UpdateSize(evt.Width, evt.Height);\n    });\n\n    return windowState;\n});</code></pre> <pre><code>// Use in scenes\npublic class GameScene : Scene\n{\n    private readonly WindowStateService _windowState;\n\n    public GameScene(WindowStateService windowState, ILogger&lt;GameScene&gt; logger) \n        : base(logger)\n    {\n        _windowState = windowState;\n        _windowState.SizeChanged += OnSizeChanged;\n    }\n\n    private void OnSizeChanged(int width, int height)\n    {\n        // Handle resize\n    }\n\n    protected override void OnDispose()\n    {\n        _windowState.SizeChanged -= OnSizeChanged;\n    }\n}</code></pre>"},{"location":"guides/events/window-events/#renderer-integration","title":"Renderer Integration","text":"<p>Both GPU and Legacy renderers automatically handle window events:</p> <pre><code>// In SDL3GPURenderer / SDL3Renderer\npublic SDL3Renderer(\n    ILogger&lt;SDL3Renderer&gt; logger,\n    ILoggerFactory loggerFactory,\n    IOptions&lt;RenderingOptions&gt; options,\n    IFontLoader? fontLoader = null,\n    EventBus? eventBus = null)  // EventBus injected\n{\n    _eventBus = eventBus;\n\n    // Renderer subscribes to window events\n    _eventBus?.Subscribe&lt;WindowResizedEvent&gt;(OnWindowResized);\n}\n\nprivate void OnWindowResized(WindowResizedEvent evt)\n{\n    // Renderer updates viewport automatically\n    _viewport.Update(evt.Width, evt.Height);\n    UpdateProjectionMatrix(_viewport.Width, _viewport.Height);\n}</code></pre> <p>What this means: - Renderer viewport updates automatically - You don't need to update renderer manually - Focus on UI/camera adjustments in your scenes</p>"},{"location":"guides/events/window-events/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guides/events/window-events/#problem-not-receiving-events","title":"Problem: Not Receiving Events","text":"<p>Symptom: Window resize handler never called</p> <p>Solutions:</p> <ol> <li> <p>Check EventBus registration <pre><code>// Make sure EventBus is registered\nbuilder.Services.AddSingleton&lt;EventBus&gt;();</code></pre></p> </li> <li> <p>Verify subscription <pre><code>protected override void OnInitialize()\n{\n    _eventBus?.Subscribe&lt;WindowResizedEvent&gt;(OnWindowResized);\n    Logger.LogInformation(\"Subscribed to WindowResizedEvent\");\n}</code></pre></p> </li> <li> <p>Check window is resizable <pre><code>{\n  \"Rendering\": {\n    \"Resizable\": true  // Must be true!\n  }\n}</code></pre></p> </li> </ol>"},{"location":"guides/events/window-events/#problem-memory-leak","title":"Problem: Memory Leak","text":"<p>Symptom: Memory usage increases over time</p> <p>Cause: Not unsubscribing from events</p> <p>Solution:</p> <pre><code>// \u2705 Always unsubscribe\nprotected override void OnDispose()\n{\n    _eventBus?.Unsubscribe&lt;WindowResizedEvent&gt;(OnWindowResized);\n    base.OnDispose();\n}</code></pre>"},{"location":"guides/events/window-events/#problem-event-fired-multiple-times","title":"Problem: Event Fired Multiple Times","text":"<p>Symptom: Handler called multiple times for single resize</p> <p>Cause: Multiple subscriptions</p> <p>Solution:</p> <pre><code>// \u2705 Subscribe only once\nprotected override void OnInitialize()\n{\n    // Unsubscribe first (if reinitializing)\n    _eventBus?.Unsubscribe&lt;WindowResizedEvent&gt;(OnWindowResized);\n\n    // Then subscribe\n    _eventBus?.Subscribe&lt;WindowResizedEvent&gt;(OnWindowResized);\n}</code></pre>"},{"location":"guides/events/window-events/#complete-example","title":"Complete Example","text":"<p>Here's a full responsive game scene:</p> <pre><code>using Brine2D.Core;\nusing Brine2D.Input;\nusing Brine2D.Rendering;\nusing Brine2D.SDL.Common.Events;\nusing Brine2D.UI;\nusing Microsoft.Extensions.Logging;\nusing System.Numerics;\n\npublic class ResponsiveGameScene : Scene\n{\n    private readonly IRenderer _renderer;\n    private readonly IInputService _input;\n    private readonly IGameContext _gameContext;\n    private readonly EventBus? _eventBus;\n    private readonly UICanvas _uiCanvas;\n\n    private Camera2D? _camera;\n    private int _windowWidth = 1280;\n    private int _windowHeight = 720;\n\n    // UI elements\n    private UILabel? _scoreLabel;\n    private UILabel? _fpsLabel;\n    private UIButton? _pauseButton;\n\n    public ResponsiveGameScene(\n        IRenderer renderer,\n        IInputService input,\n        IGameContext gameContext,\n        EventBus? eventBus,\n        UICanvas uiCanvas,\n        ILogger&lt;ResponsiveGameScene&gt; logger) : base(logger)\n    {\n        _renderer = renderer;\n        _input = input;\n        _gameContext = gameContext;\n        _eventBus = eventBus;\n        _uiCanvas = uiCanvas;\n    }\n\n    protected override void OnInitialize()\n    {\n        // Create camera\n        _camera = new Camera2D(_windowWidth, _windowHeight);\n        _renderer.Camera = _camera;\n\n        // Create UI\n        CreateUI();\n\n        // Subscribe to window events\n        _eventBus?.Subscribe&lt;WindowResizedEvent&gt;(OnWindowResized);\n\n        Logger.LogInformation(\"ResponsiveGameScene initialized\");\n    }\n\n    private void CreateUI()\n    {\n        // Score (top-left)\n        _scoreLabel = new UILabel(\"Score: 0\", new Vector2(10, 10))\n        {\n            FontSize = 24,\n            Color = Color.White\n        };\n        _uiCanvas.Add(_scoreLabel);\n\n        // FPS (top-right)\n        _fpsLabel = new UILabel(\"FPS: 60\", new Vector2(_windowWidth - 100, 10))\n        {\n            FontSize = 18,\n            Color = Color.Yellow\n        };\n        _uiCanvas.Add(_fpsLabel);\n\n        // Pause button (center-top)\n        _pauseButton = new UIButton(\"Pause\", new Vector2(0, 10), new Vector2(100, 40));\n        _pauseButton.OnClick += OnPauseClicked;\n        _uiCanvas.Add(_pauseButton);\n\n        // Position pause button\n        PositionPauseButton(_windowWidth);\n    }\n\n    private void OnWindowResized(WindowResizedEvent evt)\n    {\n        Logger.LogInformation(\"Window resized to {Width}x{Height}\", \n            evt.Width, evt.Height);\n\n        _windowWidth = evt.Width;\n        _windowHeight = evt.Height;\n\n        // Update camera viewport\n        if (_camera != null)\n        {\n            _camera.ViewportWidth = evt.Width;\n            _camera.ViewportHeight = evt.Height;\n        }\n\n        // Update UI layout\n        UpdateUILayout();\n    }\n\n    private void UpdateUILayout()\n    {\n        if (_fpsLabel != null)\n        {\n            // Keep FPS in top-right\n            _fpsLabel.Position = new Vector2(_windowWidth - 100, 10);\n        }\n\n        if (_pauseButton != null)\n        {\n            // Keep pause button centered horizontally\n            PositionPauseButton(_windowWidth);\n        }\n    }\n\n    private void PositionPauseButton(int width)\n    {\n        if (_pauseButton != null)\n        {\n            var buttonWidth = 100f;\n            _pauseButton.Position = new Vector2(\n                (width - buttonWidth) / 2,\n                10);\n        }\n    }\n\n    private void OnPauseClicked()\n    {\n        Logger.LogInformation(\"Pause clicked\");\n        // Handle pause\n    }\n\n    protected override void OnUpdate(GameTime gameTime)\n    {\n        // Exit\n        if (_input.IsKeyPressed(Keys.Escape))\n        {\n            _gameContext.RequestExit();\n        }\n\n        // Update FPS display\n        if (_fpsLabel != null)\n        {\n            var fps = (int)(1.0 / gameTime.DeltaTime);\n            _fpsLabel.Text = $\"FPS: {fps}\";\n        }\n    }\n\n    protected override void OnRender(GameTime gameTime)\n    {\n        _renderer.Clear(Color.CornflowerBlue);\n        _renderer.BeginFrame();\n\n        // Game rendering here...\n\n        _renderer.EndFrame();\n    }\n\n    protected override void OnDispose()\n    {\n        // IMPORTANT: Unsubscribe from events\n        _eventBus?.Unsubscribe&lt;WindowResizedEvent&gt;(OnWindowResized);\n\n        // Cleanup UI\n        if (_pauseButton != null)\n        {\n            _pauseButton.OnClick -= OnPauseClicked;\n        }\n\n        Logger.LogInformation(\"ResponsiveGameScene disposed\");\n\n        base.OnDispose();\n    }\n}</code></pre>"},{"location":"guides/events/window-events/#summary","title":"Summary","text":"Task Code Notes Register EventBus <code>builder.Services.AddSingleton&lt;EventBus&gt;()</code> Optional, in Program.cs Subscribe <code>_eventBus?.Subscribe&lt;WindowResizedEvent&gt;(handler)</code> In OnInitialize Unsubscribe <code>_eventBus?.Unsubscribe&lt;WindowResizedEvent&gt;(handler)</code> In OnDispose Event data <code>evt.Width</code>, <code>evt.Height</code> Window dimensions Enable resize <code>options.Resizable = true</code> In config Namespace <code>using Brine2D.SDL.Common.Events;</code> For WindowResizedEvent"},{"location":"guides/events/window-events/#next-steps","title":"Next Steps","text":"<ul> <li>UI Components - Build responsive UI</li> <li>Cameras - Camera viewport management</li> <li>Event System - Custom events with EventBus</li> <li>GPU Renderer - Modern rendering</li> </ul> <p>Ready to build responsive games? Try UI Components next!</p>"},{"location":"guides/input/gamepad/","title":"Gamepad Support","text":"<p>Add full controller support to your game with Xbox, PlayStation, and generic gamepad compatibility.</p>"},{"location":"guides/input/gamepad/#overview","title":"Overview","text":"<p>Brine2D provides comprehensive gamepad support via <code>IInputService</code>: - \u2705 Universal compatibility - Xbox, PlayStation, Switch Pro, generic - \u2705 Buttons - Face buttons, shoulders, D-pad, start/back - \u2705 Analog sticks - Left/right sticks with deadzone - \u2705 Triggers - Left/right analog triggers - \u2705 Hot-plug - Automatic connect/disconnect detection - \u2705 Multiple controllers - Support up to 4 gamepads</p> <pre><code>graph TB\n    subgraph Controllers\n        A[\"Xbox Controller\"]\n        B[\"PlayStation Controller\"]\n        C[\"Switch Pro Controller\"]\n        D[\"Generic Gamepad\"]\n    end\n\n    subgraph \"Brine2D Input\"\n        E[\"SDL3 Gamepad API\"]\n        F[\"IInputService\"]\n    end\n\n    subgraph \"Your Game\"\n        G[\"Scene\"]\n    end\n\n    A --&gt; E\n    B --&gt; E\n    C --&gt; E\n    D --&gt; E\n\n    E --&gt; F\n    F --&gt; G\n\n    style A fill:#4a3d1f,stroke:#ce9178,stroke-width:2px,color:#fff\n    style B fill:#4a3d1f,stroke:#ce9178,stroke-width:2px,color:#fff\n    style C fill:#4a3d1f,stroke:#ce9178,stroke-width:2px,color:#fff\n    style D fill:#4a3d1f,stroke:#ce9178,stroke-width:2px,color:#fff\n    style E fill:#2d5016,stroke:#4ec9b0,stroke-width:2px,color:#fff\n    style F fill:#1e3a5f,stroke:#569cd6,stroke-width:2px,color:#fff\n    style G fill:#264f78,stroke:#4fc1ff,stroke-width:2px,color:#fff</code></pre>"},{"location":"guides/input/gamepad/#prerequisites","title":"Prerequisites","text":"<ul> <li>\u2705 Quick Start - Basic scene setup</li> <li>\u2705 Keyboard Input - Understanding input basics</li> <li>\u2705 A gamepad/controller connected</li> </ul>"},{"location":"guides/input/gamepad/#quick-example","title":"Quick Example","text":"<pre><code>using Brine2D.Core;\nusing Brine2D.Input;\nusing Brine2D.Rendering;\nusing Microsoft.Extensions.Logging;\nusing System.Numerics;\n\npublic class GamepadScene : Scene\n{\n    private readonly IInputService _input;\n    private readonly IRenderer _renderer;\n    private readonly IGameContext _gameContext;\n\n    private Vector2 _playerPosition = new Vector2(400, 300);\n    private float _speed = 200f;\n\n    public GamepadScene(\n        IInputService input,\n        IRenderer renderer,\n        IGameContext gameContext,\n        ILogger&lt;GamepadScene&gt; logger\n    ) : base(logger)\n    {\n        _input = input;\n        _renderer = renderer;\n        _gameContext = gameContext;\n    }\n\n    protected override void OnUpdate(GameTime gameTime)\n    {\n        var deltaTime = (float)gameTime.DeltaTime;\n\n        // Check if gamepad is connected\n        if (!_input.IsGamepadConnected())\n        {\n            return; // No gamepad, skip input\n        }\n\n        // Get left stick for movement\n        var leftStick = _input.GetGamepadLeftStick();\n        _playerPosition += leftStick * _speed * deltaTime;\n\n        // Jump on A button\n        if (_input.IsGamepadButtonPressed(GamepadButton.A))\n        {\n            Logger.LogInformation(\"Jump!\");\n        }\n\n        // Exit on Start button\n        if (_input.IsGamepadButtonPressed(GamepadButton.Start))\n        {\n            _gameContext.RequestExit();\n        }\n    }\n\n    protected override void OnRender(GameTime gameTime)\n    {\n        _renderer.Clear(Color.Black);\n        _renderer.BeginFrame();\n\n        // Draw player\n        _renderer.DrawRectangle(\n            _playerPosition.X - 25, _playerPosition.Y - 25,\n            50, 50, Color.Green);\n\n        // Show controller status\n        var status = _input.IsGamepadConnected() \n            ? \"Controller Connected\" \n            : \"No Controller\";\n        _renderer.DrawText(status, 10, 10, Color.White);\n\n        _renderer.EndFrame();\n    }\n}</code></pre> <p>Result: Move with left stick, jump with A, exit with Start!</p>"},{"location":"guides/input/gamepad/#controller-layout","title":"Controller Layout","text":""},{"location":"guides/input/gamepad/#universal-button-mapping","title":"Universal Button Mapping","text":"<p>Brine2D uses Xbox-style naming that maps correctly to all controllers:</p> <pre><code>         [LB]              [RB]          \u2190 Shoulder Buttons\n\n    [LT]                      [RT]       \u2190 Triggers (analog)\n\n         [Back]  (O)  [Start]            \u2190 System Buttons\n                                           O = Guide/Home\n\n         [D-Pad]          [Y]             \u2190 Face Buttons\n          \u2191               / \\\n        \u2190   \u2192           [X] [B]\n          \u2193               [A]\n\n    [Left Stick]    [Right Stick]       \u2190 Analog Sticks (clickable)\n         (\u2299)             (\u2299)</code></pre> Xbox PlayStation Nintendo Switch A Cross (X) B B Circle (O) A X Square (\u25a1) Y Y Triangle (\u25b3) X LB L1 L RB R1 R LT L2 ZL RT R2 ZR Left Stick L3 (click) L Stick (click) Right Stick R3 (click) R Stick (click) Back Select/Share Minus (-) Start Start/Options Plus (+) Guide PS Button Home"},{"location":"guides/input/gamepad/#connection-detection","title":"Connection Detection","text":""},{"location":"guides/input/gamepad/#check-if-gamepad-is-connected","title":"Check if Gamepad is Connected","text":"<pre><code>protected override void OnUpdate(GameTime gameTime)\n{\n    // Check if any gamepad is connected\n    if (_input.IsGamepadConnected())\n    {\n        // Gamepad available!\n        HandleGamepadInput();\n    }\n    else\n    {\n        // Fallback to keyboard/mouse\n        HandleKeyboardInput();\n    }\n}</code></pre>"},{"location":"guides/input/gamepad/#multiple-gamepads","title":"Multiple Gamepads","text":"<pre><code>protected override void OnUpdate(GameTime gameTime)\n{\n    // Check specific gamepad indices (0-3)\n    if (_input.IsGamepadConnected(0)) // Player 1\n    {\n        HandlePlayer1Input(0);\n    }\n\n    if (_input.IsGamepadConnected(1)) // Player 2\n    {\n        HandlePlayer2Input(1);\n    }\n}</code></pre> <p>Indices: - <code>0</code> = Player 1 (default) - <code>1</code> = Player 2 - <code>2</code> = Player 3 - <code>3</code> = Player 4</p>"},{"location":"guides/input/gamepad/#buttons","title":"Buttons","text":""},{"location":"guides/input/gamepad/#available-buttons","title":"Available Buttons","text":"<pre><code>// Face buttons (right side)\nGamepadButton.A        // Bottom (Xbox A, PS Cross)\nGamepadButton.B        // Right (Xbox B, PS Circle)\nGamepadButton.X        // Left (Xbox X, PS Square)\nGamepadButton.Y        // Top (Xbox Y, PS Triangle)\n\n// Shoulder buttons\nGamepadButton.LeftShoulder   // LB, L1\nGamepadButton.RightShoulder  // RB, R1\n\n// Stick clicks\nGamepadButton.LeftStick      // L3 click\nGamepadButton.RightStick     // R3 click\n\n// D-Pad\nGamepadButton.DPadUp\nGamepadButton.DPadDown\nGamepadButton.DPadLeft\nGamepadButton.DPadRight\n\n// System buttons\nGamepadButton.Start          // Start, Options, Plus\nGamepadButton.Back           // Back, Select, Minus\nGamepadButton.Guide          // Xbox/PS/Home button</code></pre>"},{"location":"guides/input/gamepad/#button-states","title":"Button States","text":""},{"location":"guides/input/gamepad/#isgamepadbuttondown-held-detection","title":"IsGamepadButtonDown - Held Detection","text":"<pre><code>protected override void OnUpdate(GameTime gameTime)\n{\n    // Returns TRUE while button is held\n    if (_input.IsGamepadButtonDown(GamepadButton.A))\n    {\n        ChargeAttack(); // Continuous charging\n    }\n}</code></pre>"},{"location":"guides/input/gamepad/#isgamepadbuttonpressed-press-detection","title":"IsGamepadButtonPressed - Press Detection","text":"<pre><code>protected override void OnUpdate(GameTime gameTime)\n{\n    // Returns TRUE only on first frame of press\n    if (_input.IsGamepadButtonPressed(GamepadButton.A))\n    {\n        Jump(); // One jump per press\n    }\n\n    if (_input.IsGamepadButtonPressed(GamepadButton.X))\n    {\n        Attack(); // One attack per press\n    }\n}</code></pre>"},{"location":"guides/input/gamepad/#isgamepadbuttonreleased-release-detection","title":"IsGamepadButtonReleased - Release Detection","text":"<pre><code>private bool _isChargingAttack = false;\nprivate float _chargeTime = 0f;\n\nprotected override void OnUpdate(GameTime gameTime)\n{\n    var deltaTime = (float)gameTime.DeltaTime;\n\n    // Start charging\n    if (_input.IsGamepadButtonPressed(GamepadButton.B))\n    {\n        _isChargingAttack = true;\n        _chargeTime = 0f;\n    }\n\n    // Accumulate charge\n    if (_isChargingAttack &amp;&amp; _input.IsGamepadButtonDown(GamepadButton.B))\n    {\n        _chargeTime += deltaTime;\n    }\n\n    // Release - fire charged attack\n    if (_input.IsGamepadButtonReleased(GamepadButton.B))\n    {\n        if (_isChargingAttack)\n        {\n            FireChargedAttack(_chargeTime);\n            _isChargingAttack = false;\n        }\n    }\n}</code></pre>"},{"location":"guides/input/gamepad/#analog-sticks","title":"Analog Sticks","text":""},{"location":"guides/input/gamepad/#get-stick-input","title":"Get Stick Input","text":"<pre><code>protected override void OnUpdate(GameTime gameTime)\n{\n    var deltaTime = (float)gameTime.DeltaTime;\n\n    // Get left stick (-1 to 1 for each axis)\n    var leftStick = _input.GetGamepadLeftStick();\n\n    // Get right stick\n    var rightStick = _input.GetGamepadRightStick();\n\n    // Use for movement\n    if (leftStick.LengthSquared() &gt; 0.01f) // Deadzone check\n    {\n        _playerPosition += leftStick * _speed * deltaTime;\n    }\n\n    // Use for camera/aiming\n    if (rightStick.LengthSquared() &gt; 0.01f)\n    {\n        _cameraRotation += rightStick * _cameraSensitivity * deltaTime;\n    }\n}</code></pre> <p>Returns: - <code>Vector2(-1 to 1, -1 to 1)</code> - <code>X</code> axis: -1 = left, +1 = right - <code>Y</code> axis: -1 = up, +1 = down</p> <pre><code>Stick Coordinates:\n       Y-\n       |\n  (-1,0)|  (1,0)\n-X ----+---- X+\n  (-1,0)|  (1,0)\n       |\n       Y+\n\nCenter = (0, 0)\nFully pushed = (\u00b11, \u00b11)</code></pre>"},{"location":"guides/input/gamepad/#individual-axes","title":"Individual Axes","text":"<pre><code>protected override void OnUpdate(GameTime gameTime)\n{\n    // Get individual axis values\n    var leftX = _input.GetGamepadAxis(GamepadAxis.LeftX);   // -1 to 1\n    var leftY = _input.GetGamepadAxis(GamepadAxis.LeftY);   // -1 to 1\n    var rightX = _input.GetGamepadAxis(GamepadAxis.RightX); // -1 to 1\n    var rightY = _input.GetGamepadAxis(GamepadAxis.RightY); // -1 to 1\n}</code></pre>"},{"location":"guides/input/gamepad/#deadzone-handling","title":"Deadzone Handling","text":"<p>Apply deadzone to avoid stick drift:</p> <pre><code>public static Vector2 ApplyDeadzone(Vector2 stick, float deadzone = 0.15f)\n{\n    var magnitude = stick.Length();\n\n    if (magnitude &lt; deadzone)\n    {\n        return Vector2.Zero; // Inside deadzone\n    }\n\n    // Rescale to 0-1 range outside deadzone\n    var normalized = stick / magnitude;\n    var scaledMagnitude = (magnitude - deadzone) / (1.0f - deadzone);\n\n    return normalized * scaledMagnitude;\n}\n\n// Usage\nvar leftStick = ApplyDeadzone(_input.GetGamepadLeftStick(), 0.15f);</code></pre> <p>Why? Controllers have slight drift near center. Deadzone prevents unwanted movement.</p>"},{"location":"guides/input/gamepad/#triggers","title":"Triggers","text":""},{"location":"guides/input/gamepad/#get-trigger-values","title":"Get Trigger Values","text":"<pre><code>protected override void OnUpdate(GameTime gameTime)\n{\n    // Get trigger values (0 to 1)\n    var leftTrigger = _input.GetGamepadAxis(GamepadAxis.LeftTrigger);\n    var rightTrigger = _input.GetGamepadAxis(GamepadAxis.RightTrigger);\n\n    // Use for analog control\n    if (leftTrigger &gt; 0.1f) // Slight deadzone\n    {\n        Brake(leftTrigger); // Brake proportional to trigger\n    }\n\n    if (rightTrigger &gt; 0.1f)\n    {\n        Accelerate(rightTrigger); // Accelerate proportional to trigger\n    }\n}</code></pre> <p>Returns: - <code>0.0f</code> = Not pressed - <code>1.0f</code> = Fully pressed - Values between for partial press</p>"},{"location":"guides/input/gamepad/#trigger-as-button","title":"Trigger as Button","text":"<pre><code>protected override void OnUpdate(GameTime gameTime)\n{\n    var rightTrigger = _input.GetGamepadAxis(GamepadAxis.RightTrigger);\n\n    // Treat as button (threshold)\n    if (rightTrigger &gt; 0.8f) // 80% pressed = \"down\"\n    {\n        Shoot();\n    }\n}</code></pre>"},{"location":"guides/input/gamepad/#common-patterns","title":"Common Patterns","text":""},{"location":"guides/input/gamepad/#pattern-1-stick-movement","title":"Pattern 1: Stick Movement","text":"<pre><code>protected override void OnUpdate(GameTime gameTime)\n{\n    if (!_input.IsGamepadConnected()) return;\n\n    var deltaTime = (float)gameTime.DeltaTime;\n    var leftStick = _input.GetGamepadLeftStick();\n\n    // Apply deadzone\n    if (leftStick.LengthSquared() &lt; 0.15f * 0.15f)\n    {\n        leftStick = Vector2.Zero;\n    }\n\n    // Apply movement\n    _playerPosition += leftStick * _speed * deltaTime;\n}</code></pre>"},{"location":"guides/input/gamepad/#pattern-2-d-pad-menu-navigation","title":"Pattern 2: D-Pad Menu Navigation","text":"<pre><code>private int _selectedIndex = 0;\n\nprotected override void OnUpdate(GameTime gameTime)\n{\n    if (!_input.IsGamepadConnected()) return;\n\n    if (_input.IsGamepadButtonPressed(GamepadButton.DPadUp))\n    {\n        _selectedIndex = Math.Max(0, _selectedIndex - 1);\n    }\n\n    if (_input.IsGamepadButtonPressed(GamepadButton.DPadDown))\n    {\n        _selectedIndex = Math.Min(_menuItems.Length - 1, _selectedIndex + 1);\n    }\n\n    if (_input.IsGamepadButtonPressed(GamepadButton.A))\n    {\n        SelectMenuItem(_selectedIndex);\n    }\n}</code></pre>"},{"location":"guides/input/gamepad/#pattern-3-twin-stick-shooter","title":"Pattern 3: Twin-Stick Shooter","text":"<pre><code>protected override void OnUpdate(GameTime gameTime)\n{\n    if (!_input.IsGamepadConnected()) return;\n\n    var deltaTime = (float)gameTime.DeltaTime;\n\n    // Left stick = movement\n    var leftStick = _input.GetGamepadLeftStick();\n    if (leftStick.LengthSquared() &gt; 0.01f)\n    {\n        _playerPosition += leftStick * _moveSpeed * deltaTime;\n    }\n\n    // Right stick = aiming\n    var rightStick = _input.GetGamepadRightStick();\n    if (rightStick.LengthSquared() &gt; 0.01f)\n    {\n        _aimDirection = rightStick;\n\n        // Auto-fire when aiming\n        FireBullet(_aimDirection);\n    }\n}</code></pre>"},{"location":"guides/input/gamepad/#pattern-4-racing-game-controls","title":"Pattern 4: Racing Game Controls","text":"<pre><code>protected override void OnUpdate(GameTime gameTime)\n{\n    if (!_input.IsGamepadConnected()) return;\n\n    var deltaTime = (float)gameTime.DeltaTime;\n\n    // Left stick X = steering\n    var steer = _input.GetGamepadAxis(GamepadAxis.LeftX);\n    _carRotation += steer * _steerSpeed * deltaTime;\n\n    // Right trigger = accelerate\n    var accelerate = _input.GetGamepadAxis(GamepadAxis.RightTrigger);\n    _carSpeed += accelerate * _acceleration * deltaTime;\n\n    // Left trigger = brake\n    var brake = _input.GetGamepadAxis(GamepadAxis.LeftTrigger);\n    _carSpeed -= brake * _brakeForce * deltaTime;\n\n    _carSpeed = Math.Max(0, _carSpeed); // No reverse\n}</code></pre>"},{"location":"guides/input/gamepad/#pattern-5-combo-input-fighting-game","title":"Pattern 5: Combo Input (Fighting Game)","text":"<pre><code>private readonly Queue&lt;GamepadButton&gt; _inputBuffer = new();\nprivate const int BufferSize = 5;\n\nprotected override void OnUpdate(GameTime gameTime)\n{\n    if (!_input.IsGamepadConnected()) return;\n\n    // Add pressed buttons to buffer\n    foreach (GamepadButton button in Enum.GetValues&lt;GamepadButton&gt;())\n    {\n        if (_input.IsGamepadButtonPressed(button))\n        {\n            _inputBuffer.Enqueue(button);\n\n            if (_inputBuffer.Count &gt; BufferSize)\n            {\n                _inputBuffer.Dequeue();\n            }\n        }\n    }\n\n    // Check for combo: Down, Right, A\n    CheckCombo();\n}\n\nprivate void CheckCombo()\n{\n    var sequence = _inputBuffer.ToArray();\n\n    if (sequence.Length &gt;= 3 &amp;&amp;\n        sequence[^3] == GamepadButton.DPadDown &amp;&amp;\n        sequence[^2] == GamepadButton.DPadRight &amp;&amp;\n        sequence[^1] == GamepadButton.A)\n    {\n        ExecuteSpecialMove();\n        _inputBuffer.Clear();\n    }\n}</code></pre>"},{"location":"guides/input/gamepad/#advanced-techniques","title":"Advanced Techniques","text":""},{"location":"guides/input/gamepad/#rumblevibration","title":"Rumble/Vibration","text":"<p>Note: SDL3 supports rumble, but not yet exposed in Brine2D API. Coming soon!</p> <pre><code>// Future API:\n_input.GamepadRumble(0, lowFreq: 0.5f, highFreq: 1.0f, duration: 0.3f);</code></pre>"},{"location":"guides/input/gamepad/#button-prompts","title":"Button Prompts","text":"<p>Display correct button icons for detected controller:</p> <pre><code>public class GamepadPrompts\n{\n    public enum ControllerType\n    {\n        Xbox,\n        PlayStation,\n        Switch,\n        Generic\n    }\n\n    public static ControllerType DetectController(IInputService input)\n    {\n        // SDL3 provides controller name\n        // Can detect from name string\n        return ControllerType.Xbox; // Default\n    }\n\n    public static string GetButtonPrompt(GamepadButton button, ControllerType type)\n    {\n        return (button, type) switch\n        {\n            (GamepadButton.A, ControllerType.Xbox) =&gt; \"A\",\n            (GamepadButton.A, ControllerType.PlayStation) =&gt; \"Cross\",\n            (GamepadButton.A, ControllerType.Switch) =&gt; \"B\",\n\n            (GamepadButton.B, ControllerType.Xbox) =&gt; \"B\",\n            (GamepadButton.B, ControllerType.PlayStation) =&gt; \"Circle\",\n            (GamepadButton.B, ControllerType.Switch) =&gt; \"A\",\n\n            _ =&gt; button.ToString()\n        };\n    }\n}</code></pre>"},{"location":"guides/input/gamepad/#input-abstraction-layer","title":"Input Abstraction Layer","text":"<p>Map gamepad and keyboard to actions:</p> <pre><code>public class InputMapper\n{\n    private readonly IInputService _input;\n\n    public bool IsJumpPressed()\n    {\n        // Check both keyboard and gamepad\n        return _input.IsKeyPressed(Keys.Space) ||\n               (_input.IsGamepadConnected() &amp;&amp; \n                _input.IsGamepadButtonPressed(GamepadButton.A));\n    }\n\n    public Vector2 GetMovementInput()\n    {\n        // Gamepad takes priority\n        if (_input.IsGamepadConnected())\n        {\n            return _input.GetGamepadLeftStick();\n        }\n\n        // Fallback to WASD\n        var movement = Vector2.Zero;\n        if (_input.IsKeyDown(Keys.W)) movement.Y -= 1;\n        if (_input.IsKeyDown(Keys.S)) movement.Y += 1;\n        if (_input.IsKeyDown(Keys.A)) movement.X -= 1;\n        if (_input.IsKeyDown(Keys.D)) movement.X += 1;\n\n        if (movement != Vector2.Zero)\n            movement = Vector2.Normalize(movement);\n\n        return movement;\n    }\n}</code></pre>"},{"location":"guides/input/gamepad/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guides/input/gamepad/#problem-gamepad-not-detected","title":"Problem: Gamepad Not Detected","text":"<p>Symptom: <code>IsGamepadConnected()</code> returns false</p> <p>Solutions:</p> <ol> <li>Check connection</li> <li>Plug in controller</li> <li>Check USB/Bluetooth connection</li> <li> <p>Try different USB port</p> </li> <li> <p>Check logs <pre><code>// Brine2D logs gamepad detection\n// Look for: \"Found X gamepad(s)\" or \"Gamepad X connected\"</code></pre></p> </li> <li> <p>Test with other software</p> </li> <li>Verify controller works in other games</li> <li>Test with gamepad tester tools</li> </ol>"},{"location":"guides/input/gamepad/#problem-stick-drift","title":"Problem: Stick Drift","text":"<p>Symptom: Player moves without touching stick</p> <p>Solution: Apply deadzone:</p> <pre><code>private const float Deadzone = 0.15f;\n\nvar stick = _input.GetGamepadLeftStick();\n\nif (stick.Length() &lt; Deadzone)\n{\n    stick = Vector2.Zero; // Ignore drift\n}</code></pre>"},{"location":"guides/input/gamepad/#problem-wrong-buttons","title":"Problem: Wrong Buttons","text":"<p>Symptom: A button does something unexpected</p> <p>Cause: Controller mapping issue</p> <p>Solution: - SDL3 handles most mappings automatically - Check SDL gamepad database - Use <code>GamepadButton</code> enum names (not physical position)</p>"},{"location":"guides/input/gamepad/#problem-no-trigger-response","title":"Problem: No Trigger Response","text":"<p>Symptom: Triggers don't register</p> <p>Solution:</p> <ol> <li> <p>Check axis range <pre><code>var trigger = _input.GetGamepadAxis(GamepadAxis.RightTrigger);\nLogger.LogInformation(\"Trigger value: {Value}\", trigger);</code></pre></p> </li> <li> <p>Apply threshold <pre><code>// Some controllers have resting values &gt; 0\nif (trigger &gt; 0.1f) // 10% deadzone\n{\n    // Trigger actually pressed\n}</code></pre></p> </li> </ol>"},{"location":"guides/input/gamepad/#best-practices","title":"Best Practices","text":""},{"location":"guides/input/gamepad/#do","title":"DO","text":"<ol> <li> <p>Always check connection first <pre><code>if (_input.IsGamepadConnected())\n{\n    HandleGamepadInput();\n}</code></pre></p> </li> <li> <p>Apply deadzones <pre><code>if (stick.Length() &lt; 0.15f)\n    stick = Vector2.Zero;</code></pre></p> </li> <li> <p>Support both gamepad AND keyboard <pre><code>// Gamepad primary, keyboard fallback\nvar input = _input.IsGamepadConnected() \n    ? GetGamepadInput()\n    : GetKeyboardInput();</code></pre></p> </li> <li> <p>Use IsButtonPressed for discrete actions <pre><code>if (_input.IsGamepadButtonPressed(GamepadButton.A))\n    Jump();</code></pre></p> </li> <li> <p>Show button prompts</p> </li> <li>Display \"(A) Jump\" or visual icons</li> <li> <p>Update when controller changes</p> </li> <li> <p>Test with multiple controller types</p> </li> <li>Xbox</li> <li>PlayStation</li> <li>Switch Pro</li> <li>Generic USB</li> </ol>"},{"location":"guides/input/gamepad/#dont","title":"DON'T","text":"<ol> <li> <p>Don't assume gamepad is always connected <pre><code>// \u274c Bad - crashes if no gamepad!\nvar stick = _input.GetGamepadLeftStick();\n\n// \u2705 Good\nif (_input.IsGamepadConnected())\n{\n    var stick = _input.GetGamepadLeftStick();\n}</code></pre></p> </li> <li> <p>Don't ignore deadzone <pre><code>// \u274c Bad - stick drift!\n_playerPosition += _input.GetGamepadLeftStick() * speed * dt;\n\n// \u2705 Good\nvar stick = _input.GetGamepadLeftStick();\nif (stick.LengthSquared() &gt; 0.15f * 0.15f)\n{\n    _playerPosition += stick * speed * dt;\n}</code></pre></p> </li> <li> <p>Don't use button DOWN for menus <pre><code>// \u274c Bad - scrolls too fast!\nif (_input.IsGamepadButtonDown(GamepadButton.DPadDown))\n    ScrollMenu();\n\n// \u2705 Good\nif (_input.IsGamepadButtonPressed(GamepadButton.DPadDown))\n    ScrollMenu();</code></pre></p> </li> </ol>"},{"location":"guides/input/gamepad/#summary","title":"Summary","text":"Method Returns Use For <code>IsGamepadConnected(index)</code> <code>bool</code> Check connection <code>IsGamepadButtonDown(btn, idx)</code> <code>bool</code> Held detection <code>IsGamepadButtonPressed(btn, idx)</code> <code>bool</code> Press detection <code>IsGamepadButtonReleased(btn, idx)</code> <code>bool</code> Release detection <code>GetGamepadLeftStick(index)</code> <code>Vector2</code> Movement stick (-1 to 1) <code>GetGamepadRightStick(index)</code> <code>Vector2</code> Camera/aim stick (-1 to 1) <code>GetGamepadAxis(axis, index)</code> <code>float</code> Individual axis (-1 to 1) <p>Available Axes: - <code>GamepadAxis.LeftX</code>, <code>LeftY</code> - Left stick - <code>GamepadAxis.RightX</code>, <code>RightY</code> - Right stick - <code>GamepadAxis.LeftTrigger</code>, <code>RightTrigger</code> - Triggers (0 to 1)</p>"},{"location":"guides/input/gamepad/#next-steps","title":"Next Steps","text":"<ul> <li>Input Layers - Priority-based input routing</li> <li>Player Movement - Complete movement system</li> <li>UI Navigation - Gamepad-friendly menus</li> <li>Keyboard Input - Combine with keyboard support</li> </ul> <p>Ready to layer your input? Check out Input Layers!</p>"},{"location":"guides/input/keyboard/","title":"Keyboard Input","text":"<p>Master keyboard input handling in Brine2D for player movement, menu navigation, shortcuts, and text entry.</p>"},{"location":"guides/input/keyboard/#overview","title":"Overview","text":"<p>Brine2D provides a simple, frame-based keyboard input system via <code>IInputService</code>:</p> <ul> <li>\u2705 Key down - Is key currently held?</li> <li>\u2705 Key pressed - Was key just pressed this frame?</li> <li>\u2705 Key released - Was key just released this frame?</li> <li>\u2705 100+ keys supported - Letters, numbers, F-keys, arrows, modifiers, etc.</li> </ul> <pre><code>sequenceDiagram\n    participant Game as Your Scene\n    participant Input as IInputService\n    participant SDL as SDL3\n\n    Note over SDL: Player Presses Key\n    SDL-&gt;&gt;Input: KeyDown Event\n\n    Note over Game: Each Frame\n    Game-&gt;&gt;Input: IsKeyPressed(Keys.Space)?\n    Input-&gt;&gt;Game: true (first frame only)\n\n    Game-&gt;&gt;Input: IsKeyDown(Keys.Space)?\n    Input-&gt;&gt;Game: true (every frame held)\n\n    Note over SDL: Player Releases Key\n    SDL-&gt;&gt;Input: KeyUp Event\n\n    Game-&gt;&gt;Input: IsKeyReleased(Keys.Space)?\n    Input-&gt;&gt;Game: true (frame of release)</code></pre>"},{"location":"guides/input/keyboard/#prerequisites","title":"Prerequisites","text":"<ul> <li>\u2705 Quick Start - Basic scene setup</li> <li>\u2705 Scenes - Understanding OnUpdate</li> </ul>"},{"location":"guides/input/keyboard/#quick-example","title":"Quick Example","text":"<pre><code>using Brine2D.Core;\nusing Brine2D.Input;\nusing Brine2D.Rendering;\nusing Microsoft.Extensions.Logging;\nusing System.Numerics;\n\npublic class KeyboardScene : Scene\n{\n    private readonly IInputService _input;\n    private readonly IGameContext _gameContext;\n    private readonly IRenderer _renderer;\n\n    private Vector2 _playerPosition = new Vector2(400, 300);\n    private float _speed = 200f;\n\n    public KeyboardScene(\n        IInputService input,\n        IGameContext gameContext,\n        IRenderer renderer,\n        ILogger&lt;KeyboardScene&gt; logger\n    ) : base(logger)\n    {\n        _input = input;\n        _gameContext = gameContext;\n        _renderer = renderer;\n    }\n\n    protected override void OnUpdate(GameTime gameTime)\n    {\n        var deltaTime = (float)gameTime.DeltaTime;\n\n        // Exit on ESC\n        if (_input.IsKeyPressed(Keys.Escape))\n        {\n            _gameContext.RequestExit();\n        }\n\n        // WASD Movement\n        if (_input.IsKeyDown(Keys.W))\n            _playerPosition.Y -= _speed * deltaTime;\n\n        if (_input.IsKeyDown(Keys.S))\n            _playerPosition.Y += _speed * deltaTime;\n\n        if (_input.IsKeyDown(Keys.A))\n            _playerPosition.X -= _speed * deltaTime;\n\n        if (_input.IsKeyDown(Keys.D))\n            _playerPosition.X += _speed * deltaTime;\n\n        // Jump on Spacebar (once per press)\n        if (_input.IsKeyPressed(Keys.Space))\n        {\n            Logger.LogInformation(\"Jump!\");\n        }\n    }\n\n    protected override void OnRender(GameTime gameTime)\n    {\n        _renderer.Clear(Color.Black);\n        _renderer.BeginFrame();\n\n        // Draw player\n        _renderer.DrawRectangle(\n            _playerPosition.X - 25, _playerPosition.Y - 25,\n            50, 50, Color.Red);\n\n        _renderer.EndFrame();\n    }\n}</code></pre> <p>Result: Player moves with WASD, jumps with Space, exits with ESC! \u2328\ufe0f</p>"},{"location":"guides/input/keyboard/#key-states","title":"Key States","text":""},{"location":"guides/input/keyboard/#iskeydown-continuous-input","title":"IsKeyDown - Continuous Input","text":"<p>Use for: Movement, aiming, holding buttons</p> <pre><code>protected override void OnUpdate(GameTime gameTime)\n{\n    var deltaTime = (float)gameTime.DeltaTime;\n\n    // Returns TRUE while key is held\n    if (_input.IsKeyDown(Keys.W))\n    {\n        _playerY -= _speed * deltaTime; // Move up continuously\n    }\n}</code></pre> <p>Behavior:</p> <ul> <li>\u2705 Returns <code>true</code> every frame while key is held</li> <li>\u2705 Perfect for smooth movement</li> <li>\u2705 Frame-rate independent (use delta time!)</li> </ul>"},{"location":"guides/input/keyboard/#iskeypressed-single-event","title":"IsKeyPressed - Single Event","text":"<p>Use for: Jumping, shooting, menu actions</p> <pre><code>protected override void OnUpdate(GameTime gameTime)\n{\n    // Returns TRUE only on first frame of press\n    if (_input.IsKeyPressed(Keys.Space))\n    {\n        Jump(); // Only jumps once per press\n    }\n\n    if (_input.IsKeyPressed(Keys.F))\n    {\n        FireWeapon(); // One shot per press\n    }\n}</code></pre> <p>Behavior:</p> <ul> <li>\u2705 Returns <code>true</code> only on first frame of press</li> <li>\u2705 Ignores key repeats</li> <li>\u2705 Perfect for discrete actions</li> </ul>"},{"location":"guides/input/keyboard/#iskeyreleased-release-detection","title":"IsKeyReleased - Release Detection","text":"<p>Use for: Charge attacks, button releases</p> <pre><code>private bool _isCharging = false;\nprivate float _chargeTime = 0f;\n\nprotected override void OnUpdate(GameTime gameTime)\n{\n    var deltaTime = (float)gameTime.DeltaTime;\n\n    // Start charging\n    if (_input.IsKeyPressed(Keys.Space))\n    {\n        _isCharging = true;\n        _chargeTime = 0f;\n    }\n\n    // Accumulate charge\n    if (_isCharging &amp;&amp; _input.IsKeyDown(Keys.Space))\n    {\n        _chargeTime += deltaTime;\n    }\n\n    // Release - fire charged attack\n    if (_input.IsKeyReleased(Keys.Space))\n    {\n        if (_isCharging)\n        {\n            FireChargedAttack(_chargeTime);\n            _isCharging = false;\n        }\n    }\n}</code></pre> <p>Behavior:</p> <ul> <li>\u2705 Returns <code>true</code> on frame of release</li> <li>\u2705 Perfect for charge mechanics</li> </ul>"},{"location":"guides/input/keyboard/#available-keys","title":"Available Keys","text":""},{"location":"guides/input/keyboard/#letters-a-z","title":"Letters (A-Z)","text":"<pre><code>Keys.A, Keys.B, Keys.C, ... Keys.Z</code></pre> <p>Example:</p> <pre><code>if (_input.IsKeyPressed(Keys.P))\n{\n    TogglePause();\n}</code></pre>"},{"location":"guides/input/keyboard/#numbers-0-9","title":"Numbers (0-9)","text":"<pre><code>Keys.D0, Keys.D1, Keys.D2, ... Keys.D9</code></pre> <p>Why <code>D</code> prefix? C# enums can't start with numbers!</p> <p>Example:</p> <pre><code>// Weapon selection\nif (_input.IsKeyPressed(Keys.D1)) SelectWeapon(1);\nif (_input.IsKeyPressed(Keys.D2)) SelectWeapon(2);\nif (_input.IsKeyPressed(Keys.D3)) SelectWeapon(3);</code></pre>"},{"location":"guides/input/keyboard/#arrow-keys","title":"Arrow Keys","text":"<pre><code>Keys.Up, Keys.Down, Keys.Left, Keys.Right</code></pre> <p>Example:</p> <pre><code>// Menu navigation\nif (_input.IsKeyPressed(Keys.Up)) SelectPreviousMenuItem();\nif (_input.IsKeyPressed(Keys.Down)) SelectNextMenuItem();\nif (_input.IsKeyPressed(Keys.Enter)) ActivateMenuItem();</code></pre>"},{"location":"guides/input/keyboard/#function-keys-f1-f12","title":"Function Keys (F1-F12)","text":"<pre><code>Keys.F1, Keys.F2, ... Keys.F12</code></pre> <p>Example:</p> <pre><code>// Debug shortcuts\nif (_input.IsKeyPressed(Keys.F1)) ToggleDebugOverlay();\nif (_input.IsKeyPressed(Keys.F5)) QuickSave();\nif (_input.IsKeyPressed(Keys.F9)) QuickLoad();</code></pre>"},{"location":"guides/input/keyboard/#special-keys","title":"Special Keys","text":"Key Usage <code>Keys.Space</code> Jump, shoot, confirm <code>Keys.Enter</code> Confirm, submit <code>Keys.Escape</code> Cancel, pause, exit <code>Keys.Tab</code> Inventory, map <code>Keys.Backspace</code> Delete text <code>Keys.Delete</code> Delete forward"},{"location":"guides/input/keyboard/#modifier-keys","title":"Modifier Keys","text":"<pre><code>Keys.LeftShift, Keys.RightShift\nKeys.LeftControl, Keys.RightControl\nKeys.LeftAlt, Keys.RightAlt</code></pre> <p>Example:</p> <pre><code>// Sprint (hold Shift + W)\nif (_input.IsKeyDown(Keys.W))\n{\n    var speed = _normalSpeed;\n\n    if (_input.IsKeyDown(Keys.LeftShift))\n    {\n        speed = _sprintSpeed; // 2x speed\n    }\n\n    _playerY -= speed * deltaTime;\n}\n\n// Shortcut (Ctrl+S = Save)\nif (_input.IsKeyDown(Keys.LeftControl) &amp;&amp; _input.IsKeyPressed(Keys.S))\n{\n    SaveGame();\n}</code></pre>"},{"location":"guides/input/keyboard/#numpad-keys","title":"Numpad Keys","text":"<pre><code>Keys.Numpad0, Keys.Numpad1, ... Keys.Numpad9\nKeys.NumpadEnter, Keys.NumpadPlus, Keys.NumpadMinus</code></pre>"},{"location":"guides/input/keyboard/#full-keys-enum","title":"Full Keys Enum \u2192","text":""},{"location":"guides/input/keyboard/#common-patterns","title":"Common Patterns","text":""},{"location":"guides/input/keyboard/#pattern-1-wasd-movement","title":"Pattern 1: WASD Movement","text":"<pre><code>protected override void OnUpdate(GameTime gameTime)\n{\n    var deltaTime = (float)gameTime.DeltaTime;\n    var movement = Vector2.Zero;\n\n    if (_input.IsKeyDown(Keys.W)) movement.Y -= 1;\n    if (_input.IsKeyDown(Keys.S)) movement.Y += 1;\n    if (_input.IsKeyDown(Keys.A)) movement.X -= 1;\n    if (_input.IsKeyDown(Keys.D)) movement.X += 1;\n\n    if (movement != Vector2.Zero)\n    {\n        movement = Vector2.Normalize(movement); // Prevent faster diagonal\n        _playerPosition += movement * _speed * deltaTime;\n    }\n}</code></pre>"},{"location":"guides/input/keyboard/#pattern-2-arrow-key-menu-navigation","title":"Pattern 2: Arrow Key Menu Navigation","text":"<pre><code>private int _selectedIndex = 0;\nprivate readonly string[] _menuItems = [\"New Game\", \"Load Game\", \"Options\", \"Exit\"];\n\nprotected override void OnUpdate(GameTime gameTime)\n{\n    // Navigate menu\n    if (_input.IsKeyPressed(Keys.Up))\n    {\n        _selectedIndex = Math.Max(0, _selectedIndex - 1);\n    }\n\n    if (_input.IsKeyPressed(Keys.Down))\n    {\n        _selectedIndex = Math.Min(_menuItems.Length - 1, _selectedIndex + 1);\n    }\n\n    // Confirm selection\n    if (_input.IsKeyPressed(Keys.Enter) || _input.IsKeyPressed(Keys.Space))\n    {\n        ActivateMenuItem(_selectedIndex);\n    }\n}</code></pre>"},{"location":"guides/input/keyboard/#pattern-3-number-key-hotbar","title":"Pattern 3: Number Key Hotbar","text":"<pre><code>protected override void OnUpdate(GameTime gameTime)\n{\n    // Check number keys 1-9\n    for (int i = 0; i &lt; 9; i++)\n    {\n        var key = (Keys)((int)Keys.D1 + i); // D1, D2, D3, etc.\n\n        if (_input.IsKeyPressed(key))\n        {\n            SelectHotbarSlot(i);\n        }\n    }\n}</code></pre>"},{"location":"guides/input/keyboard/#pattern-4-toggle-key","title":"Pattern 4: Toggle Key","text":"<pre><code>private bool _debugMode = false;\n\nprotected override void OnUpdate(GameTime gameTime)\n{\n    // Toggle debug mode with F3\n    if (_input.IsKeyPressed(Keys.F3))\n    {\n        _debugMode = !_debugMode;\n        Logger.LogInformation(\"Debug mode: {Enabled}\", _debugMode);\n    }\n}</code></pre>"},{"location":"guides/input/keyboard/#pattern-5-combo-keys-modifiers","title":"Pattern 5: Combo Keys (Modifiers)","text":"<pre><code>protected override void OnUpdate(GameTime gameTime)\n{\n    var ctrl = _input.IsKeyDown(Keys.LeftControl) || \n               _input.IsKeyDown(Keys.RightControl);\n    var shift = _input.IsKeyDown(Keys.LeftShift) || \n                _input.IsKeyDown(Keys.RightShift);\n\n    // Ctrl+S = Save\n    if (ctrl &amp;&amp; _input.IsKeyPressed(Keys.S))\n    {\n        SaveGame();\n    }\n\n    // Ctrl+Shift+D = Debug save\n    if (ctrl &amp;&amp; shift &amp;&amp; _input.IsKeyPressed(Keys.D))\n    {\n        SaveDebugInfo();\n    }\n}</code></pre>"},{"location":"guides/input/keyboard/#advanced-techniques","title":"Advanced Techniques","text":""},{"location":"guides/input/keyboard/#input-buffering","title":"Input Buffering","text":"<p>Store recent inputs for combo systems:</p> <pre><code>private readonly Queue&lt;Keys&gt; _inputBuffer = new();\nprivate const int BufferSize = 5;\n\nprotected override void OnUpdate(GameTime gameTime)\n{\n    // Add pressed keys to buffer\n    foreach (Keys key in Enum.GetValues&lt;Keys&gt;())\n    {\n        if (_input.IsKeyPressed(key))\n        {\n            _inputBuffer.Enqueue(key);\n\n            if (_inputBuffer.Count &gt; BufferSize)\n            {\n                _inputBuffer.Dequeue();\n            }\n        }\n    }\n\n    // Check for combo: Down, Down, Right, A\n    CheckCombo();\n}\n\nprivate void CheckCombo()\n{\n    var sequence = _inputBuffer.ToArray();\n\n    if (sequence.Length &gt;= 4 &amp;&amp;\n        sequence[^4] == Keys.Down &amp;&amp;\n        sequence[^3] == Keys.Down &amp;&amp;\n        sequence[^2] == Keys.Right &amp;&amp;\n        sequence[^1] == Keys.A)\n    {\n        ExecuteSpecialMove();\n        _inputBuffer.Clear();\n    }\n}</code></pre>"},{"location":"guides/input/keyboard/#key-rebinding","title":"Key Rebinding","text":"<p>Allow players to customize controls:</p> <pre><code>public class InputMapper\n{\n    private readonly Dictionary&lt;string, Keys&gt; _bindings = new()\n    {\n        [\"Jump\"] = Keys.Space,\n        [\"Shoot\"] = Keys.LeftControl,\n        [\"Reload\"] = Keys.R\n    };\n\n    public bool IsActionPressed(IInputService input, string action)\n    {\n        if (_bindings.TryGetValue(action, out var key))\n        {\n            return input.IsKeyPressed(key);\n        }\n\n        return false;\n    }\n\n    public void RebindAction(string action, Keys newKey)\n    {\n        _bindings[action] = newKey;\n        SaveBindings(); // Persist to config file\n    }\n}\n\n// Usage\nif (_inputMapper.IsActionPressed(_input, \"Jump\"))\n{\n    Jump();\n}</code></pre>"},{"location":"guides/input/keyboard/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guides/input/keyboard/#problem-key-not-detected","title":"Problem: Key Not Detected","text":"<p>Symptom: <code>IsKeyPressed()</code> always returns false</p> <p>Solutions:</p> <ol> <li> <p>Check key name <pre><code>// \u274c Wrong\nif (_input.IsKeyPressed(Keys.0)) // Compile error!\n\n// \u2705 Correct\nif (_input.IsKeyPressed(Keys.D0)) // Number keys have 'D' prefix</code></pre></p> </li> <li> <p>Check input service is injected <pre><code>// Constructor must inject IInputService\npublic MyScene(IInputService input, ILogger&lt;MyScene&gt; logger) \n    : base(logger)\n{\n    _input = input; // Don't forget to store!\n}</code></pre></p> </li> </ol>"},{"location":"guides/input/keyboard/#problem-movement-too-fastslow","title":"Problem: Movement Too Fast/Slow","text":"<p>Symptom: Player zooms or crawls</p> <p>Solution: Use delta time for frame-rate independence:</p> <pre><code>// \u274c Bad - frame-rate dependent\nif (_input.IsKeyDown(Keys.W))\n{\n    _playerY -= 5; // Moves 5 pixels per frame\n}\n\n// \u2705 Good - frame-rate independent\nif (_input.IsKeyDown(Keys.W))\n{\n    _playerY -= _speed * deltaTime; // Moves at constant real-world speed\n}</code></pre>"},{"location":"guides/input/keyboard/#problem-diagonal-movement-too-fast","title":"Problem: Diagonal Movement Too Fast","text":"<p>Symptom: Moving diagonally (W+D) is \u221a2 faster</p> <p>Solution: Normalize movement vector:</p> <pre><code>// \u274c Bad\nif (_input.IsKeyDown(Keys.W)) _playerY -= speed * dt;\nif (_input.IsKeyDown(Keys.D)) _playerX += speed * dt;\n// Diagonal = speed * \u221a2 \u2248 1.41x!\n\n// \u2705 Good\nvar movement = Vector2.Zero;\nif (_input.IsKeyDown(Keys.W)) movement.Y -= 1;\nif (_input.IsKeyDown(Keys.D)) movement.X += 1;\n\nif (movement != Vector2.Zero)\n{\n    movement = Vector2.Normalize(movement); // Length = 1\n    _playerPosition += movement * speed * dt;\n}</code></pre>"},{"location":"guides/input/keyboard/#problem-keys-stuck-after-alttab","title":"Problem: Keys Stuck After Alt+Tab","text":"<p>Symptom: Keys remain \"pressed\" after window loses focus</p> <p>Note: SDL3 handles this automatically! Keys are released when window loses focus.</p>"},{"location":"guides/input/keyboard/#best-practices","title":"Best Practices","text":""},{"location":"guides/input/keyboard/#do","title":"DO","text":"<ol> <li> <p>Use <code>IsKeyPressed</code> for discrete actions <pre><code>if (_input.IsKeyPressed(Keys.Space)) Jump();</code></pre></p> </li> <li> <p>Use <code>IsKeyDown</code> for continuous actions <pre><code>if (_input.IsKeyDown(Keys.W)) MoveForward(deltaTime);</code></pre></p> </li> <li> <p>Always use delta time for movement <pre><code>position += velocity * deltaTime;</code></pre></p> </li> <li> <p>Normalize movement vectors <pre><code>if (movement != Vector2.Zero)\n    movement = Vector2.Normalize(movement);</code></pre></p> </li> <li> <p>Provide key rebinding</p> </li> <li>Let players customize controls</li> <li> <p>Store in config file</p> </li> <li> <p>Support multiple keys for same action <pre><code>bool jump = _input.IsKeyPressed(Keys.Space) || \n            _input.IsKeyPressed(Keys.W);</code></pre></p> </li> </ol>"},{"location":"guides/input/keyboard/#dont","title":"DON'T","text":"<ol> <li> <p>Don't poll input outside OnUpdate <pre><code>// \u274c Bad - won't update!\nprotected override void OnInitialize()\n{\n    if (_input.IsKeyDown(Keys.W)) // Never true here!\n}</code></pre></p> </li> <li> <p>Don't forget delta time <pre><code>// \u274c Bad\n_playerX += 5; // Frame-rate dependent!\n\n// \u2705 Good\n_playerX += _speed * deltaTime;</code></pre></p> </li> <li> <p>Don't check IsKeyPressed in loops <pre><code>// \u274c Bad - only true once per frame!\nwhile (gameRunning)\n{\n    if (_input.IsKeyPressed(Keys.Space)) // Won't work!\n}</code></pre></p> </li> </ol>"},{"location":"guides/input/keyboard/#summary","title":"Summary","text":"Method When True Use For <code>IsKeyDown(key)</code> Every frame held Movement, continuous actions <code>IsKeyPressed(key)</code> First frame only Jump, shoot, single actions <code>IsKeyReleased(key)</code> Frame of release Charge attacks, release detection"},{"location":"guides/input/keyboard/#next-steps","title":"Next Steps","text":"<ul> <li>Mouse Input - Handle clicks and cursor</li> <li>Gamepad Support - Add controller support</li> <li>Input Layers - Priority-based input routing</li> <li>Player Movement - Complete movement system</li> </ul> <p>Ready to add mouse support? Check out Mouse Input!</p>"},{"location":"guides/input/layers/","title":"Input Layers","text":"<p>Master priority-based input routing to handle UI overlays, pause menus, and complex input scenarios in Brine2D.</p>"},{"location":"guides/input/layers/#overview","title":"Overview","text":"<p>Input Layers solve a common problem: when a player clicks a button on a pause menu, the game world shouldn't also react to that click!</p> <p>Brine2D's <code>InputLayerManager</code> routes input through priority-based layers:</p> <ul> <li>\u2705 UI Layer (Priority 1000) - Menus, dialogs, HUD</li> <li>\u2705 Game Layer (Priority 0) - Game world, player controls</li> <li>\u2705 Input consumption - Higher priority layers can block lower ones</li> <li>\u2705 Automatic routing - No manual checks needed</li> </ul> <pre><code>graph TB\n    A[\"Player Input&lt;br/&gt;(Keyboard/Mouse)\"] --&gt; B[\"InputLayerManager\"]\n\n    B --&gt; C[\"Layer 1: UI Canvas&lt;br/&gt;(Priority 1000)\"]\n    C --&gt;|\"Consumed?&lt;br/&gt;YES\"| D[\"Stop&lt;br/&gt;(Game doesn't see input)\"]\n    C --&gt;|\"Consumed?&lt;br/&gt;NO\"| E[\"Layer 2: Game&lt;br/&gt;(Priority 0)\"]\n\n    E --&gt; F[\"Game Handles Input\"]\n\n    style A fill:#4a3d1f,stroke:#ce9178,stroke-width:2px,color:#fff\n    style B fill:#2d5016,stroke:#4ec9b0,stroke-width:2px,color:#fff\n    style C fill:#1e3a5f,stroke:#569cd6,stroke-width:2px,color:#fff\n    style D fill:#4a2d4a,stroke:#c586c0,stroke-width:2px,color:#fff\n    style E fill:#3d3d2a,stroke:#dcdcaa,stroke-width:2px,color:#fff\n    style F fill:#264f78,stroke:#4fc1ff,stroke-width:2px,color:#fff</code></pre> <p>Example Scenario: 1. Player opens pause menu (UI layer) 2. Player clicks \"Resume\" button 3. UI layer consumes the click (handles it) 4. Game layer never sees the click (doesn't spawn units, shoot, etc.)</p>"},{"location":"guides/input/layers/#prerequisites","title":"Prerequisites","text":"<ul> <li>\u2705 Keyboard Input - Basic input handling</li> <li>\u2705 Mouse Input - Mouse handling</li> <li>\u2705 Scenes - Scene structure</li> </ul>"},{"location":"guides/input/layers/#quick-example","title":"Quick Example","text":""},{"location":"guides/input/layers/#problem-ui-clicks-affect-game","title":"Problem: UI Clicks Affect Game","text":"<pre><code>// \u274c BAD - Both UI and game handle the same click!\nprotected override void OnUpdate(GameTime gameTime)\n{\n    // UI handles click\n    if (_input.IsMouseButtonPressed(MouseButton.Left))\n    {\n        CheckButtonClicked(); // Button clicked!\n    }\n\n    // Game ALSO handles same click!\n    if (_input.IsMouseButtonPressed(MouseButton.Left))\n    {\n        SpawnUnitAtMouse(); // Oops! Spawned unit under button!\n    }\n}</code></pre>"},{"location":"guides/input/layers/#solution-input-layers","title":"Solution: Input Layers","text":"<pre><code>using Brine2D.Core;\nusing Brine2D.Input;\nusing Brine2D.Rendering;\nusing Brine2D.UI;\nusing Microsoft.Extensions.Logging;\n\npublic class InputLayerScene : Scene\n{\n    private readonly IInputService _input;\n    private readonly InputLayerManager _inputLayerManager;\n    private readonly UICanvas _uiCanvas;\n    private readonly IRenderer _renderer;\n\n    public InputLayerScene(\n        IInputService input,\n        InputLayerManager inputLayerManager,\n        UICanvas uiCanvas,\n        IRenderer renderer,\n        ILogger&lt;InputLayerScene&gt; logger\n    ) : base(logger)\n    {\n        _input = input;\n        _inputLayerManager = inputLayerManager;\n        _uiCanvas = uiCanvas;\n        _renderer = renderer;\n    }\n\n    protected override void OnInitialize()\n    {\n        // Register UI layer (high priority)\n        _inputLayerManager.RegisterLayer(_uiCanvas);\n\n        // Add a button\n        var button = new UIButton(\"Click Me\", new Vector2(100, 100), new Vector2(150, 50));\n        button.OnClick += () =&gt; Logger.LogInformation(\"Button clicked!\");\n        _uiCanvas.Add(button);\n    }\n\n    protected override void OnUpdate(GameTime gameTime)\n    {\n        // Process input through layers\n        _inputLayerManager.ProcessInput();\n\n        // \u2705 GOOD - Only handle game input if NOT consumed by UI\n        if (!_inputLayerManager.MouseConsumed)\n        {\n            if (_input.IsMouseButtonPressed(MouseButton.Left))\n            {\n                SpawnUnitAtMouse(); // Only spawns if NOT clicking UI!\n            }\n        }\n\n        if (!_inputLayerManager.KeyboardConsumed)\n        {\n            HandleGameKeyboard(); // Only if UI isn't typing\n        }\n    }\n}</code></pre> <p>Result: Clicking button doesn't affect game world! \ud83c\udfaf</p>"},{"location":"guides/input/layers/#setup","title":"Setup","text":""},{"location":"guides/input/layers/#1-register-service","title":"1. Register Service","text":"<pre><code>using Brine2D.Hosting;\nusing Brine2D.Input;\nusing Brine2D.UI;\n\nvar builder = GameApplication.CreateBuilder(args);\n\n// Add input layer manager\nbuilder.Services.AddInputLayerManager();\n\n// Add UI canvas (implements IInputLayer)\nbuilder.Services.AddSingleton&lt;UICanvas&gt;();\n\n// ... other services ...\n\nvar game = builder.Build();\nawait game.RunAsync&lt;MyScene&gt;();</code></pre>"},{"location":"guides/input/layers/#2-inject-dependencies","title":"2. Inject Dependencies","text":"<pre><code>public class MyScene : Scene\n{\n    private readonly IInputService _input;\n    private readonly InputLayerManager _layerManager;\n    private readonly UICanvas _uiCanvas;\n\n    public MyScene(\n        IInputService input,\n        InputLayerManager layerManager,\n        UICanvas uiCanvas,\n        ILogger&lt;MyScene&gt; logger\n    ) : base(logger)\n    {\n        _input = input;\n        _layerManager = layerManager;\n        _uiCanvas = uiCanvas;\n    }\n}</code></pre>"},{"location":"guides/input/layers/#3-register-layers","title":"3. Register Layers","text":"<pre><code>protected override void OnInitialize()\n{\n    // Register UI layer (priority 1000)\n    _layerManager.RegisterLayer(_uiCanvas);\n\n    // Can register custom layers too\n    // _layerManager.RegisterLayer(myCustomLayer);\n}</code></pre>"},{"location":"guides/input/layers/#4-process-input-every-frame","title":"4. Process Input Every Frame","text":"<pre><code>protected override void OnUpdate(GameTime gameTime)\n{\n    // IMPORTANT: Call this BEFORE checking input!\n    _layerManager.ProcessInput();\n\n    // Now safe to check consumption\n    if (!_layerManager.MouseConsumed)\n    {\n        HandleGameMouseInput();\n    }\n\n    if (!_layerManager.KeyboardConsumed)\n    {\n        HandleGameKeyboardInput();\n    }\n}</code></pre>"},{"location":"guides/input/layers/#input-layer-interface","title":"Input Layer Interface","text":""},{"location":"guides/input/layers/#iinputlayer","title":"IInputLayer","text":"<p>Implement this interface to create custom layers:</p> <pre><code>public interface IInputLayer\n{\n    /// &lt;summary&gt;\n    /// Priority (higher = processed first).\n    /// UI = 1000, Game = 0\n    /// &lt;/summary&gt;\n    int Priority { get; }\n\n    /// &lt;summary&gt;\n    /// Process keyboard input.\n    /// Return TRUE to consume (block lower layers).\n    /// &lt;/summary&gt;\n    bool ProcessKeyboardInput(IInputService input);\n\n    /// &lt;summary&gt;\n    /// Process mouse input.\n    /// Return TRUE to consume (block lower layers).\n    /// &lt;/summary&gt;\n    bool ProcessMouseInput(IInputService input);\n}</code></pre>"},{"location":"guides/input/layers/#priority-system","title":"Priority System","text":"Priority Layer Type Example 1000+ Critical UI Modal dialogs, error messages 1000 UI Menus, HUD, buttons 500 Overlay Console, debug menu 0 Game Player controls, world interaction -1000 Background Always processes (logging, etc.) <p>Rule: Higher priority = processed first, can block lower priorities.</p>"},{"location":"guides/input/layers/#consumption-flags","title":"Consumption Flags","text":""},{"location":"guides/input/layers/#check-consumption","title":"Check Consumption","text":"<pre><code>protected override void OnUpdate(GameTime gameTime)\n{\n    _layerManager.ProcessInput();\n\n    // Check if keyboard was consumed\n    if (_layerManager.KeyboardConsumed)\n    {\n        // UI is typing, don't handle game keyboard\n        return;\n    }\n\n    // Check if mouse was consumed\n    if (_layerManager.MouseConsumed)\n    {\n        // UI is clicking, don't handle game mouse\n        return;\n    }\n\n    // Safe to process game input\n    HandleGameInput();\n}</code></pre>"},{"location":"guides/input/layers/#when-input-is-consumed","title":"When Input is Consumed","text":"<p>Keyboard consumed when: - Text input field is focused - Dropdown is open (arrow keys) - Dialog is active (Enter/Escape)</p> <p>Mouse consumed when: - Hovering over button - Dragging slider - Clicking checkbox - Scrolling in UI element</p>"},{"location":"guides/input/layers/#common-patterns","title":"Common Patterns","text":""},{"location":"guides/input/layers/#pattern-1-game-with-ui-overlay","title":"Pattern 1: Game with UI Overlay","text":"<pre><code>public class GameWithUIScene : Scene\n{\n    private readonly IInputService _input;\n    private readonly InputLayerManager _layerManager;\n    private readonly UICanvas _uiCanvas;\n\n    private Vector2 _playerPosition = new Vector2(400, 300);\n\n    protected override void OnInitialize()\n    {\n        // Register UI layer\n        _layerManager.RegisterLayer(_uiCanvas);\n\n        // Add pause button\n        var pauseBtn = new UIButton(\"Pause\", new Vector2(10, 10), new Vector2(100, 40));\n        pauseBtn.OnClick += TogglePause;\n        _uiCanvas.Add(pauseBtn);\n    }\n\n    protected override void OnUpdate(GameTime gameTime)\n    {\n        // Process layers\n        _layerManager.ProcessInput();\n\n        // Only handle game input if UI didn't consume it\n        if (!_layerManager.KeyboardConsumed)\n        {\n            HandlePlayerMovement(gameTime);\n        }\n\n        if (!_layerManager.MouseConsumed)\n        {\n            HandleWorldClicks();\n        }\n    }\n\n    private void HandlePlayerMovement(GameTime gameTime)\n    {\n        var deltaTime = (float)gameTime.DeltaTime;\n        var movement = Vector2.Zero;\n\n        if (_input.IsKeyDown(Keys.W)) movement.Y -= 1;\n        if (_input.IsKeyDown(Keys.S)) movement.Y += 1;\n        if (_input.IsKeyDown(Keys.A)) movement.X -= 1;\n        if (_input.IsKeyDown(Keys.D)) movement.X += 1;\n\n        if (movement != Vector2.Zero)\n        {\n            movement = Vector2.Normalize(movement);\n            _playerPosition += movement * 200f * deltaTime;\n        }\n    }\n}</code></pre>"},{"location":"guides/input/layers/#pattern-2-pause-menu","title":"Pattern 2: Pause Menu","text":"<pre><code>public class PauseMenuLayer : IInputLayer\n{\n    private readonly IInputService _input;\n    private bool _isPaused = false;\n\n    public int Priority =&gt; 2000; // Higher than normal UI\n\n    public bool ProcessKeyboardInput(IInputService input)\n    {\n        // Toggle pause on Escape\n        if (input.IsKeyPressed(Keys.Escape))\n        {\n            _isPaused = !_isPaused;\n        }\n\n        // Consume ALL keyboard when paused\n        return _isPaused;\n    }\n\n    public bool ProcessMouseInput(IInputService input)\n    {\n        // Consume ALL mouse when paused\n        return _isPaused;\n    }\n}\n\n// Register it:\nprotected override void OnInitialize()\n{\n    var pauseLayer = new PauseMenuLayer(_input);\n    _layerManager.RegisterLayer(pauseLayer);\n}</code></pre>"},{"location":"guides/input/layers/#pattern-3-console-overlay","title":"Pattern 3: Console Overlay","text":"<pre><code>public class DebugConsoleLayer : IInputLayer\n{\n    private bool _consoleOpen = false;\n\n    public int Priority =&gt; 500; // Between UI and game\n\n    public bool ProcessKeyboardInput(IInputService input)\n    {\n        // Toggle with ~ key\n        if (input.IsKeyPressed(Keys.Grave))\n        {\n            _consoleOpen = !_consoleOpen;\n            return true; // Consume the ~ key\n        }\n\n        // Consume all keyboard if console is open\n        if (_consoleOpen)\n        {\n            HandleConsoleInput(input);\n            return true;\n        }\n\n        return false; // Don't consume if closed\n    }\n\n    public bool ProcessMouseInput(IInputService input)\n    {\n        // Console doesn't use mouse\n        return false;\n    }\n}</code></pre>"},{"location":"guides/input/layers/#pattern-4-multiple-ui-layers","title":"Pattern 4: Multiple UI Layers","text":"<pre><code>protected override void OnInitialize()\n{\n    // Layer 1: Modal dialog (highest priority)\n    var dialogLayer = new DialogLayer();\n    _layerManager.RegisterLayer(dialogLayer); // Priority: 2000\n\n    // Layer 2: Main UI\n    _layerManager.RegisterLayer(_uiCanvas); // Priority: 1000\n\n    // Layer 3: Game\n    var gameLayer = new GameInputLayer();\n    _layerManager.RegisterLayer(gameLayer); // Priority: 0\n}\n\n// Processing order:\n// 1. Dialog (if active, blocks everything else)\n// 2. Main UI (if clicking buttons, blocks game)\n// 3. Game (only if neither dialog nor UI consumed input)</code></pre>"},{"location":"guides/input/layers/#custom-input-layer","title":"\ud83d\udee0\ufe0f Custom Input Layer","text":""},{"location":"guides/input/layers/#create-custom-layer","title":"Create Custom Layer","text":"<pre><code>using Brine2D.Input;\nusing System.Numerics;\n\npublic class GameInputLayer : IInputLayer\n{\n    private readonly IInputService _input;\n    private readonly Action&lt;Vector2&gt; _onWorldClick;\n\n    public int Priority =&gt; 0; // Game priority\n\n    public GameInputLayer(IInputService input, Action&lt;Vector2&gt; onWorldClick)\n    {\n        _input = input;\n        _onWorldClick = onWorldClick;\n    }\n\n    public bool ProcessKeyboardInput(IInputService input)\n    {\n        // Game doesn't consume keyboard (allows other layers to see it)\n        return false;\n    }\n\n    public bool ProcessMouseInput(IInputService input)\n    {\n        if (input.IsMouseButtonPressed(MouseButton.Left))\n        {\n            var mousePos = input.MousePosition;\n            _onWorldClick?.Invoke(mousePos);\n\n            // Don't consume - allow lower layers (if any)\n            return false;\n        }\n\n        return false;\n    }\n}</code></pre>"},{"location":"guides/input/layers/#use-custom-layer","title":"Use Custom Layer","text":"<pre><code>protected override void OnInitialize()\n{\n    // Create custom game layer\n    var gameLayer = new GameInputLayer(_input, OnWorldClick);\n    _layerManager.RegisterLayer(gameLayer);\n\n    // Also register UI layer\n    _layerManager.RegisterLayer(_uiCanvas);\n}\n\nprivate void OnWorldClick(Vector2 position)\n{\n    Logger.LogInformation(\"Clicked world at: {Pos}\", position);\n}</code></pre>"},{"location":"guides/input/layers/#advanced-techniques","title":"Advanced Techniques","text":""},{"location":"guides/input/layers/#conditional-consumption","title":"Conditional Consumption","text":"<p>Only consume input under certain conditions:</p> <pre><code>public class ConditionalUILayer : IInputLayer\n{\n    private readonly UICanvas _canvas;\n    private bool _isMenuOpen = false;\n\n    public int Priority =&gt; 1000;\n\n    public bool ProcessKeyboardInput(IInputService input)\n    {\n        // Only consume if menu is open\n        if (!_isMenuOpen)\n            return false;\n\n        // Handle menu keyboard\n        // ...\n\n        return true; // Consume\n    }\n\n    public bool ProcessMouseInput(IInputService input)\n    {\n        // Only consume if actually hovering UI\n        var mousePos = input.MousePosition;\n        bool hoveringUI = IsMouseOverUI(mousePos);\n\n        if (hoveringUI)\n        {\n            // Handle UI click\n            return true; // Consume\n        }\n\n        return false; // Don't consume, game can handle\n    }\n}</code></pre>"},{"location":"guides/input/layers/#dynamic-priority","title":"Dynamic Priority","text":"<p>Change priority at runtime:</p> <pre><code>public class DynamicPriorityLayer : IInputLayer\n{\n    private int _priority = 0;\n\n    public int Priority =&gt; _priority;\n\n    public void SetPriority(int priority)\n    {\n        _priority = priority;\n        // Re-sort layers (not automatic - would need manager support)\n    }\n\n    // ... ProcessInput methods ...\n}</code></pre>"},{"location":"guides/input/layers/#input-recording","title":"Input Recording","text":"<p>Log all input through layers:</p> <pre><code>public class InputRecorderLayer : IInputLayer\n{\n    private readonly ILogger _logger;\n\n    public int Priority =&gt; -1000; // Lowest (always processes)\n\n    public bool ProcessKeyboardInput(IInputService input)\n    {\n        // Log keyboard input (for replay/debug)\n        // ...\n\n        return false; // Never consume (always pass through)\n    }\n\n    public bool ProcessMouseInput(IInputService input)\n    {\n        // Log mouse input\n        // ...\n\n        return false; // Never consume\n    }\n}</code></pre>"},{"location":"guides/input/layers/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guides/input/layers/#problem-game-still-receives-ui-clicks","title":"Problem: Game Still Receives UI Clicks","text":"<p>Symptom: Clicking button also spawns unit</p> <p>Solutions:</p> <ol> <li> <p>Check ProcessInput is called <pre><code>protected override void OnUpdate(GameTime gameTime)\n{\n    // \u274c Forgot this!\n    // _layerManager.ProcessInput();\n\n    // \u2705 Call it FIRST\n    _layerManager.ProcessInput();\n\n    if (!_layerManager.MouseConsumed)\n    {\n        HandleGameInput();\n    }\n}</code></pre></p> </li> <li> <p>Check consumption flag <pre><code>// \u274c Bad - ignores consumption\nif (_input.IsMouseButtonPressed(MouseButton.Left))\n{\n    SpawnUnit();\n}\n\n// \u2705 Good - respects consumption\nif (!_layerManager.MouseConsumed &amp;&amp; \n    _input.IsMouseButtonPressed(MouseButton.Left))\n{\n    SpawnUnit();\n}</code></pre></p> </li> <li> <p>Verify layer is registered <pre><code>protected override void OnInitialize()\n{\n    _layerManager.RegisterLayer(_uiCanvas); // Don't forget!\n}</code></pre></p> </li> </ol>"},{"location":"guides/input/layers/#problem-ui-not-consuming-input","title":"Problem: UI Not Consuming Input","text":"<p>Symptom: UI layer doesn't block game input</p> <p>Solution: Ensure UICanvas returns true when appropriate:</p> <pre><code>// UICanvas.ProcessMouseInput should return true when:\n// - Hovering over button\n// - Clicking UI element\n// - Dragging slider\n// etc.\n\npublic bool ProcessMouseInput(IInputService input)\n{\n    HandleButtonInput();\n    // ... other UI handling ...\n\n    bool isInteractingWithUI = \n        _hoveredButton != null || \n        _pressedButton != null || \n        _activeSlider?.IsDragging == true;\n\n    return isInteractingWithUI; // TRUE = consume\n}</code></pre>"},{"location":"guides/input/layers/#problem-text-input-leaks-to-game","title":"Problem: Text Input Leaks to Game","text":"<p>Symptom: Typing \"W\" in textbox also moves player</p> <p>Solution: UICanvas consumes ALL keyboard when focused:</p> <pre><code>public bool ProcessKeyboardInput(IInputService input)\n{\n    // If text input is focused, consume ALL keyboard\n    if (_focusedTextInput != null &amp;&amp; _focusedTextInput.IsFocused)\n    {\n        HandleTextInputKeyboard();\n        return true; // Block game from seeing ANY keys\n    }\n\n    return false;\n}</code></pre>"},{"location":"guides/input/layers/#best-practices","title":"Best Practices","text":""},{"location":"guides/input/layers/#do","title":"DO","text":"<ol> <li> <p>Always call ProcessInput first <pre><code>protected override void OnUpdate(GameTime gameTime)\n{\n    _layerManager.ProcessInput(); // First!\n\n    if (!_layerManager.KeyboardConsumed)\n    {\n        // Game keyboard\n    }\n}</code></pre></p> </li> <li> <p>Check consumption flags <pre><code>if (!_layerManager.MouseConsumed)\n{\n    HandleGameMouse();\n}</code></pre></p> </li> <li> <p>Use appropriate priorities</p> </li> <li>Critical UI: 2000+</li> <li>Normal UI: 1000</li> <li>Game: 0</li> <li> <p>Background: -1000</p> </li> <li> <p>Return true when consuming <pre><code>public bool ProcessKeyboardInput(IInputService input)\n{\n    if (ShouldBlockGameInput())\n    {\n        return true; // Consume\n    }\n\n    return false; // Pass through\n}</code></pre></p> </li> <li> <p>Unregister layers when done <pre><code>protected override Task OnUnloadAsync(CancellationToken ct)\n{\n    _layerManager.UnregisterLayer(_myLayer);\n    return Task.CompletedTask;\n}</code></pre></p> </li> </ol>"},{"location":"guides/input/layers/#dont","title":"DON'T","text":"<ol> <li> <p>Don't forget ProcessInput <pre><code>// \u274c Bad\nprotected override void OnUpdate(GameTime gameTime)\n{\n    // Forgot _layerManager.ProcessInput();\n\n    if (_input.IsKeyDown(Keys.W)) // Wrong!\n}</code></pre></p> </li> <li> <p>Don't check input before ProcessInput <pre><code>// \u274c Bad order\nif (_input.IsMouseButtonPressed(MouseButton.Left)) // Too early!\n    SpawnUnit();\n\n_layerManager.ProcessInput(); // Too late!\n\n// \u2705 Good order\n_layerManager.ProcessInput(); // First\n\nif (!_layerManager.MouseConsumed &amp;&amp; \n    _input.IsMouseButtonPressed(MouseButton.Left))\n    SpawnUnit();</code></pre></p> </li> <li> <p>Don't ignore consumption flags <pre><code>// \u274c Bad\nif (_input.IsKeyDown(Keys.W))\n    MovePlayer(); // Moves even when typing!\n\n// \u2705 Good\nif (!_layerManager.KeyboardConsumed &amp;&amp; \n    _input.IsKeyDown(Keys.W))\n    MovePlayer();</code></pre></p> </li> <li> <p>Don't hardcode priorities <pre><code>// \u274c Bad\npublic int Priority =&gt; 1237; // Magic number!\n\n// \u2705 Good\npublic const int UI_PRIORITY = 1000;\npublic int Priority =&gt; UI_PRIORITY;</code></pre></p> </li> </ol>"},{"location":"guides/input/layers/#summary","title":"Summary","text":"Concept Purpose Input Layer Object that processes input at a priority InputLayerManager Routes input through layers by priority Priority Higher values = processed first Consumption Returning true = block lower layers KeyboardConsumed Check before handling game keyboard MouseConsumed Check before handling game mouse <p>Typical Priorities: - Dialog/Modal: 2000 - UI/Menu: 1000 - Game: 0 - Background: -1000</p>"},{"location":"guides/input/layers/#next-steps","title":"Next Steps","text":"<ul> <li>UI Components - Build interactive UI</li> <li>Text Input - Handle text fields</li> <li>Player Movement - Implement player controls</li> <li>Pause Menu - Create pause/menu systems</li> </ul> <p>Ready to build UI? Check out UI Components!</p>"},{"location":"guides/input/mouse/","title":"Mouse Input","text":"<p>Master mouse input handling in Brine2D for point-and-click gameplay, UI interaction, and camera control.</p>"},{"location":"guides/input/mouse/#overview","title":"Overview","text":"<p>Brine2D provides comprehensive mouse input via <code>IInputService</code>: - \u2705 Mouse buttons - Left, right, middle, X1, X2 - \u2705 Mouse position - Screen coordinates - \u2705 Mouse delta - Movement since last frame - \u2705 Scroll wheel - Zoom, scroll, etc.</p> <pre><code>sequenceDiagram\n    participant Game as Your Scene\n    participant Input as IInputService\n    participant SDL as SDL3\n\n    Note over SDL: Player Clicks Mouse\n    SDL-&gt;&gt;Input: MouseButtonDown Event\n\n    Note over Game: Each Frame\n    Game-&gt;&gt;Input: MousePosition?\n    Input-&gt;&gt;Game: Vector2(125, 340)\n\n    Game-&gt;&gt;Input: IsMouseButtonPressed(Left)?\n    Input-&gt;&gt;Game: true (first frame only)\n\n    Game-&gt;&gt;Input: IsMouseButtonDown(Left)?\n    Input-&gt;&gt;Game: true (while held)\n\n    Note over SDL: Player Moves Mouse\n    SDL-&gt;&gt;Input: MouseMotion Event\n\n    Game-&gt;&gt;Input: MouseDelta?\n    Input-&gt;&gt;Game: Vector2(5, -2)\n\n    Note over SDL: Player Scrolls Wheel\n    SDL-&gt;&gt;Input: MouseWheel Event\n\n    Game-&gt;&gt;Input: ScrollWheelDelta?\n    Input-&gt;&gt;Game: 1.0 (scroll up)</code></pre>"},{"location":"guides/input/mouse/#prerequisites","title":"Prerequisites","text":"<ul> <li>\u2705 Quick Start - Basic scene setup</li> <li>\u2705 Keyboard Input - Understanding input basics</li> </ul>"},{"location":"guides/input/mouse/#quick-example","title":"Quick Example","text":"<pre><code>using Brine2D.Core;\nusing Brine2D.Input;\nusing Brine2D.Rendering;\nusing Microsoft.Extensions.Logging;\nusing System.Numerics;\n\npublic class MouseScene : Scene\n{\n    private readonly IInputService _input;\n    private readonly IRenderer _renderer;\n\n    private Vector2 _cursorPosition;\n\n    public MouseScene(\n        IInputService input,\n        IRenderer renderer,\n        ILogger&lt;MouseScene&gt; logger\n    ) : base(logger)\n    {\n        _input = input;\n        _renderer = renderer;\n    }\n\n    protected override void OnUpdate(GameTime gameTime)\n    {\n        // Get mouse position\n        _cursorPosition = _input.MousePosition;\n\n        // Handle left click\n        if (_input.IsMouseButtonPressed(MouseButton.Left))\n        {\n            Logger.LogInformation(\"Clicked at: ({X}, {Y})\", \n                _cursorPosition.X, _cursorPosition.Y);\n        }\n    }\n\n    protected override void OnRender(GameTime gameTime)\n    {\n        _renderer.Clear(Color.Black);\n        _renderer.BeginFrame();\n\n        // Draw cursor position indicator\n        _renderer.DrawCircle(_cursorPosition.X, _cursorPosition.Y, 10, Color.Red);\n\n        // Show coordinates\n        _renderer.DrawText($\"Mouse: ({(int)_cursorPosition.X}, {(int)_cursorPosition.Y})\", \n            10, 10, Color.White);\n\n        _renderer.EndFrame();\n    }\n}</code></pre> <p>Result: Red circle follows cursor, displays coordinates!</p>"},{"location":"guides/input/mouse/#mouse-position","title":"Mouse Position","text":""},{"location":"guides/input/mouse/#get-current-position","title":"Get Current Position","text":"<pre><code>protected override void OnUpdate(GameTime gameTime)\n{\n    // Get current mouse position (screen coordinates)\n    var mousePos = _input.MousePosition;\n\n    Logger.LogInformation(\"Mouse at: X={X}, Y={Y}\", mousePos.X, mousePos.Y);\n}</code></pre> <p>Coordinates: - Origin <code>(0, 0)</code> = top-left corner - X increases \u2192 right - Y increases \u2192 down</p> <pre><code>Screen Coordinates:\n(0,0) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba X\n  \u2502\n  \u2502     (400, 300)\n  \u2502         \u25cf\n  \u2502\n  \u2502\n  \u25bc\n  Y</code></pre>"},{"location":"guides/input/mouse/#mouse-delta-movement","title":"Mouse Delta (Movement)","text":"<pre><code>protected override void OnUpdate(GameTime gameTime)\n{\n    // Get movement since last frame\n    var mouseDelta = _input.MouseDelta;\n\n    if (mouseDelta.LengthSquared() &gt; 0)\n    {\n        Logger.LogInformation(\"Mouse moved: ({X}, {Y})\", \n            mouseDelta.X, mouseDelta.Y);\n    }\n}</code></pre> <p>Use for: - Camera rotation (first-person) - Dragging objects - Mouse-look controls</p>"},{"location":"guides/input/mouse/#mouse-buttons","title":"Mouse Buttons","text":""},{"location":"guides/input/mouse/#available-buttons","title":"Available Buttons","text":"<pre><code>MouseButton.Left     // Primary button (left)\nMouseButton.Right    // Secondary button (right)\nMouseButton.Middle   // Scroll wheel click\nMouseButton.X1       // Extra button 1 (back)\nMouseButton.X2       // Extra button 2 (forward)</code></pre>"},{"location":"guides/input/mouse/#ismousebuttonpressed-click-detection","title":"IsMouseButtonPressed - Click Detection","text":"<p>Use for: Clicking UI, shooting, selecting</p> <pre><code>protected override void OnUpdate(GameTime gameTime)\n{\n    // Returns TRUE only on first frame of press\n    if (_input.IsMouseButtonPressed(MouseButton.Left))\n    {\n        var mousePos = _input.MousePosition;\n        SpawnObjectAt(mousePos);\n    }\n\n    if (_input.IsMouseButtonPressed(MouseButton.Right))\n    {\n        ShowContextMenu();\n    }\n}</code></pre>"},{"location":"guides/input/mouse/#ismousebuttondown-held-detection","title":"IsMouseButtonDown - Held Detection","text":"<p>Use for: Dragging, continuous shooting</p> <pre><code>protected override void OnUpdate(GameTime gameTime)\n{\n    // Returns TRUE every frame while held\n    if (_input.IsMouseButtonDown(MouseButton.Left))\n    {\n        var mousePos = _input.MousePosition;\n        ContinuousPaint(mousePos);\n    }\n}</code></pre>"},{"location":"guides/input/mouse/#ismousebuttonreleased-release-detection","title":"IsMouseButtonReleased - Release Detection","text":"<p>Use for: Drag-and-drop, charge attacks</p> <pre><code>private Vector2? _dragStart = null;\n\nprotected override void OnUpdate(GameTime gameTime)\n{\n    // Start drag\n    if (_input.IsMouseButtonPressed(MouseButton.Left))\n    {\n        _dragStart = _input.MousePosition;\n    }\n\n    // End drag\n    if (_input.IsMouseButtonReleased(MouseButton.Left))\n    {\n        if (_dragStart.HasValue)\n        {\n            var dragEnd = _input.MousePosition;\n            HandleDrag(_dragStart.Value, dragEnd);\n            _dragStart = null;\n        }\n    }\n}</code></pre>"},{"location":"guides/input/mouse/#scroll-wheel","title":"Scroll Wheel","text":""},{"location":"guides/input/mouse/#get-scroll-delta","title":"Get Scroll Delta","text":"<pre><code>protected override void OnUpdate(GameTime gameTime)\n{\n    var scroll = _input.ScrollWheelDelta;\n\n    if (scroll &gt; 0)\n    {\n        // Scrolled up\n        ZoomIn();\n    }\n    else if (scroll &lt; 0)\n    {\n        // Scrolled down\n        ZoomOut();\n    }\n}</code></pre> <p>Values: - <code>&gt; 0</code> = Scroll up - <code>&lt; 0</code> = Scroll down - <code>0</code> = No scroll this frame</p>"},{"location":"guides/input/mouse/#common-patterns","title":"Common Patterns","text":""},{"location":"guides/input/mouse/#pattern-1-point-and-click-movement","title":"Pattern 1: Point-and-Click Movement","text":"<pre><code>private Vector2 _playerPosition = new Vector2(400, 300);\nprivate Vector2? _targetPosition = null;\nprivate float _moveSpeed = 200f;\n\nprotected override void OnUpdate(GameTime gameTime)\n{\n    var deltaTime = (float)gameTime.DeltaTime;\n\n    // Click to set target\n    if (_input.IsMouseButtonPressed(MouseButton.Left))\n    {\n        _targetPosition = _input.MousePosition;\n    }\n\n    // Move towards target\n    if (_targetPosition.HasValue)\n    {\n        var direction = _targetPosition.Value - _playerPosition;\n        var distance = direction.Length();\n\n        if (distance &gt; 5f) // Close enough threshold\n        {\n            direction = Vector2.Normalize(direction);\n            _playerPosition += direction * _moveSpeed * deltaTime;\n        }\n        else\n        {\n            _targetPosition = null; // Arrived!\n        }\n    }\n}</code></pre>"},{"location":"guides/input/mouse/#pattern-2-click-detection-on-objects","title":"Pattern 2: Click Detection on Objects","text":"<pre><code>public class ClickableObject\n{\n    public Vector2 Position { get; set; }\n    public float Radius { get; set; }\n\n    public bool Contains(Vector2 point)\n    {\n        var offset = point - Position;\n        return offset.Length() &lt;= Radius;\n    }\n}\n\nprivate readonly List&lt;ClickableObject&gt; _objects = new();\n\nprotected override void OnUpdate(GameTime gameTime)\n{\n    if (_input.IsMouseButtonPressed(MouseButton.Left))\n    {\n        var mousePos = _input.MousePosition;\n\n        foreach (var obj in _objects)\n        {\n            if (obj.Contains(mousePos))\n            {\n                Logger.LogInformation(\"Clicked object at {Pos}\", obj.Position);\n                break; // First object only\n            }\n        }\n    }\n}</code></pre>"},{"location":"guides/input/mouse/#pattern-3-drag-and-drop","title":"Pattern 3: Drag and Drop","text":"<pre><code>private object? _draggedObject = null;\nprivate Vector2 _dragOffset;\n\nprotected override void OnUpdate(GameTime gameTime)\n{\n    var mousePos = _input.MousePosition;\n\n    // Start drag\n    if (_input.IsMouseButtonPressed(MouseButton.Left) &amp;&amp; _draggedObject == null)\n    {\n        _draggedObject = GetObjectUnderMouse(mousePos);\n\n        if (_draggedObject != null)\n        {\n            _dragOffset = mousePos - _draggedObject.Position;\n        }\n    }\n\n    // During drag\n    if (_input.IsMouseButtonDown(MouseButton.Left) &amp;&amp; _draggedObject != null)\n    {\n        _draggedObject.Position = mousePos - _dragOffset;\n    }\n\n    // End drag\n    if (_input.IsMouseButtonReleased(MouseButton.Left))\n    {\n        if (_draggedObject != null)\n        {\n            SnapToGrid(_draggedObject);\n            _draggedObject = null;\n        }\n    }\n}</code></pre>"},{"location":"guides/input/mouse/#pattern-4-camera-zoom-with-scroll","title":"Pattern 4: Camera Zoom with Scroll","text":"<pre><code>private float _cameraZoom = 1.0f;\n\nprotected override void OnUpdate(GameTime gameTime)\n{\n    var scroll = _input.ScrollWheelDelta;\n\n    if (Math.Abs(scroll) &gt; 0.001f)\n    {\n        // Zoom in/out\n        _cameraZoom += scroll * 0.1f;\n        _cameraZoom = Math.Clamp(_cameraZoom, 0.5f, 3.0f);\n\n        if (_camera != null)\n        {\n            _camera.Zoom = _cameraZoom;\n        }\n    }\n}</code></pre>"},{"location":"guides/input/mouse/#pattern-5-right-click-context-menu","title":"Pattern 5: Right-Click Context Menu","text":"<pre><code>private bool _showContextMenu = false;\nprivate Vector2 _contextMenuPosition;\n\nprotected override void OnUpdate(GameTime gameTime)\n{\n    // Show menu on right-click\n    if (_input.IsMouseButtonPressed(MouseButton.Right))\n    {\n        _contextMenuPosition = _input.MousePosition;\n        _showContextMenu = true;\n    }\n\n    // Hide menu on left-click elsewhere\n    if (_input.IsMouseButtonPressed(MouseButton.Left))\n    {\n        _showContextMenu = false;\n    }\n}\n\nprotected override void OnRender(GameTime gameTime)\n{\n    // ... render game ...\n\n    if (_showContextMenu)\n    {\n        DrawContextMenu(_contextMenuPosition);\n    }\n}</code></pre>"},{"location":"guides/input/mouse/#world-space-conversion","title":"World Space Conversion","text":"<p>When using a camera, convert mouse position from screen to world:</p> <pre><code>protected override void OnUpdate(GameTime gameTime)\n{\n    // Mouse position in screen space\n    var mouseScreen = _input.MousePosition;\n\n    // Convert to world space\n    var mouseWorld = _camera?.ScreenToWorld(mouseScreen) ?? mouseScreen;\n\n    // Now use world position\n    if (_input.IsMouseButtonPressed(MouseButton.Left))\n    {\n        SpawnObjectInWorld(mouseWorld);\n    }\n}</code></pre> <p>See Camera Guide for details</p>"},{"location":"guides/input/mouse/#advanced-techniques","title":"Advanced Techniques","text":""},{"location":"guides/input/mouse/#double-click-detection","title":"Double-Click Detection","text":"<pre><code>private float _lastClickTime = 0f;\nprivate const float DoubleClickThreshold = 0.3f; // seconds\n\nprotected override void OnUpdate(GameTime gameTime)\n{\n    var currentTime = (float)gameTime.TotalTime;\n\n    if (_input.IsMouseButtonPressed(MouseButton.Left))\n    {\n        var timeSinceLastClick = currentTime - _lastClickTime;\n\n        if (timeSinceLastClick &lt; DoubleClickThreshold)\n        {\n            // Double click!\n            OnDoubleClick();\n        }\n\n        _lastClickTime = currentTime;\n    }\n}</code></pre>"},{"location":"guides/input/mouse/#mouse-hover-detection","title":"Mouse Hover Detection","text":"<pre><code>private IUIComponent? _hoveredComponent = null;\n\nprotected override void OnUpdate(GameTime gameTime)\n{\n    var mousePos = _input.MousePosition;\n\n    // Find hovered component\n    IUIComponent? newHovered = null;\n\n    foreach (var component in _uiComponents)\n    {\n        if (component.Contains(mousePos))\n        {\n            newHovered = component;\n            break;\n        }\n    }\n\n    // Handle hover state changes\n    if (newHovered != _hoveredComponent)\n    {\n        _hoveredComponent?.OnHoverExit();\n        newHovered?.OnHoverEnter();\n        _hoveredComponent = newHovered;\n    }\n}</code></pre>"},{"location":"guides/input/mouse/#mouse-lock-fps-camera","title":"Mouse Lock (FPS Camera)","text":"<pre><code>private bool _mouseLocked = false;\nprivate Vector2 _cameraRotation;\n\nprotected override void OnUpdate(GameTime gameTime)\n{\n    // Toggle mouse lock with Tab\n    if (_input.IsKeyPressed(Keys.Tab))\n    {\n        _mouseLocked = !_mouseLocked;\n\n        if (_mouseLocked)\n        {\n            // Hide cursor, center it\n            // (SDL3 API needed - not yet exposed)\n        }\n    }\n\n    if (_mouseLocked)\n    {\n        var mouseDelta = _input.MouseDelta;\n        var sensitivity = 0.002f;\n\n        _cameraRotation.X += mouseDelta.X * sensitivity;\n        _cameraRotation.Y -= mouseDelta.Y * sensitivity;\n\n        // Clamp vertical rotation\n        _cameraRotation.Y = Math.Clamp(_cameraRotation.Y, -1.5f, 1.5f);\n\n        ApplyCameraRotation(_cameraRotation);\n    }\n}</code></pre>"},{"location":"guides/input/mouse/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guides/input/mouse/#problem-wrong-mouse-coordinates","title":"Problem: Wrong Mouse Coordinates","text":"<p>Symptom: Mouse position doesn't match visual location</p> <p>Causes &amp; Solutions:</p> <ol> <li> <p>Camera active <pre><code>// \u274c Problem: Using screen coords with camera\nvar mousePos = _input.MousePosition;\nSpawnAt(mousePos); // Wrong when camera moved!\n\n// \u2705 Solution: Convert to world space\nvar mouseWorld = _camera.ScreenToWorld(_input.MousePosition);\nSpawnAt(mouseWorld);</code></pre></p> </li> <li> <p>Window scaling/DPI</p> </li> <li>Usually handled automatically by SDL3</li> <li>Check <code>RenderingOptions.WindowWidth/Height</code> matches actual size</li> </ol>"},{"location":"guides/input/mouse/#problem-clicks-not-detected","title":"Problem: Clicks Not Detected","text":"<p>Symptom: <code>IsMouseButtonPressed()</code> always false</p> <p>Solutions:</p> <ol> <li> <p>Check correct button <pre><code>// \u274c Wrong button\nif (_input.IsMouseButtonPressed(MouseButton.Middle))\n\n// \u2705 Left button\nif (_input.IsMouseButtonPressed(MouseButton.Left))</code></pre></p> </li> <li> <p>UI consuming clicks <pre><code>// Check if UI consumed the click\nif (!_inputLayerManager.MouseConsumed)\n{\n    // Now safe to check game input\n    if (_input.IsMouseButtonPressed(MouseButton.Left))\n    {\n        // Handle game click\n    }\n}</code></pre></p> </li> </ol>"},{"location":"guides/input/mouse/#problem-scroll-wheel-not-working","title":"Problem: Scroll Wheel Not Working","text":"<p>Symptom: <code>ScrollWheelDelta</code> always 0</p> <p>Solutions:</p> <ol> <li> <p>Check each frame <pre><code>// \u274c Bad - only true for one frame\nif (_input.ScrollWheelDelta != 0)\n\n// \u2705 Good - explicit check\nvar scroll = _input.ScrollWheelDelta;\nif (scroll &gt; 0) ZoomIn();\nelse if (scroll &lt; 0) ZoomOut();</code></pre></p> </li> <li> <p>Verify window has focus</p> </li> <li>Scroll only works when window is focused</li> </ol>"},{"location":"guides/input/mouse/#best-practices","title":"Best Practices","text":""},{"location":"guides/input/mouse/#do","title":"DO","text":"<ol> <li> <p>Use <code>IsMouseButtonPressed</code> for clicks <pre><code>if (_input.IsMouseButtonPressed(MouseButton.Left))\n    HandleClick();</code></pre></p> </li> <li> <p>Convert to world space when using camera <pre><code>var worldPos = _camera.ScreenToWorld(_input.MousePosition);</code></pre></p> </li> <li> <p>Respect UI input consumption <pre><code>if (!_inputLayerManager.MouseConsumed)\n{\n    // Game input here\n}</code></pre></p> </li> <li> <p>Use smooth scrolling <pre><code>_targetZoom += _input.ScrollWheelDelta * 0.1f;\n_currentZoom = Lerp(_currentZoom, _targetZoom, 10f * deltaTime);</code></pre></p> </li> <li> <p>Provide visual feedback <pre><code>// Change cursor appearance on hover\nif (IsHoveringButton())\n    DrawHighlightedCursor();</code></pre></p> </li> </ol>"},{"location":"guides/input/mouse/#dont","title":"DON'T","text":"<ol> <li> <p>Don't ignore UI layers <pre><code>// \u274c Bad - clicks UI AND game\nif (_input.IsMouseButtonPressed(MouseButton.Left))\n    SpawnUnit(); // Spawns even when clicking UI!\n\n// \u2705 Good\nif (!_inputLayerManager.MouseConsumed &amp;&amp; \n    _input.IsMouseButtonPressed(MouseButton.Left))\n    SpawnUnit();</code></pre></p> </li> <li> <p>Don't forget camera transform <pre><code>// \u274c Bad with camera\nvar mousePos = _input.MousePosition;\n\n// \u2705 Good\nvar mousePos = _camera.ScreenToWorld(_input.MousePosition);</code></pre></p> </li> <li> <p>Don't hardcode button checks <pre><code>// \u274c Hard to rebind\nif (_input.IsMouseButtonPressed(MouseButton.Left))\n\n// \u2705 Use action mapping\nif (_inputMapper.IsActionPressed(\"PrimaryAction\"))</code></pre></p> </li> </ol>"},{"location":"guides/input/mouse/#summary","title":"Summary","text":"Method Returns Use For <code>MousePosition</code> <code>Vector2</code> Current cursor position <code>MouseDelta</code> <code>Vector2</code> Movement since last frame <code>ScrollWheelDelta</code> <code>float</code> Scroll amount (+ = up) <code>IsMouseButtonPressed(btn)</code> <code>bool</code> Clicking (first frame) <code>IsMouseButtonDown(btn)</code> <code>bool</code> Held (continuous) <code>IsMouseButtonReleased(btn)</code> <code>bool</code> Release detection"},{"location":"guides/input/mouse/#next-steps","title":"Next Steps","text":"<ul> <li>Input Layers - Priority-based input routing</li> <li>Gamepad Support - Add controller support</li> <li>UI Components - Build interactive UI</li> <li>Camera System - Handle world/screen conversion</li> </ul> <p>Ready to support controllers? Check out Gamepad Support!</p>"},{"location":"guides/performance/monitoring/","title":"Performance Monitoring","text":"<p>Learn how to use Brine2D's built-in performance overlay and profiling tools to identify bottlenecks and optimize your game.</p>"},{"location":"guides/performance/monitoring/#overview","title":"Overview","text":"<p>Brine2D includes a comprehensive performance monitoring system that provides real-time metrics without impacting game performance. The overlay displays FPS, frame time, memory usage, rendering statistics, and more.</p> <pre><code>graph LR\n    A[Game Loop] --&gt; B[PerformanceMonitor]\n    B --&gt; C[FPS Tracking]\n    B --&gt; D[Frame Time History]\n    B --&gt; E[Memory Stats]\n    B --&gt; F[Rendering Stats]\n    C --&gt; G[PerformanceOverlay]\n    D --&gt; G\n    E --&gt; G\n    F --&gt; G\n    G --&gt; H[On-Screen Display]</code></pre>"},{"location":"guides/performance/monitoring/#quick-start","title":"Quick Start","text":""},{"location":"guides/performance/monitoring/#enable-performance-monitoring","title":"Enable Performance Monitoring","text":"<p>Add performance monitoring to your game builder:</p> <pre><code>using Brine2D.Hosting;\nusing Brine2D.Rendering.Performance;\n\nvar builder = GameApplication.CreateBuilder(args);\n\n// Add performance monitoring with default settings\nbuilder.Services.AddPerformanceMonitoring(options =&gt;\n{\n    options.EnableOverlay = true;\n    options.ShowFPS = true;\n    options.ShowFrameTime = true;\n    options.ShowMemory = true;\n});\n\nvar game = builder.Build();\nawait game.RunAsync&lt;GameScene&gt;();</code></pre> <p>That's it! The performance overlay will now appear in your game.</p>"},{"location":"guides/performance/monitoring/#keyboard-shortcuts","title":"Keyboard Shortcuts","text":"<p>Control the performance overlay with these hotkeys:</p> Hotkey Action <code>F1</code> Toggle overlay visibility (on/off) <code>F3</code> Toggle detailed stats (includes frame time graph and memory) <p>Demo Scene</p> <p>Try the Performance Benchmark demo to see the overlay in action with 10,000+ sprites!</p> <pre><code>cd samples/FeatureDemos\ndotnet run\n# Select \"Performance Benchmark\" from menu</code></pre>"},{"location":"guides/performance/monitoring/#performance-metrics","title":"Performance Metrics","text":""},{"location":"guides/performance/monitoring/#fps-counter","title":"FPS Counter","text":"<p>The FPS counter tracks frames per second with historical data:</p> <p>Displayed Metrics: - Current FPS - Real-time frame rate - Min FPS - Lowest FPS recorded (since startup) - Max FPS - Highest FPS recorded - Average FPS - Rolling average (last 60 frames)</p> <p>Color Coding: - \ud83d\udfe2 Green - 60+ FPS (excellent) - \ud83d\udfe1 Yellow - 30-59 FPS (acceptable) - \ud83d\udd34 Red - Below 30 FPS (poor)</p> <pre><code>// Access FPS metrics programmatically\nvar monitor = serviceProvider.GetRequiredService&lt;PerformanceMonitor&gt;();\n\nvar currentFPS = monitor.CurrentFPS;\nvar minFPS = monitor.MinFPS;\nvar maxFPS = monitor.MaxFPS;\nvar avgFPS = monitor.AverageFPS;\n\nLogger.LogInformation($\"FPS: {currentFPS:F1} (Min: {minFPS:F0}, Max: {maxFPS:F0}, Avg: {avgFPS:F1})\");</code></pre>"},{"location":"guides/performance/monitoring/#frame-time","title":"Frame Time","text":"<p>Frame time measures how long each frame takes to render (in milliseconds):</p> <p>Key Metrics: - Current Frame Time - Time for the last frame - Frame Time Graph - Visual history of last 60 frames - Target Line - 16.67ms line (60 FPS target)</p> <p>Interpreting Frame Time: - &lt; 16.67ms - Running at 60+ FPS \u2705 - 16.67-33.33ms - Running at 30-60 FPS \u26a0\ufe0f - &gt; 33.33ms - Below 30 FPS \u274c</p> <pre><code>// Access frame time metrics\nvar frameTime = monitor.CurrentFrameTime;\nvar minFrameTime = monitor.MinFrameTime;\nvar maxFrameTime = monitor.MaxFrameTime;\n\nLogger.LogDebug($\"Frame Time: {frameTime:F2}ms\");</code></pre> <p>Frame Time Graph:</p> <p>The graph shows a rolling 60-frame history, with spikes indicating frame drops. Green bars indicate frames under the 60 FPS target (16.67ms), while red bars show slower frames.</p>"},{"location":"guides/performance/monitoring/#memory-statistics","title":"Memory Statistics","text":"<p>Track managed memory usage and garbage collection:</p> <p>Displayed Metrics: - Total Memory (MB) - Current managed heap size - GC Gen 0/1/2 - Collection counts per generation</p> <p>Understanding GC Generations: - Gen 0 - Short-lived objects (frequent, cheap) - Gen 1 - Medium-lived objects (less frequent) - Gen 2 - Long-lived objects (rare, expensive!)</p> <pre><code>// Access memory metrics\nvar memoryMB = monitor.TotalMemoryMB;\nvar gen0 = monitor.Gen0Collections;\nvar gen1 = monitor.Gen1Collections;\nvar gen2 = monitor.Gen2Collections;\n\nLogger.LogInformation($\"Memory: {memoryMB:F2} MB | GC: {gen0}/{gen1}/{gen2}\");</code></pre> <p>Watch Gen 2 Collections</p> <p>Frequent Gen 2 collections indicate memory pressure. Consider using object pooling (see Optimization Guide).</p>"},{"location":"guides/performance/monitoring/#rendering-statistics","title":"Rendering Statistics","text":"<p>Monitor sprite rendering performance:</p> <p>Displayed Metrics: - Entity Count - Total entities in the world - Sprite Count - Sprites rendered this frame - Culled Sprites - Off-screen sprites skipped - Draw Calls - Number of render batches - Batch Efficiency - Average sprites per batch</p> <pre><code>// Update rendering stats each frame\nmonitor.UpdateRenderStats(\n    drawCalls: 5,\n    entityCount: 1000,\n    spriteCount: 850,\n    culledSprites: 150,\n    batchCount: 5\n);\n\n// Access rendering stats\nvar drawCalls = monitor.DrawCalls;\nvar spriteCount = monitor.SpriteCount;\nvar batchEfficiency = monitor.BatchEfficiency; // sprites per batch\n\nLogger.LogDebug($\"Rendered {spriteCount} sprites in {drawCalls} batches ({batchEfficiency:F1}x efficiency)\");</code></pre> <p>Batch Efficiency: - 1x - No batching (poor) \ud83d\udd34 - 5-10x - Moderate batching (acceptable) \ud83d\udfe1 - 10+x - Excellent batching \u2705</p>"},{"location":"guides/performance/monitoring/#configuration-options","title":"Configuration Options","text":""},{"location":"guides/performance/monitoring/#basic-configuration","title":"Basic Configuration","text":"<pre><code>builder.Services.AddPerformanceMonitoring(options =&gt;\n{\n    // Toggle overlay visibility\n    options.EnableOverlay = true;\n\n    // Choose which stats to display\n    options.ShowFPS = true;\n    options.ShowFrameTime = true;\n    options.ShowMemory = true;\n});</code></pre>"},{"location":"guides/performance/monitoring/#advanced-configuration","title":"Advanced Configuration","text":"<pre><code>// Access overlay at runtime for customization\npublic class GameScene : Scene\n{\n    private readonly PerformanceOverlay _perfOverlay;\n\n    public GameScene(PerformanceOverlay perfOverlay, ILogger&lt;GameScene&gt; logger) : base(logger)\n    {\n        _perfOverlay = perfOverlay;\n\n        // Change overlay position\n        _perfOverlay.Position = OverlayPosition.TopLeft;\n\n        // Adjust update frequency (default: 0.25 seconds = 4 updates/sec)\n        _perfOverlay.DisplayUpdateInterval = 0.5; // Update twice per second\n\n        // Start with detailed stats visible\n        _perfOverlay.ShowDetailedStats = true;\n    }\n}</code></pre> <p>Overlay Positions: - <code>OverlayPosition.TopRight</code> (default) - <code>OverlayPosition.TopLeft</code> - <code>OverlayPosition.BottomLeft</code> - <code>OverlayPosition.BottomRight</code></p>"},{"location":"guides/performance/monitoring/#programmatic-access","title":"Programmatic Access","text":""},{"location":"guides/performance/monitoring/#manual-frame-timing","title":"Manual Frame Timing","text":"<p>Track custom operations:</p> <pre><code>public class GameScene : Scene\n{\n    private readonly PerformanceMonitor _monitor;\n\n    protected override void OnUpdate(GameTime gameTime)\n    {\n        // Monitor tracks frames automatically, but you can reset stats\n        if (Input.IsKeyPressed(Keys.R))\n        {\n            _monitor.Reset(); // Clear min/max/average stats\n            Logger.LogInformation(\"Performance stats reset!\");\n        }\n    }\n}</code></pre>"},{"location":"guides/performance/monitoring/#custom-profiling-regions","title":"Custom Profiling Regions","text":"<p>Profile specific code sections:</p> <pre><code>using System.Diagnostics;\n\npublic class AISystem : ECSSystem\n{\n    private readonly Stopwatch _stopwatch = new();\n\n    public override void Update(GameTime gameTime)\n    {\n        _stopwatch.Restart();\n\n        // Your AI logic here\n        ProcessEnemyAI();\n\n        _stopwatch.Stop();\n\n        if (_stopwatch.ElapsedMilliseconds &gt; 5)\n        {\n            Logger.LogWarning($\"AI system took {_stopwatch.ElapsedMilliseconds}ms (&gt; 5ms budget!)\");\n        }\n    }\n}</code></pre>"},{"location":"guides/performance/monitoring/#performance-targets","title":"Performance Targets","text":""},{"location":"guides/performance/monitoring/#60-fps-target","title":"60 FPS Target","text":"<p>Target specifications for smooth gameplay:</p> Metric Target Acceptable Poor FPS 60+ 30-59 &lt; 30 Frame Time &lt; 16.67ms 16.67-33.33ms &gt; 33.33ms Gen 2 GC 0/sec &lt; 1/sec &gt; 1/sec Batch Efficiency 10+x 5-10x &lt; 5x"},{"location":"guides/performance/monitoring/#platform-specific-targets","title":"Platform-Specific Targets","text":"<p>Adjust expectations based on platform:</p> <pre><code>// Desktop: Target 60 FPS\n// Mobile: Target 30 FPS (optional)\n// Web: Target 30-60 FPS depending on device\n\nvar targetFPS = RuntimeInformation.IsOSPlatform(OSPlatform.Windows) ? 60 : 30;\nLogger.LogInformation($\"Target FPS: {targetFPS}\");</code></pre>"},{"location":"guides/performance/monitoring/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guides/performance/monitoring/#high-frame-time-low-fps","title":"High Frame Time (Low FPS)","text":"<p>Symptoms: - FPS consistently below 60 - Frame time spikes above 16.67ms</p> <p>Common Causes: 1. Too many entities - Reduce entity count or use culling 2. Expensive queries - Cache queries, avoid complex predicates 3. Allocations - Use object pooling (see Optimization Guide) 4. Draw calls - Enable sprite batching</p> <p>Solutions:</p> <pre><code>// 1. Enable frustum culling (automatic with SpriteRenderingSystem)\nvar spriteSystem = world.GetSystem&lt;SpriteRenderingSystem&gt;();\nvar (rendered, culled) = spriteSystem.GetCullingStats();\nLogger.LogInfo($\"Rendered: {rendered}, Culled: {culled}\");\n\n// 2. Use cached queries\nvar enemies = world.CreateCachedQuery&lt;EnemyComponent, TransformComponent&gt;();\n\n// 3. Check batch efficiency\nvar (spriteCount, drawCalls) = spriteSystem.GetBatchStats();\nvar efficiency = (float)spriteCount / drawCalls;\nif (efficiency &lt; 5f)\n{\n    Logger.LogWarning($\"Low batch efficiency: {efficiency:F1}x\");\n}</code></pre>"},{"location":"guides/performance/monitoring/#frequent-gc-collections","title":"Frequent GC Collections","text":"<p>Symptoms: - Gen 2 collections increasing rapidly - Frame time spikes during collections</p> <p>Common Causes: 1. LINQ in hot paths - Use <code>for</code> loops instead 2. String concatenation - Use <code>StringBuilder</code> or string interpolation 3. New allocations - Use object pooling</p> <p>Solutions:</p> <pre><code>// \u274c BAD: Creates garbage\nvar results = world.Query()\n    .With&lt;EnemyComponent&gt;()\n    .Execute()\n    .ToList(); // Allocation!\n\nforeach (var enemy in results)\n{\n    var message = \"Enemy: \" + enemy.Name; // Allocation!\n}\n\n// \u2705 GOOD: Zero allocation\nvar enemies = world.CreateCachedQuery&lt;EnemyComponent&gt;();\n\nforeach (var enemy in enemies.Execute())\n{\n    Logger.LogDebug($\"Enemy: {enemy.Name}\"); // Interpolation is optimized\n}</code></pre> <p>See Performance Optimization for detailed guidance.</p>"},{"location":"guides/performance/monitoring/#low-batch-efficiency","title":"Low Batch Efficiency","text":"<p>Symptoms: - Batch efficiency &lt; 5x - High draw call count</p> <p>Common Causes: 1. Many different textures - Use texture atlases 2. Frequent layer changes - Group sprites by layer</p> <p>Solutions:</p> <pre><code>// Group sprites by texture and layer\nvar sprites = world.Query()\n    .With&lt;SpriteComponent&gt;()\n    .OrderBy(e =&gt; e.GetComponent&lt;SpriteComponent&gt;().Layer)\n    .ThenBy(e =&gt; e.GetComponent&lt;SpriteComponent&gt;().TexturePath)\n    .Execute();</code></pre>"},{"location":"guides/performance/monitoring/#best-practices","title":"Best Practices","text":""},{"location":"guides/performance/monitoring/#do","title":"DO","text":"<p>\u2705 Enable monitoring during development</p> <pre><code>#if DEBUG\nbuilder.Services.AddPerformanceMonitoring(options =&gt;\n{\n    options.EnableOverlay = true;\n    options.ShowDetailedStats = true;\n});\n#endif</code></pre> <p>\u2705 Profile before optimizing</p> <p>Measure first, optimize second. Don't guess where bottlenecks are!</p> <p>\u2705 Set performance budgets</p> <pre><code>const float MAX_FRAME_TIME = 16.67f; // 60 FPS\n\nif (monitor.CurrentFrameTime &gt; MAX_FRAME_TIME)\n{\n    Logger.LogWarning($\"Frame time exceeded budget: {monitor.CurrentFrameTime:F2}ms\");\n}</code></pre>"},{"location":"guides/performance/monitoring/#dont","title":"DON'T","text":"<p>\u274c Don't optimize prematurely</p> <p>Profile first to identify actual bottlenecks.</p> <p>\u274c Don't leave overlay enabled in production</p> <pre><code>// Only enable in debug builds\n#if !RELEASE\noptions.EnableOverlay = true;\n#endif</code></pre> <p>\u274c Don't ignore Gen 2 collections</p> <p>Frequent Gen 2 GCs indicate serious memory problems.</p>"},{"location":"guides/performance/monitoring/#next-steps","title":"Next Steps","text":"<ul> <li> <p>Optimization Guide</p> <p>Learn zero-allocation patterns</p> <p> Optimization Guide</p> </li> <li> <p>Particle System</p> <p>High-performance effects</p> <p> Particle System</p> </li> <li> <p>Sprite Batching</p> <p>Minimize draw calls</p> <p> Rendering Guide</p> </li> </ul> <p>Remember: Measure first, optimize second!</p>"},{"location":"guides/performance/optimization/","title":"Performance Optimization","text":"<p>Master zero-allocation patterns, object pooling, and other techniques to build high-performance games in Brine2D.</p>"},{"location":"guides/performance/optimization/#overview","title":"Overview","text":"<p>Brine2D is designed for performance from the ground up, using modern .NET techniques to minimize garbage collection pressure and maximize frame rates. This guide covers best practices for building games that run at 60+ FPS with minimal memory allocations.</p> <pre><code>graph TD\n    A[Performance Optimization] --&gt; B[Zero Allocations]\n    A --&gt; C[Object Pooling]\n    A --&gt; D[Sprite Batching]\n    A --&gt; E[Query Optimization]\n\n    B --&gt; F[ArrayPool]\n    B --&gt; G[Span &amp; stackalloc]\n    B --&gt; H[Cached Queries]\n\n    C --&gt; I[Particle Pools]\n    C --&gt; J[Entity Pools]\n    C --&gt; K[Custom Pools]\n\n    D --&gt; L[Texture Grouping]\n    D --&gt; M[Layer Sorting]\n    D --&gt; N[Frustum Culling]\n\n    E --&gt; O[Cached Queries]\n    E --&gt; P[Spatial Queries]\n    E --&gt; Q[Predicate Optimization]</code></pre>"},{"location":"guides/performance/optimization/#zero-allocation-patterns","title":"Zero-Allocation Patterns","text":""},{"location":"guides/performance/optimization/#understanding-allocations","title":"Understanding Allocations","text":"<p>Every <code>new</code> allocation creates garbage that must eventually be collected:</p> <pre><code>// \u274c BAD: Allocates every frame\nprotected override void OnUpdate(GameTime gameTime)\n{\n    var enemies = new List&lt;Entity&gt;(); // Allocation!\n\n    foreach (var entity in World.Entities)\n    {\n        if (entity.HasComponent&lt;EnemyComponent&gt;())\n        {\n            enemies.Add(entity);\n        }\n    }\n\n    // Process enemies...\n}</code></pre> <p>Problems: - Creates garbage every frame - Triggers Gen 0 collections (minor, but still pauses) - Eventually triggers Gen 2 collections (major pauses!)</p>"},{"location":"guides/performance/optimization/#arraypool","title":"ArrayPool <p>Use <code>ArrayPool&lt;T&gt;</code> for temporary buffers:</p> <pre><code>using System.Buffers;\n\n// \u2705 GOOD: Zero allocation\nprotected override void OnUpdate(GameTime gameTime)\n{\n    var enemyCount = World.GetEntitiesWithComponent&lt;EnemyComponent&gt;().Count();\n    var array = ArrayPool&lt;Entity&gt;.Shared.Rent(enemyCount);\n\n    try\n    {\n        int index = 0;\n        foreach (var entity in World.GetEntitiesWithComponent&lt;EnemyComponent&gt;())\n        {\n            array[index++] = entity;\n        }\n\n        // Process array[0..index]\n        for (int i = 0; i &lt; index; i++)\n        {\n            ProcessEnemy(array[i]);\n        }\n    }\n    finally\n    {\n        ArrayPool&lt;Entity&gt;.Shared.Return(array, clearArray: true);\n    }\n}</code></pre> <p>Benefits: - Zero allocation (array is reused) - No GC pressure - Minimal overhead</p> <p>Best Practices: - Always use <code>try/finally</code> to ensure return - Set <code>clearArray: true</code> to avoid memory leaks - Rent exact size if known, or slightly larger</p>","text":""},{"location":"guides/performance/optimization/#cached-queries","title":"Cached Queries <p>Brine2D's cached queries eliminate allocations in hot paths:</p> <pre><code>public class MovementSystem : ECSSystem\n{\n    private readonly IEntityWorld _world;\n    private readonly CachedQuery&lt;TransformComponent, VelocityComponent&gt; _movingEntities;\n\n    public MovementSystem(IEntityWorld world)\n    {\n        _world = world;\n\n        // Create cached query once (setup cost)\n        _movingEntities = world.CreateCachedQuery&lt;TransformComponent, VelocityComponent&gt;();\n    }\n\n    public override void Update(GameTime gameTime)\n    {\n        var deltaTime = (float)gameTime.DeltaTime;\n\n        // \u2705 Zero allocation per frame!\n        foreach (var entity in _movingEntities.Execute())\n        {\n            var transform = entity.GetComponent&lt;TransformComponent&gt;();\n            var velocity = entity.GetComponent&lt;VelocityComponent&gt;();\n\n            transform.Position += velocity.Velocity * deltaTime;\n        }\n    }\n}</code></pre> <p>When to Use: - Hot paths (every frame) - Systems processing many entities - Frequently executed queries</p> <p>Limitations: - Up to 3 component types - No complex predicates - Automatically invalidated on entity/component changes</p>","text":""},{"location":"guides/performance/optimization/#avoid-linq-in-hot-paths","title":"Avoid LINQ in Hot Paths <p>LINQ is convenient but allocates:</p> <pre><code>// \u274c BAD: LINQ allocates enumerators\nvar weakEnemies = World.Query()\n    .With&lt;EnemyComponent&gt;()\n    .With&lt;HealthComponent&gt;()\n    .Execute()\n    .Where(e =&gt; e.GetComponent&lt;HealthComponent&gt;().CurrentHealth &lt; 50) // Allocation!\n    .ToList(); // More allocation!\n\n// \u2705 GOOD: Manual iteration\nvar weakEnemies = new List&lt;Entity&gt;(capacity: 10); // Pre-allocate once\n\nforeach (var entity in World.Query()\n    .With&lt;EnemyComponent&gt;()\n    .With&lt;HealthComponent&gt;()\n    .Execute())\n{\n    var health = entity.GetComponent&lt;HealthComponent&gt;();\n    if (health.CurrentHealth &lt; 50)\n    {\n        weakEnemies.Add(entity);\n    }\n}</code></pre> <p>Even Better:</p> <pre><code>// \u2705 BEST: Use query predicates\nvar weakEnemies = World.Query()\n    .With&lt;EnemyComponent&gt;()\n    .With&lt;HealthComponent&gt;(h =&gt; h.CurrentHealth &lt; 50) // Filtered at query level!\n    .Execute();</code></pre>","text":""},{"location":"guides/performance/optimization/#object-pooling","title":"Object Pooling","text":""},{"location":"guides/performance/optimization/#built-in-particle-pooling","title":"Built-in Particle Pooling <p>Brine2D's particle system uses object pooling automatically:</p> <pre><code>// ParticleEmitterComponent uses ObjectPool&lt;Particle&gt; internally\nvar emitter = entity.AddComponent&lt;ParticleEmitterComponent&gt;();\nemitter.MaxParticles = 200;\nemitter.EmissionRate = 50f;\n\n// Particles are Get() from pool on spawn, Return() on death\n// Zero allocation per particle!</code></pre> <p>Under the Hood:</p> <pre><code>public class ParticleEmitterComponent : Component\n{\n    private readonly ObjectPool&lt;Particle&gt; _particlePool;\n\n    public ParticleEmitterComponent()\n    {\n        // Pool created once\n        _particlePool = new ObjectPool&lt;Particle&gt;(\n            createFunc: () =&gt; new Particle(),\n            resetAction: p =&gt; p.Reset(),\n            maxSize: MaxParticles\n        );\n    }\n\n    private void EmitParticle()\n    {\n        var particle = _particlePool.Get(); // Reuse existing particle\n        // Configure particle...\n        _particles.Add(particle);\n    }\n\n    private void UpdateParticle(Particle particle)\n    {\n        if (particle.IsExpired)\n        {\n            _particlePool.Return(particle); // Return to pool\n        }\n    }\n}</code></pre>","text":""},{"location":"guides/performance/optimization/#custom-object-pools","title":"Custom Object Pools <p>Create your own pools for frequently spawned objects:</p> <pre><code>using Brine2D.Core.Pooling;\n\npublic class BulletPool\n{\n    private readonly ObjectPool&lt;Entity&gt; _pool;\n    private readonly IEntityWorld _world;\n\n    public BulletPool(IEntityWorld world, int maxSize = 100)\n    {\n        _world = world;\n\n        _pool = new ObjectPool&lt;Entity&gt;(\n            createFunc: CreateBullet,\n            resetAction: ResetBullet,\n            maxSize: maxSize\n        );\n    }\n\n    private Entity CreateBullet()\n    {\n        var bullet = _world.CreateEntity(\"Bullet\");\n        bullet.AddComponent&lt;TransformComponent&gt;();\n        bullet.AddComponent&lt;VelocityComponent&gt;();\n        bullet.AddComponent&lt;SpriteComponent&gt;();\n        bullet.AddComponent&lt;BulletComponent&gt;();\n        bullet.IsActive = false; // Start disabled\n\n        return bullet;\n    }\n\n    private void ResetBullet(Entity bullet)\n    {\n        bullet.IsActive = false;\n        bullet.GetComponent&lt;TransformComponent&gt;().Position = Vector2.Zero;\n        bullet.GetComponent&lt;VelocityComponent&gt;().Velocity = Vector2.Zero;\n    }\n\n    public Entity SpawnBullet(Vector2 position, Vector2 velocity)\n    {\n        var bullet = _pool.Get();\n\n        bullet.IsActive = true;\n        bullet.GetComponent&lt;TransformComponent&gt;().Position = position;\n        bullet.GetComponent&lt;VelocityComponent&gt;().Velocity = velocity;\n\n        return bullet;\n    }\n\n    public void DespawnBullet(Entity bullet)\n    {\n        _pool.Return(bullet);\n    }\n}</code></pre> <p>Usage:</p> <pre><code>public class WeaponSystem : ECSSystem\n{\n    private readonly BulletPool _bulletPool;\n\n    public WeaponSystem(IEntityWorld world)\n    {\n        _bulletPool = new BulletPool(world, maxSize: 100);\n    }\n\n    public void FireWeapon(Vector2 position, Vector2 direction)\n    {\n        // \u2705 Zero allocation - bullet is pooled!\n        var bullet = _bulletPool.SpawnBullet(position, direction * 500f);\n    }\n\n    public void OnBulletHit(Entity bullet)\n    {\n        _bulletPool.DespawnBullet(bullet); // Return to pool\n    }\n}</code></pre>","text":""},{"location":"guides/performance/optimization/#pool-guidelines","title":"Pool Guidelines <p>When to Pool: - \u2705 Frequently spawned/destroyed objects (bullets, particles, effects) - \u2705 Large objects (expensive to allocate) - \u2705 Objects with complex initialization</p> <p>When NOT to Pool: - \u274c Rarely spawned objects (bosses, level geometry) - \u274c Objects with unique state - \u274c Small, simple structs (use stack allocation instead)</p> <p>Pool Sizing: - Set <code>maxSize</code> to expected maximum concurrent instances - Too small: Pool doesn't help much - Too large: Wastes memory</p>","text":""},{"location":"guides/performance/optimization/#sprite-batching","title":"Sprite Batching","text":""},{"location":"guides/performance/optimization/#automatic-batching","title":"Automatic Batching <p><code>SpriteRenderingSystem</code> automatically batches sprites:</p> <pre><code>// Sprites are automatically batched by:\n// 1. Texture (same texture = same batch)\n// 2. Layer (sort for correct rendering order)\n\nvar sprite1 = entity1.AddComponent&lt;SpriteComponent&gt;();\nsprite1.TexturePath = \"assets/enemy.png\";\nsprite1.Layer = 10;\n\nvar sprite2 = entity2.AddComponent&lt;SpriteComponent&gt;();\nsprite2.TexturePath = \"assets/enemy.png\"; // Same texture!\nsprite2.Layer = 10; // Same layer!\n\n// Both sprites rendered in 1 draw call! \u2705</code></pre> <p>Check Batching Efficiency:</p> <pre><code>var spriteSystem = world.GetSystem&lt;SpriteRenderingSystem&gt;();\nvar (spriteCount, drawCalls) = spriteSystem.GetBatchStats();\nvar efficiency = (float)spriteCount / drawCalls;\n\nLogger.LogDebug($\"Batch efficiency: {efficiency:F1}x ({spriteCount} sprites in {drawCalls} calls)\");\n\nif (efficiency &lt; 5f)\n{\n    Logger.LogWarning(\"Low batch efficiency! Consider using texture atlases.\");\n}</code></pre>","text":""},{"location":"guides/performance/optimization/#texture-atlases","title":"Texture Atlases <p>Combine multiple textures into one atlas:</p> <pre><code>// \u274c BAD: Many textures = many batches\nsprite1.TexturePath = \"assets/enemy1.png\";  // Batch 1\nsprite2.TexturePath = \"assets/enemy2.png\";  // Batch 2\nsprite3.TexturePath = \"assets/player.png\";  // Batch 3\n// 3 draw calls for 3 sprites!\n\n// \u2705 GOOD: One atlas = one batch\nsprite1.TexturePath = \"assets/atlas.png\";\nsprite1.SourceRect = new Rectangle(0, 0, 32, 32);    // Enemy 1\n\nsprite2.TexturePath = \"assets/atlas.png\";\nsprite2.SourceRect = new Rectangle(32, 0, 32, 32);   // Enemy 2\n\nsprite3.TexturePath = \"assets/atlas.png\";\nsprite3.SourceRect = new Rectangle(64, 0, 32, 32);   // Player\n\n// 1 draw call for 3 sprites! \u2705</code></pre> <p>Tools for Creating Atlases: - TexturePacker - ShoeBox - LibGDX Texture Packer</p>","text":""},{"location":"guides/performance/optimization/#layer-optimization","title":"Layer Optimization <p>Group sprites by layer to minimize state changes:</p> <pre><code>// \u2705 GOOD: Group by layer\nbackground.Layer = 0;   // All backgrounds\nterrain.Layer = 1;      // All terrain\nenemies.Layer = 10;     // All enemies\nplayer.Layer = 15;      // Player\neffects.Layer = 20;     // All effects\nui.Layer = 100;         // All UI\n\n// Rendered in order: 0 \u2192 1 \u2192 10 \u2192 15 \u2192 20 \u2192 100\n// Minimal layer switches = better batching!</code></pre>","text":""},{"location":"guides/performance/optimization/#query-optimization","title":"Query Optimization","text":""},{"location":"guides/performance/optimization/#spatial-queries","title":"Spatial Queries <p>Use spatial queries to reduce iteration:</p> <pre><code>// \u274c BAD: Check all entities\nforeach (var entity in World.Query().With&lt;EnemyComponent&gt;().Execute())\n{\n    var distance = Vector2.Distance(entity.Position, playerPosition);\n    if (distance &lt; 200f)\n    {\n        // Process nearby enemy\n    }\n}\n\n// \u2705 GOOD: Only iterate nearby entities\nvar nearbyEnemies = World.Query()\n    .WithinRadius(playerPosition, 200f)\n    .With&lt;EnemyComponent&gt;()\n    .Execute();\n\nforeach (var enemy in nearbyEnemies)\n{\n    // Already filtered by distance!\n}</code></pre>","text":""},{"location":"guides/performance/optimization/#component-predicates","title":"Component Predicates <p>Filter at query level, not in loops:</p> <pre><code>// \u274c BAD: Filter in loop\nforeach (var entity in World.Query().With&lt;HealthComponent&gt;().Execute())\n{\n    var health = entity.GetComponent&lt;HealthComponent&gt;();\n    if (health.CurrentHealth &lt; 50)\n    {\n        // Process low health...\n    }\n}\n\n// \u2705 GOOD: Filter in query\nvar lowHealthEntities = World.Query()\n    .With&lt;HealthComponent&gt;(h =&gt; h.CurrentHealth &lt; 50)\n    .Execute();\n\nforeach (var entity in lowHealthEntities)\n{\n    // Already filtered!\n}</code></pre>","text":""},{"location":"guides/performance/optimization/#query-complexity","title":"Query Complexity <p>Keep queries simple for best performance:</p> <pre><code>// \u26a0\ufe0f ACCEPTABLE: Simple predicate\nvar result = World.Query()\n    .With&lt;HealthComponent&gt;(h =&gt; h.CurrentHealth &lt; 50)\n    .Execute();\n\n// \u274c BAD: Complex predicate (executes per entity!)\nvar result = World.Query()\n    .With&lt;TransformComponent&gt;()\n    .Where(e =&gt; \n    {\n        var transform = e.GetComponent&lt;TransformComponent&gt;();\n        var distance = Vector2.Distance(transform.Position, playerPos);\n        var health = e.GetComponent&lt;HealthComponent&gt;();\n        return distance &lt; 200f &amp;&amp; health.CurrentHealth &lt; 50;\n    })\n    .Execute();\n\n// \u2705 BETTER: Split into multiple simpler queries\nvar nearbyLowHealth = World.Query()\n    .WithinRadius(playerPos, 200f)\n    .With&lt;HealthComponent&gt;(h =&gt; h.CurrentHealth &lt; 50)\n    .Execute();</code></pre>","text":""},{"location":"guides/performance/optimization/#memory-management","title":"Memory Management","text":""},{"location":"guides/performance/optimization/#avoid-string-allocations","title":"Avoid String Allocations <pre><code>// \u274c BAD: Concatenation allocates\nvar message = \"Player: \" + player.Name + \" HP: \" + player.Health;\n\n// \u2705 GOOD: Interpolation is optimized by compiler\nvar message = $\"Player: {player.Name} HP: {player.Health}\";\n\n// \u2705 BEST: StringBuilder for complex cases\nvar sb = new StringBuilder(capacity: 100); // Pre-allocate\nsb.Append(\"Player: \");\nsb.Append(player.Name);\nsb.Append(\" HP: \");\nsb.Append(player.Health);\nvar message = sb.ToString();\nsb.Clear(); // Reuse!</code></pre>","text":""},{"location":"guides/performance/optimization/#struct-vs-class","title":"Struct vs Class <p>Use structs for small, immutable data:</p> <pre><code>// \u2705 GOOD: Struct for small data (no allocation)\npublic struct Velocity\n{\n    public float X;\n    public float Y;\n\n    public Velocity(float x, float y)\n    {\n        X = x;\n        Y = y;\n    }\n}\n\n// Use it\nvar velocity = new Velocity(10, 20); // Stack allocated!</code></pre> <p>Guidelines: - \u2705 Use structs for &lt; 16 bytes - \u2705 Use structs for immutable data - \u274c Avoid large structs (copying is expensive) - \u274c Avoid mutable structs (confusing semantics)</p>","text":""},{"location":"guides/performance/optimization/#collection-capacity","title":"Collection Capacity <p>Pre-allocate collections with known sizes:</p> <pre><code>// \u274c BAD: Grows dynamically (allocates multiple times)\nvar list = new List&lt;Entity&gt;();\nfor (int i = 0; i &lt; 1000; i++)\n{\n    list.Add(CreateEntity()); // Reallocates at 4, 8, 16, 32...\n}\n\n// \u2705 GOOD: Pre-allocate\nvar list = new List&lt;Entity&gt;(capacity: 1000);\nfor (int i = 0; i &lt; 1000; i++)\n{\n    list.Add(CreateEntity()); // No reallocation!\n}</code></pre>","text":""},{"location":"guides/performance/optimization/#profiling-tips","title":"Profiling Tips","text":""},{"location":"guides/performance/optimization/#use-benchmarkdotnet","title":"Use BenchmarkDotNet <p>Micro-benchmark critical code:</p> <pre><code>using BenchmarkDotNet.Attributes;\nusing BenchmarkDotNet.Running;\n\n[MemoryDiagnoser]\npublic class QueryBenchmarks\n{\n    private IEntityWorld _world;\n\n    [GlobalSetup]\n    public void Setup()\n    {\n        _world = new EntityWorld();\n        // Create test entities...\n    }\n\n    [Benchmark]\n    public void QueryWithLinq()\n    {\n        var result = _world.Query()\n            .With&lt;EnemyComponent&gt;()\n            .Execute()\n            .Where(e =&gt; e.GetComponent&lt;HealthComponent&gt;().CurrentHealth &lt; 50)\n            .ToList();\n    }\n\n    [Benchmark]\n    public void QueryWithPredicate()\n    {\n        var result = _world.Query()\n            .With&lt;EnemyComponent&gt;()\n            .With&lt;HealthComponent&gt;(h =&gt; h.CurrentHealth &lt; 50)\n            .Execute();\n    }\n}\n\n// Run: dotnet run -c Release</code></pre>","text":""},{"location":"guides/performance/optimization/#measure-gc-pressure","title":"Measure GC Pressure <p>Track Gen 2 collections:</p> <pre><code>var gen2Before = GC.CollectionCount(2);\n\n// Run your code...\nRunGameLoop();\n\nvar gen2After = GC.CollectionCount(2);\nvar gen2Collections = gen2After - gen2Before;\n\nif (gen2Collections &gt; 0)\n{\n    Logger.LogWarning($\"Triggered {gen2Collections} Gen 2 collections!\");\n}</code></pre>","text":""},{"location":"guides/performance/optimization/#performance-checklist","title":"Performance Checklist","text":""},{"location":"guides/performance/optimization/#hot-path-checklist","title":"Hot Path Checklist <p>Before shipping, verify:</p> <ul> <li>[ ] No LINQ in hot paths (Update, Render)</li> <li>[ ] Cached queries for frequent lookups</li> <li>[ ] ArrayPool used for temporary buffers</li> <li>[ ] Object pools for frequently spawned objects</li> <li>[ ] Sprite batching enabled (check efficiency)</li> <li>[ ] Frustum culling enabled</li> <li>[ ] No string concatenation in loops</li> <li>[ ] Collections pre-allocated with capacity</li> <li>[ ] Gen 2 collections &lt; 1 per minute</li> <li>[ ] Frame time &lt; 16.67ms (60 FPS)</li> </ul>","text":""},{"location":"guides/performance/optimization/#best-practices","title":"Best Practices","text":""},{"location":"guides/performance/optimization/#do","title":"DO <p>\u2705 Profile before optimizing</p> <p>Use the Performance Monitor to identify real bottlenecks.</p> <p>\u2705 Use cached queries in systems</p> <pre><code>private readonly CachedQuery&lt;T1, T2&gt; _query = world.CreateCachedQuery&lt;T1, T2&gt;();</code></pre> <p>\u2705 Pool frequently spawned objects</p> <p>Bullets, particles, effects, projectiles.</p> <p>\u2705 Pre-allocate collections</p> <pre><code>var list = new List&lt;Entity&gt;(capacity: expectedSize);</code></pre> <p>\u2705 Use structs for small data</p> <p>Position, velocity, color (&lt; 16 bytes).</p>","text":""},{"location":"guides/performance/optimization/#dont","title":"DON'T <p>\u274c Don't use LINQ in hot paths</p> <p>LINQ allocates enumerators.</p> <p>\u274c Don't create new objects every frame</p> <p>Use pooling or reuse.</p> <p>\u274c Don't use <code>ToList()</code> on queries</p> <p>Iterate directly with <code>foreach</code>.</p> <p>\u274c Don't ignore GC warnings</p> <p>Gen 2 collections = serious problem!</p> <p>\u274c Don't optimize prematurely</p> <p>Measure first!</p>","text":""},{"location":"guides/performance/optimization/#next-steps","title":"Next Steps","text":"<ul> <li> <p>Performance Monitoring</p> <p>Measure and profile your game</p> <p> Monitoring Guide</p> </li> <li> <p>Particle System</p> <p>Zero-allocation effects</p> <p> Particle System</p> </li> <li> <p>Advanced Queries</p> <p>Optimize entity lookups</p> <p> Query Guide</p> </li> </ul> <p>Remember: Profile first, optimize second, measure results!</p>"},{"location":"guides/rendering/cameras/","title":"Camera System","text":"<p>Learn how to implement camera movement, zoom, rotation, and player following to create dynamic 2D worlds.</p>"},{"location":"guides/rendering/cameras/#overview","title":"Overview","text":"<p>A camera in 2D games defines what portion of the game world is visible on screen. Think of it like a virtual viewport that can: - \u2705 Move - Pan around the world - \u2705 Zoom - Get closer or farther from action - \u2705 Rotate - Tilt the view (optional) - \u2705 Follow - Track player smoothly - \u2705 Constrain - Stay within world bounds</p> <pre><code>graph TD\n    A[\"World Space&lt;br/&gt;(Game Objects)\"] --&gt; B[\"Camera Transform\"]\n    B --&gt; C[\"Screen Space&lt;br/&gt;(What You See)\"]\n\n    B --&gt; D[\"Position\"]\n    B --&gt; E[\"Zoom\"]\n    B --&gt; F[\"Rotation\"]\n\n    D --&gt; G[\"Follow Player\"]\n    D --&gt; H[\"Constrain to Bounds\"]\n\n    style A fill:#2d5016,stroke:#4ec9b0,stroke-width:2px,color:#fff\n    style B fill:#1e3a5f,stroke:#569cd6,stroke-width:2px,color:#fff\n    style C fill:#264f78,stroke:#4fc1ff,stroke-width:2px,color:#fff\n    style D fill:#3d3d2a,stroke:#dcdcaa,stroke-width:2px,color:#fff\n    style E fill:#3d3d2a,stroke:#dcdcaa,stroke-width:2px,color:#fff\n    style F fill:#3d3d2a,stroke:#dcdcaa,stroke-width:2px,color:#fff\n    style G fill:#4a3d1f,stroke:#ce9178,stroke-width:2px,color:#fff\n    style H fill:#4a3d1f,stroke:#ce9178,stroke-width:2px,color:#fff</code></pre>"},{"location":"guides/rendering/cameras/#prerequisites","title":"Prerequisites","text":"<ul> <li>\u2705 Quick Start - Basic scene setup</li> <li>\u2705 Drawing Basics - Understand rendering</li> <li>\u2705 Player Movement - Have something to follow</li> </ul>"},{"location":"guides/rendering/cameras/#quick-example","title":"Quick Example","text":""},{"location":"guides/rendering/cameras/#minimal-camera-setup","title":"Minimal Camera Setup","text":"<pre><code>using Brine2D.Core;\nusing Brine2D.Rendering;\nusing System.Numerics;\n\npublic class CameraScene : Scene\n{\n    private readonly IRenderer _renderer;\n    private Camera2D? _camera;\n    private Vector2 _playerPosition = new Vector2(400, 300);\n\n    public CameraScene(IRenderer renderer, ILogger&lt;CameraScene&gt; logger) \n        : base(logger) \n    {\n        _renderer = renderer;\n    }\n\n    protected override void OnInitialize()\n    {\n        // Create camera\n        _camera = new Camera2D(1280, 720); // viewport size\n        _camera.Position = _playerPosition;\n        _camera.Zoom = 1.0f;\n\n        // Set as renderer's active camera\n        _renderer.Camera = _camera;\n    }\n\n    protected override void OnUpdate(GameTime gameTime)\n    {\n        // Camera follows player smoothly\n        _camera?.LerpTo(_playerPosition, 5f * (float)gameTime.DeltaTime);\n    }\n\n    protected override void OnRender(GameTime gameTime)\n    {\n        _renderer.Clear(Color.CornflowerBlue);\n        _renderer.BeginFrame();\n\n        // Draw at world position (camera transforms automatically)\n        _renderer.DrawRectangle(_playerPosition.X - 25, _playerPosition.Y - 25, \n            50, 50, Color.Red);\n\n        _renderer.EndFrame();\n    }\n}</code></pre> <p>Result: Camera smoothly follows the player!</p>"},{"location":"guides/rendering/cameras/#concept-world-space-vs-screen-space","title":"Concept: World Space vs Screen Space","text":""},{"location":"guides/rendering/cameras/#without-camera-screen-space","title":"Without Camera (Screen Space)","text":"<pre><code>// Everything drawn at screen coordinates\n_renderer.DrawRectangle(100, 100, 50, 50, Color.Red);\n// Always at pixel (100, 100) on screen</code></pre>"},{"location":"guides/rendering/cameras/#with-camera-world-space","title":"With Camera (World Space)","text":"<pre><code>// Set camera\n_renderer.Camera = _camera;\n\n// Draw at WORLD coordinates\n_renderer.DrawRectangle(100, 100, 50, 50, Color.Red);\n// Camera transforms to screen position</code></pre> <p>Visual:</p> <pre><code>World Space (large):           Screen Space (viewport):\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                     \u2502       \u2502           \u2502\n\u2502   Player @(500,300) \u2502  \u2192\u2192\u2192  \u2502 Player    \u2502\n\u2502                     \u2502       \u2502 (centered)|\n\u2502  2000x2000 pixels   \u2502       \u2502 1280x720  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518</code></pre>"},{"location":"guides/rendering/cameras/#camera-basics","title":"Camera Basics","text":""},{"location":"guides/rendering/cameras/#create-a-camera","title":"Create a Camera","text":"<pre><code>protected override void OnInitialize()\n{\n    // Create camera with viewport size\n    _camera = new Camera2D(1280, 720);\n\n    // Set initial position (world coordinates)\n    _camera.Position = new Vector2(400, 300);\n\n    // Set zoom (1.0 = normal, 2.0 = 2x zoomed in)\n    _camera.Zoom = 1.0f;\n\n    // Set rotation (in degrees, 0 = no rotation)\n    _camera.Rotation = 0f;\n\n    // Activate camera\n    _renderer.Camera = _camera;\n}</code></pre>"},{"location":"guides/rendering/cameras/#camera-properties","title":"Camera Properties","text":"Property Type Description <code>Position</code> <code>Vector2</code> Camera center in world space <code>Zoom</code> <code>float</code> Zoom level (0.5 = zoomed out, 2.0 = zoomed in) <code>Rotation</code> <code>float</code> Rotation in degrees (clockwise) <code>ViewportWidth</code> <code>int</code> Screen width in pixels (readonly) <code>ViewportHeight</code> <code>int</code> Screen height in pixels (readonly)"},{"location":"guides/rendering/cameras/#camera-movement","title":"Camera Movement","text":""},{"location":"guides/rendering/cameras/#manual-movement-arrow-keys","title":"Manual Movement (Arrow Keys)","text":"<pre><code>protected override void OnUpdate(GameTime gameTime)\n{\n    if (_camera == null) return;\n\n    var deltaTime = (float)gameTime.DeltaTime;\n    var moveSpeed = 300f; // pixels per second\n    var movement = Vector2.Zero;\n\n    // Camera controls\n    if (_input.IsKeyDown(Keys.Left))  movement.X -= 1;\n    if (_input.IsKeyDown(Keys.Right)) movement.X += 1;\n    if (_input.IsKeyDown(Keys.Up))    movement.Y -= 1;\n    if (_input.IsKeyDown(Keys.Down))  movement.Y += 1;\n\n    if (movement != Vector2.Zero)\n    {\n        movement = Vector2.Normalize(movement);\n        _camera.Move(movement * moveSpeed * deltaTime);\n    }\n}</code></pre>"},{"location":"guides/rendering/cameras/#instant-centering","title":"Instant Centering","text":"<pre><code>// Immediately center camera on position\n_camera.CenterOn(new Vector2(500, 500));</code></pre>"},{"location":"guides/rendering/cameras/#smooth-following-lerp","title":"Smooth Following (Lerp)","text":"<pre><code>protected override void OnUpdate(GameTime gameTime)\n{\n    var deltaTime = (float)gameTime.DeltaTime;\n    var smoothing = 5f; // Higher = faster following\n\n    // Camera smoothly moves towards player\n    _camera?.LerpTo(_playerPosition, smoothing * deltaTime);\n}</code></pre> <p>Smoothing values: - <code>1f</code> - Very slow, cinematic - <code>5f</code> - Nice balance (recommended) - <code>10f</code> - Quick, responsive - <code>20f</code> - Almost instant</p>"},{"location":"guides/rendering/cameras/#zoom-control","title":"Zoom Control","text":""},{"location":"guides/rendering/cameras/#basic-zoom","title":"Basic Zoom","text":"<pre><code>protected override void OnUpdate(GameTime gameTime)\n{\n    if (_camera == null) return;\n\n    var deltaTime = (float)gameTime.DeltaTime;\n\n    // Q/E to zoom in/out\n    if (_input.IsKeyDown(Keys.Q))\n    {\n        _camera.Zoom = Math.Max(0.5f, _camera.Zoom - 1.0f * deltaTime);\n    }\n\n    if (_input.IsKeyDown(Keys.E))\n    {\n        _camera.Zoom = Math.Min(3.0f, _camera.Zoom + 1.0f * deltaTime);\n    }\n}</code></pre>"},{"location":"guides/rendering/cameras/#smooth-zoom","title":"Smooth Zoom","text":"<pre><code>private float _targetZoom = 1.0f;\n\nprotected override void OnUpdate(GameTime gameTime)\n{\n    var deltaTime = (float)gameTime.DeltaTime;\n\n    // Scroll wheel for zoom\n    var scrollDelta = _input.ScrollWheelDelta;\n    if (Math.Abs(scrollDelta) &gt; 0.001f)\n    {\n        _targetZoom = Math.Clamp(_targetZoom + scrollDelta * 0.1f, 0.5f, 3.0f);\n    }\n\n    // Smooth zoom transition\n    if (_camera != null)\n    {\n        _camera.Zoom = MathHelper.Lerp(_camera.Zoom, _targetZoom, 10f * deltaTime);\n    }\n}</code></pre>"},{"location":"guides/rendering/cameras/#zoom-presets","title":"Zoom Presets","text":"<pre><code>public enum ZoomLevel\n{\n    Far = 0,    // 0.5x - See more world\n    Normal = 1, // 1.0x - Standard view\n    Close = 2,  // 2.0x - Zoomed in\n    VeryClose = 3 // 3.0x - Very zoomed in\n}\n\nprivate void SetZoom(ZoomLevel level)\n{\n    _targetZoom = level switch\n    {\n        ZoomLevel.Far =&gt; 0.5f,\n        ZoomLevel.Normal =&gt; 1.0f,\n        ZoomLevel.Close =&gt; 2.0f,\n        ZoomLevel.VeryClose =&gt; 3.0f,\n        _ =&gt; 1.0f\n    };\n}</code></pre>"},{"location":"guides/rendering/cameras/#world-bounds","title":"World Bounds","text":"<p>Prevent camera from showing outside the world:</p>"},{"location":"guides/rendering/cameras/#create-bounds","title":"Create Bounds","text":"<pre><code>protected override void OnInitialize()\n{\n    _camera = new Camera2D(1280, 720);\n    _renderer.Camera = _camera;\n\n    // Define world boundaries (min/max coordinates)\n    _worldBounds = new CameraBounds(0, 0, 2000, 2000);\n}</code></pre>"},{"location":"guides/rendering/cameras/#constrain-camera","title":"Constrain Camera","text":"<pre><code>protected override void OnUpdate(GameTime gameTime)\n{\n    // Update camera position\n    _camera?.LerpTo(_playerPosition, 5f * (float)gameTime.DeltaTime);\n\n    // Clamp to world bounds\n    if (_camera != null &amp;&amp; _worldBounds != null)\n    {\n        _camera.Position = _worldBounds.ClampPosition(_camera.Position, _camera);\n    }\n}</code></pre> <p>How it works: - Calculates camera's visible area based on zoom - Prevents camera edges from showing outside world bounds - Automatically handles different zoom levels</p>"},{"location":"guides/rendering/cameras/#following-patterns","title":"Following Patterns","text":""},{"location":"guides/rendering/cameras/#pattern-1-direct-follow-no-smoothing","title":"Pattern 1: Direct Follow (No Smoothing)","text":"<pre><code>protected override void OnUpdate(GameTime gameTime)\n{\n    // Camera instantly follows player\n    if (_camera != null)\n    {\n        _camera.Position = _playerPosition;\n    }\n}</code></pre> <p>Use for: Tight, precise camera control (2D fighters, puzzle games)</p>"},{"location":"guides/rendering/cameras/#pattern-2-smooth-follow-lerp","title":"Pattern 2: Smooth Follow (Lerp)","text":"<pre><code>protected override void OnUpdate(GameTime gameTime)\n{\n    var deltaTime = (float)gameTime.DeltaTime;\n\n    // Camera smoothly follows\n    _camera?.LerpTo(_playerPosition, 5f * deltaTime);\n}</code></pre> <p>Use for: Most games (platformers, top-down shooters)</p>"},{"location":"guides/rendering/cameras/#pattern-3-deadzone-follow","title":"Pattern 3: Deadzone Follow","text":"<pre><code>private readonly float _deadzoneRadius = 100f;\n\nprotected override void OnUpdate(GameTime gameTime)\n{\n    if (_camera == null) return;\n\n    var deltaTime = (float)gameTime.DeltaTime;\n    var offset = _playerPosition - _camera.Position;\n    var distance = offset.Length();\n\n    // Only move camera if player leaves deadzone\n    if (distance &gt; _deadzoneRadius)\n    {\n        var direction = Vector2.Normalize(offset);\n        var moveAmount = distance - _deadzoneRadius;\n        _camera.Position += direction * moveAmount * 5f * deltaTime;\n    }\n}</code></pre> <p>Use for: Exploration games, slower-paced games</p> <pre><code>Deadzone Visualization:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                  \u2502\n\u2502   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2502\n\u2502   \u2502 Player \u2502     \u2502 Camera doesn't move\n\u2502   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2502\n\u2502   (deadzone)     \u2502\n\u2502                  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nPlayer moves outside \u2192 Camera follows</code></pre>"},{"location":"guides/rendering/cameras/#pattern-4-look-ahead-follow","title":"Pattern 4: Look-Ahead Follow","text":"<pre><code>private readonly float _lookAheadDistance = 150f;\n\nprotected override void OnUpdate(GameTime gameTime)\n{\n    var deltaTime = (float)gameTime.DeltaTime;\n\n    // Calculate player's facing direction from velocity\n    var facing = Vector2.Zero;\n    if (_playerVelocity.LengthSquared() &gt; 0.01f)\n    {\n        facing = Vector2.Normalize(_playerVelocity);\n    }\n\n    // Target is ahead of player\n    var lookAheadTarget = _playerPosition + facing * _lookAheadDistance;\n\n    _camera?.LerpTo(lookAheadTarget, 3f * deltaTime);\n}</code></pre> <p>Use for: Fast-paced games (racing, side-scrolling shooters)</p>"},{"location":"guides/rendering/cameras/#complete-camera-example","title":"Complete Camera Example","text":"<p>Here's a full scene with all camera features:</p> <pre><code>using Brine2D.Core;\nusing Brine2D.Input;\nusing Brine2D.Rendering;\nusing Microsoft.Extensions.Logging;\nusing System.Numerics;\n\npublic class CameraGameScene : Scene\n{\n    private readonly IRenderer _renderer;\n    private readonly IInputService _input;\n    private readonly IGameContext _gameContext;\n\n    private Camera2D? _camera;\n    private CameraBounds? _worldBounds;\n\n    private Vector2 _playerPosition = new Vector2(400, 300);\n    private float _playerSpeed = 200f;\n\n    private float _targetZoom = 1.0f;\n\n    public CameraGameScene(\n        IRenderer renderer,\n        IInputService input,\n        IGameContext gameContext,\n        ILogger&lt;CameraGameScene&gt; logger\n    ) : base(logger)\n    {\n        _renderer = renderer;\n        _input = input;\n        _gameContext = gameContext;\n    }\n\n    // ============================================\n    // INITIALIZATION\n    // ============================================\n    protected override void OnInitialize()\n    {\n        Logger.LogInformation(\"Camera Demo initialized!\");\n        Logger.LogInformation(\"Controls:\");\n        Logger.LogInformation(\"  WASD - Move player\");\n        Logger.LogInformation(\"  Q/E - Zoom out/in\");\n        Logger.LogInformation(\"  R - Reset camera\");\n        Logger.LogInformation(\"  ESC - Exit\");\n\n        // Create camera with viewport size\n        _camera = new Camera2D(1280, 720);\n        _camera.Position = _playerPosition;\n        _camera.Zoom = 1.0f;\n        _renderer.Camera = _camera;\n\n        // Set world bounds (2000x2000 world)\n        _worldBounds = new CameraBounds(0, 0, 2000, 2000);\n    }\n\n    // ============================================\n    // UPDATE\n    // ============================================\n    protected override void OnUpdate(GameTime gameTime)\n    {\n        var deltaTime = (float)gameTime.DeltaTime;\n\n        // Exit\n        if (_input.IsKeyPressed(Keys.Escape))\n        {\n            _gameContext.RequestExit();\n        }\n\n        // Player movement\n        UpdatePlayerMovement(deltaTime);\n\n        // Camera zoom controls\n        UpdateCameraZoom(deltaTime);\n\n        // Reset camera\n        if (_input.IsKeyPressed(Keys.R) &amp;&amp; _camera != null)\n        {\n            _camera.Zoom = 1.0f;\n            _targetZoom = 1.0f;\n            _camera.Rotation = 0f;\n        }\n\n        // Camera follows player smoothly\n        if (_camera != null &amp;&amp; _worldBounds != null)\n        {\n            _camera.LerpTo(_playerPosition, 5f * deltaTime);\n            _camera.Position = _worldBounds.ClampPosition(_camera.Position, _camera);\n        }\n    }\n\n    private void UpdatePlayerMovement(float deltaTime)\n    {\n        var movement = Vector2.Zero;\n\n        if (_input.IsKeyDown(Keys.W)) movement.Y -= 1;\n        if (_input.IsKeyDown(Keys.S)) movement.Y += 1;\n        if (_input.IsKeyDown(Keys.A)) movement.X -= 1;\n        if (_input.IsKeyDown(Keys.D)) movement.X += 1;\n\n        if (movement != Vector2.Zero)\n        {\n            movement = Vector2.Normalize(movement);\n            _playerPosition += movement * _playerSpeed * deltaTime;\n\n            // Keep player in world bounds\n            _playerPosition = new Vector2(\n                Math.Clamp(_playerPosition.X, 0, 2000),\n                Math.Clamp(_playerPosition.Y, 0, 2000));\n        }\n    }\n\n    private void UpdateCameraZoom(float deltaTime)\n    {\n        if (_camera == null) return;\n\n        // Zoom controls\n        if (_input.IsKeyDown(Keys.Q))\n        {\n            _targetZoom = Math.Max(0.5f, _targetZoom - 1.0f * deltaTime);\n        }\n\n        if (_input.IsKeyDown(Keys.E))\n        {\n            _targetZoom = Math.Min(3.0f, _targetZoom + 1.0f * deltaTime);\n        }\n\n        // Smooth zoom transition\n        _camera.Zoom = MathHelper.Lerp(_camera.Zoom, _targetZoom, 10f * deltaTime);\n    }\n\n    // ============================================\n    // RENDER\n    // ============================================\n    protected override void OnRender(GameTime gameTime)\n    {\n        _renderer.Clear(new Color(40, 40, 40));\n        _renderer.BeginFrame();\n\n        // Draw grid (to visualize camera movement)\n        DrawGrid();\n\n        // Draw player\n        DrawPlayer();\n\n        _renderer.EndFrame();\n    }\n\n    private void DrawGrid()\n    {\n        var gridSize = 100;\n        var gridColor = new Color(60, 60, 60);\n\n        // Draw vertical lines\n        for (int x = 0; x &lt;= 2000; x += gridSize)\n        {\n            _renderer.DrawRectangle(x, 0, 2, 2000, gridColor);\n        }\n\n        // Draw horizontal lines\n        for (int y = 0; y &lt;= 2000; y += gridSize)\n        {\n            _renderer.DrawRectangle(0, y, 2000, 2, gridColor);\n        }\n    }\n\n    private void DrawPlayer()\n    {\n        var playerSize = 50f;\n        _renderer.DrawRectangle(\n            _playerPosition.X - playerSize / 2,\n            _playerPosition.Y - playerSize / 2,\n            playerSize,\n            playerSize,\n            Color.Red);\n    }\n}\n\n// Helper class for smooth interpolation\npublic static class MathHelper\n{\n    public static float Lerp(float a, float b, float t)\n    {\n        return a + (b - a) * Math.Clamp(t, 0f, 1f);\n    }\n}</code></pre>"},{"location":"guides/rendering/cameras/#advanced-techniques","title":"Advanced Techniques","text":""},{"location":"guides/rendering/cameras/#camera-shake","title":"Camera Shake","text":"<p>Add screen shake for impact effects:</p> <pre><code>private float _shakeIntensity = 0f;\nprivate float _shakeDuration = 0f;\nprivate Random _random = new Random();\n\npublic void ShakeCamera(float intensity, float duration)\n{\n    _shakeIntensity = intensity;\n    _shakeDuration = duration;\n}\n\nprotected override void OnUpdate(GameTime gameTime)\n{\n    var deltaTime = (float)gameTime.DeltaTime;\n\n    // Update shake\n    if (_shakeDuration &gt; 0)\n    {\n        _shakeDuration -= deltaTime;\n\n        // Add random offset to camera\n        var shakeOffset = new Vector2(\n            (_random.NextSingle() - 0.5f) * 2f * _shakeIntensity,\n            (_random.NextSingle() - 0.5f) * 2f * _shakeIntensity);\n\n        if (_camera != null)\n        {\n            _camera.Position += shakeOffset;\n        }\n    }\n\n    // Normal camera movement\n    _camera?.LerpTo(_playerPosition, 5f * deltaTime);\n}\n\n// Trigger shake on explosion\nprivate void OnExplosion()\n{\n    ShakeCamera(intensity: 10f, duration: 0.3f);\n}</code></pre>"},{"location":"guides/rendering/cameras/#screen-to-world-conversion","title":"Screen-To-World Conversion","text":"<p>Convert mouse position to world coordinates:</p> <pre><code>protected override void OnUpdate(GameTime gameTime)\n{\n    // Get mouse position in screen space\n    var mouseScreen = _input.MousePosition;\n\n    // Convert to world space\n    var mouseWorld = _camera?.ScreenToWorld(mouseScreen) ?? mouseScreen;\n\n    // Now you can use world position for gameplay\n    if (_input.IsMouseButtonPressed(MouseButton.Left))\n    {\n        SpawnObjectAt(mouseWorld);\n    }\n}</code></pre>"},{"location":"guides/rendering/cameras/#multi-camera-setup","title":"Multi-Camera Setup","text":"<p>Have different cameras for different purposes:</p> <pre><code>private Camera2D? _gameCamera;\nprivate Camera2D? _minimapCamera;\n\nprotected override void OnInitialize()\n{\n    // Main game camera\n    _gameCamera = new Camera2D(1280, 720);\n    _gameCamera.Zoom = 1.0f;\n\n    // Minimap camera (zoomed out, top-right corner)\n    _minimapCamera = new Camera2D(200, 200);\n    _minimapCamera.Zoom = 0.2f; // See more world\n}\n\nprotected override void OnRender(GameTime gameTime)\n{\n    // Render main game view\n    _renderer.Camera = _gameCamera;\n    _renderer.Clear(Color.Black);\n    _renderer.BeginFrame();\n    DrawGameWorld();\n    _renderer.EndFrame();\n\n    // Render minimap (separate pass)\n    _renderer.Camera = _minimapCamera;\n    // ... render minimap ...\n    _renderer.Camera = null; // Reset to screen space\n}</code></pre>"},{"location":"guides/rendering/cameras/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guides/rendering/cameras/#problem-camera-jitters","title":"Problem: Camera Jitters","text":"<p>Symptom: Camera shakes or stutters</p> <p>Causes: - Rounding errors - Too fast lerp speed - Conflicting movement</p> <p>Solutions:</p> <pre><code>// 1. Smooth lerp speed\n_camera.LerpTo(_playerPosition, 5f * deltaTime); // Not 50f!\n\n// 2. Don't mix immediate and lerp\n// \u274c Bad\n_camera.Position = _playerPosition; // Instant\n_camera.LerpTo(_playerPosition, 5f * deltaTime); // Smooth\n\n// \u2705 Good - pick one\n_camera.LerpTo(_playerPosition, 5f * deltaTime);</code></pre>"},{"location":"guides/rendering/cameras/#problem-camera-shows-outside-world","title":"Problem: Camera Shows Outside World","text":"<p>Symptom: Black bars or empty space visible</p> <p>Solution: Use <code>CameraBounds</code> to constrain:</p> <pre><code>_worldBounds = new CameraBounds(0, 0, 2000, 2000);\n_camera.Position = _worldBounds.ClampPosition(_camera.Position, _camera);</code></pre>"},{"location":"guides/rendering/cameras/#problem-ui-not-showing","title":"Problem: UI Not Showing","text":"<p>Symptom: UI elements invisible or transformed</p> <p>Solution: Disable camera for UI rendering:</p> <pre><code>protected override void OnRender(GameTime gameTime)\n{\n    // Game world (with camera)\n    _renderer.Camera = _camera;\n    DrawGameWorld();\n\n    // UI (without camera)\n    _renderer.Camera = null; // Screen space\n    DrawUI();\n}</code></pre>"},{"location":"guides/rendering/cameras/#best-practices","title":"Best Practices","text":""},{"location":"guides/rendering/cameras/#do","title":"DO","text":"<ol> <li> <p>Use smooth following for better feel    <pre><code>_camera.LerpTo(_playerPosition, 5f * deltaTime);</code></pre></p> </li> <li> <p>Constrain to world bounds to avoid showing empty space    <pre><code>_camera.Position = _worldBounds.ClampPosition(_camera.Position, _camera);</code></pre></p> </li> <li> <p>Disable camera for UI to keep UI in screen space    <pre><code>_renderer.Camera = null; // Before rendering UI</code></pre></p> </li> <li> <p>Use reasonable zoom limits to prevent extreme views    <pre><code>_camera.Zoom = Math.Clamp(_camera.Zoom, 0.5f, 3.0f);</code></pre></p> </li> </ol>"},{"location":"guides/rendering/cameras/#dont","title":"DON'T","text":"<ol> <li> <p>Don't update camera position multiple times per frame <pre><code>// \u274c Bad - conflicts\n_camera.Position = _playerPosition;\n_camera.LerpTo(_target, 5f);</code></pre></p> </li> <li> <p>Don't forget delta time in camera movement    <pre><code>// \u274c Bad\n_camera.LerpTo(_target, 5f);\n\n// \u2705 Good\n_camera.LerpTo(_target, 5f * deltaTime);</code></pre></p> </li> <li> <p>Don't use extreme zoom values (causes rendering issues)    <pre><code>// \u274c Bad\n_camera.Zoom = 0.01f; // Too small\n_camera.Zoom = 100f;  // Too large</code></pre></p> </li> </ol>"},{"location":"guides/rendering/cameras/#performance-tips","title":"Performance Tips","text":"<ol> <li> <p>Culling - Only render visible objects:    <pre><code>foreach (var obj in _gameObjects)\n{\n    if (IsVisibleToCamera(obj, _camera))\n    {\n        obj.Render(_renderer);\n    }\n}</code></pre></p> </li> <li> <p>Grid rendering - Only draw visible grid cells:    <pre><code>var visibleBounds = _camera.GetVisibleBounds();\nvar startX = (int)(visibleBounds.Left / gridSize) * gridSize;\nvar endX = (int)(visibleBounds.Right / gridSize) * gridSize;\n// ... draw only visible portion</code></pre></p> </li> </ol>"},{"location":"guides/rendering/cameras/#summary","title":"Summary","text":"Feature Code Use Case Create Camera <code>new Camera2D(1280, 720)</code> Initialize Set Camera <code>_renderer.Camera = camera</code> Activate Direct Follow <code>camera.Position = target</code> Instant tracking Smooth Follow <code>camera.LerpTo(target, 5f * dt)</code> Smooth tracking Zoom <code>camera.Zoom = 2.0f</code> Get closer Bounds <code>new CameraBounds(0, 0, w, h)</code> Constrain view Screen\u2192World <code>camera.ScreenToWorld(pos)</code> Mouse to world World\u2192Screen <code>camera.WorldToScreen(pos)</code> World to screen"},{"location":"guides/rendering/cameras/#next-steps","title":"Next Steps","text":"<ul> <li>Animation - Animate camera movements</li> <li>Tilemaps - Optimize large world rendering</li> <li>Player Movement - Create smooth player controls</li> <li>Parallax Scrolling - Multi-layer backgrounds</li> </ul> <p>Ready to add more? Try Camera Shake and Effects!</p>"},{"location":"guides/rendering/choosing-renderer/","title":"Choosing a Renderer","text":"<p>Brine2D v0.7.0+ offers two rendering backends: the modern GPU Renderer and the classic Legacy Renderer. This guide helps you choose the right one for your project.</p>"},{"location":"guides/rendering/choosing-renderer/#quick-decision","title":"Quick Decision","text":"<p>Use GPU Renderer (default) if: - Building a new game - Need high performance (1,000+ sprites) - Targeting modern hardware (2015+) - Want future features (shaders, post-processing)</p> <p>Use Legacy Renderer if: - Maximum compatibility needed - Targeting older hardware - Simple game (&lt;500 sprites) - Experiencing GPU driver issues</p> <pre><code>graph TD\n    START[\"New Game?\"] --&gt; NEW{New Project?}\n    NEW --&gt;|Yes| SPRITES{Many Sprites?}\n    NEW --&gt;|No| EXISTING[\"Existing Game\"]\n\n    SPRITES --&gt;|\"1000+ sprites\"| GPU[\"Use GPU Renderer\"]\n    SPRITES --&gt;|\"&lt;500 sprites\"| EITHER[\"Either works\"]\n    SPRITES --&gt;|\"500-1000\"| PERF{Need max performance?}\n\n    PERF --&gt;|Yes| GPU\n    PERF --&gt;|No| EITHER\n\n    EITHER --&gt; MODERN{Modern hardware only?}\n    MODERN --&gt;|Yes| GPU\n    MODERN --&gt;|No| LEGACY[\"Use Legacy Renderer\"]\n\n    EXISTING --&gt; ISSUES{Have issues?}\n    ISSUES --&gt;|No| KEEP[\"Keep current\"]\n    ISSUES --&gt;|Yes| TRY[\"Try GPU renderer\"]\n\n    style START fill:#264f78,stroke:#4fc1ff,stroke-width:2px,color:#fff\n    style NEW fill:#4a2d4a,stroke:#c586c0,stroke-width:2px,color:#fff\n    style SPRITES fill:#4a2d4a,stroke:#c586c0,stroke-width:2px,color:#fff\n    style PERF fill:#4a2d4a,stroke:#c586c0,stroke-width:2px,color:#fff\n    style MODERN fill:#4a2d4a,stroke:#c586c0,stroke-width:2px,color:#fff\n    style ISSUES fill:#4a2d4a,stroke:#c586c0,stroke-width:2px,color:#fff\n    style EXISTING fill:#3d3d2a,stroke:#dcdcaa,stroke-width:2px,color:#fff\n    style GPU fill:#2d5016,stroke:#4ec9b0,stroke-width:3px,color:#fff\n    style LEGACY fill:#4a3d1f,stroke:#ce9178,stroke-width:2px,color:#fff\n    style EITHER fill:#1e3a5f,stroke:#569cd6,stroke-width:2px,color:#fff\n    style KEEP fill:#3d3d2a,stroke:#dcdcaa,stroke-width:2px,color:#fff\n    style TRY fill:#2d5016,stroke:#4ec9b0,stroke-width:2px,color:#fff</code></pre>"},{"location":"guides/rendering/choosing-renderer/#renderer-overview","title":"Renderer Overview","text":""},{"location":"guides/rendering/choosing-renderer/#gpu-renderer-recommended","title":"GPU Renderer (Recommended)","text":"<p>Modern shader-based renderer using SDL3's GPU API.</p> <p>Graphics APIs: - Vulkan (Windows, Linux, Android) - Metal (macOS, iOS) - Direct3D 11 (Windows) - Direct3D 12 (Windows 10+)</p> <p>Best For: - Modern games (2020+) - High sprite counts - Particle effects - Future features</p> <p>Requires: - Modern GPU (2015+) - Updated drivers - Vulkan/Metal/D3D11+ support</p>"},{"location":"guides/rendering/choosing-renderer/#legacy-renderer","title":"Legacy Renderer","text":"<p>Classic SDL_Renderer API with broader compatibility.</p> <p>Graphics APIs: - Platform-specific backends - Software fallback available - OpenGL (some platforms)</p> <p>Best For: - Maximum compatibility - Simple 2D games - Older hardware - Fallback option</p> <p>Requires: - Any GPU or CPU - SDL3 support - Minimal driver requirements</p>"},{"location":"guides/rendering/choosing-renderer/#feature-comparison","title":"Feature Comparison","text":"Feature GPU Renderer Legacy Renderer Graphics API Vulkan/Metal/D3D11/D3D12 Platform-specific Rendering Shader-based Fixed-function Max sprites/frame 10,000+ @ 60 FPS 1,000-5,000 @ 60 FPS Batching Advanced vertex batching Basic batching Texture switches Optimized Moderate overhead Custom shaders Future support No Post-processing Future support No Render-to-texture Future support Limited Platform support Modern systems Broader Driver requirements Up-to-date drivers Minimal Memory usage Efficient Moderate Initialization Slower Faster"},{"location":"guides/rendering/choosing-renderer/#performance-comparison","title":"Performance Comparison","text":""},{"location":"guides/rendering/choosing-renderer/#sprite-rendering-benchmarks","title":"Sprite Rendering Benchmarks","text":"<pre><code>Test: Render sprites at 60 FPS target\nHardware: GTX 1060 / Ryzen 5 3600\n\nSprite Count    GPU Renderer    Legacy Renderer\n-----------     ------------    ---------------\n100 sprites     60 FPS \u2588\u2588\u2588\u2588     60 FPS \u2588\u2588\u2588\u2588\n500 sprites     60 FPS \u2588\u2588\u2588\u2588     60 FPS \u2588\u2588\u2588\u2588\n1,000 sprites   60 FPS \u2588\u2588\u2588\u2588     60 FPS \u2588\u2588\u2588\u2588\n2,500 sprites   60 FPS \u2588\u2588\u2588\u2588     55 FPS \u2588\u2588\u2588\u2591\n5,000 sprites   60 FPS \u2588\u2588\u2588\u2588     45 FPS \u2588\u2588\u2591\u2591\n10,000 sprites  60 FPS \u2588\u2588\u2588\u2588     25 FPS \u2588\u2591\u2591\u2591\n\nWinner: GPU Renderer (+140% at 10k sprites)</code></pre>"},{"location":"guides/rendering/choosing-renderer/#texture-switch-performance","title":"Texture Switch Performance","text":"<pre><code>Test: 100 sprites with different textures\n\nGPU Renderer:     Legacy Renderer:\n- 100 sprites     - 100 sprites\n- 50 textures     - 50 textures\n- 60 FPS \u2588\u2588\u2588\u2588     - 45 FPS \u2588\u2588\u2591\u2591\n\nWinner: GPU Renderer (33% better)</code></pre>"},{"location":"guides/rendering/choosing-renderer/#particle-systems","title":"Particle Systems","text":"<pre><code>Test: Particles at 60 FPS\n\nParticle Count   GPU Renderer    Legacy Renderer\n--------------   ------------    ---------------\n1,000            60 FPS \u2588\u2588\u2588\u2588     60 FPS \u2588\u2588\u2588\u2588\n5,000            60 FPS \u2588\u2588\u2588\u2588     40 FPS \u2588\u2588\u2591\u2591\n10,000           60 FPS \u2588\u2588\u2588\u2588     20 FPS \u2588\u2591\u2591\u2591\n50,000           55 FPS \u2588\u2588\u2588\u2591     5 FPS \u2591\u2591\u2591\u2591\n\nWinner: GPU Renderer (300% better)</code></pre> <p>Summary: - Simple games (&lt;500 sprites): Equal performance - Medium games (500-2,500): GPU 20-30% faster - Complex games (2,500+): GPU 100-300% faster</p>"},{"location":"guides/rendering/choosing-renderer/#use-cases","title":"Use Cases","text":""},{"location":"guides/rendering/choosing-renderer/#when-to-use-gpu-renderer","title":"When to Use GPU Renderer","text":"<p>1. High-Performance Games</p> <pre><code>// Bullet hell shooter with 1000+ bullets\npublic class BulletHellScene : Scene\n{\n    private List&lt;Bullet&gt; _bullets = new();\n\n    protected override void OnRender(GameTime gameTime)\n    {\n        // GPU renderer handles this easily\n        foreach (var bullet in _bullets)\n        {\n            _renderer.DrawTexture(_bulletTexture, bullet.X, bullet.Y);\n        }\n        // 1000+ sprites at 60 FPS!\n    }\n}</code></pre> <p>2. Particle-Heavy Games</p> <pre><code>// Particle effects game\npublic class ParticleScene : Scene\n{\n    private ParticleEmitter _emitter;\n\n    protected override void OnUpdate(GameTime gameTime)\n    {\n        // GPU renderer: 10,000+ particles at 60 FPS\n        _emitter.Emit(100);  // 100 particles per frame\n    }\n}</code></pre> <p>3. Future-Proof Projects</p> <pre><code>// Planning to add shaders/post-processing later\nbuilder.Services.AddSDL3Rendering(options =&gt;\n{\n    options.Backend = GraphicsBackend.GPU;\n    // Ready for future features\n});</code></pre> <p>4. Modern Platforms Only</p> <pre><code>// Targeting Steam Deck, modern PCs, consoles\nbuilder.Services.AddSDL3Rendering(options =&gt;\n{\n    options.Backend = GraphicsBackend.GPU;\n    // Excellent performance on modern hardware\n});</code></pre>"},{"location":"guides/rendering/choosing-renderer/#when-to-use-legacy-renderer","title":"When to Use Legacy Renderer","text":"<p>1. Maximum Compatibility</p> <pre><code>// Need to run on very old hardware\nbuilder.Services.AddSDL3Rendering(options =&gt;\n{\n    options.Backend = GraphicsBackend.LegacyRenderer;\n    // Works on nearly anything\n});</code></pre> <p>2. Simple Games</p> <pre><code>// Turn-based strategy with &lt;100 sprites\npublic class StrategyScene : Scene\n{\n    protected override void OnRender(GameTime gameTime)\n    {\n        // Draw board (small sprite count)\n        foreach (var tile in _board)\n        {\n            _renderer.DrawTexture(_tileTexture, tile.X, tile.Y);\n        }\n        // Legacy renderer is fine here\n    }\n}</code></pre> <p>3. GPU Driver Issues</p> <pre><code>// Fallback for systems with GPU problems\ntry\n{\n    builder.Services.AddSDL3Rendering(options =&gt;\n    {\n        options.Backend = GraphicsBackend.GPU;\n    });\n}\ncatch\n{\n    builder.Services.AddSDL3Rendering(options =&gt;\n    {\n        options.Backend = GraphicsBackend.LegacyRenderer;\n    });\n}</code></pre> <p>4. Faster Initialization</p> <pre><code>// Quick prototyping/testing\nbuilder.Services.AddSDL3Rendering(options =&gt;\n{\n    options.Backend = GraphicsBackend.LegacyRenderer;\n    // Faster startup\n});</code></pre>"},{"location":"guides/rendering/choosing-renderer/#configuration-examples","title":"Configuration Examples","text":""},{"location":"guides/rendering/choosing-renderer/#gpu-renderer-setup","title":"GPU Renderer Setup","text":"<pre><code>using Brine2D.Hosting;\nusing Brine2D.Rendering.SDL;\n\nvar builder = GameApplication.CreateBuilder(args);\n\nbuilder.Services.AddSDL3Rendering(options =&gt;\n{\n    options.Backend = GraphicsBackend.GPU;  // Explicit\n    options.WindowWidth = 1280;\n    options.WindowHeight = 720;\n    options.VSync = true;\n\n    // Optional: Force specific API\n    // options.PreferredGPUDriver = \"Vulkan\";\n});\n\nbuilder.Services.AddScene&lt;GameScene&gt;();\n\nvar game = builder.Build();\nawait game.RunAsync&lt;GameScene&gt;();</code></pre> <p>```json gamesettings.json {   \"Rendering\": {     \"Backend\": \"GPU\",     \"WindowTitle\": \"My Game\",     \"WindowWidth\": 1280,     \"WindowHeight\": 720,     \"VSync\": true,     \"PreferredGPUDriver\": null   } } <pre><code>\n---\n\n### Legacy Renderer Setup\n\n```csharp\nusing Brine2D.Hosting;\nusing Brine2D.Rendering.SDL;\n\nvar builder = GameApplication.CreateBuilder(args);\n\nbuilder.Services.AddSDL3Rendering(options =&gt;\n{\n    options.Backend = GraphicsBackend.LegacyRenderer;  // Explicit\n    options.WindowWidth = 1280;\n    options.WindowHeight = 720;\n    options.VSync = true;\n});\n\nbuilder.Services.AddScene&lt;GameScene&gt;();\n\nvar game = builder.Build();\nawait game.RunAsync&lt;GameScene&gt;();</code></pre></p> <p>```json gamesettings.json {   \"Rendering\": {     \"Backend\": \"LegacyRenderer\",     \"WindowTitle\": \"My Game\",     \"WindowWidth\": 1280,     \"WindowHeight\": 720,     \"VSync\": true   } } <pre><code>\n---\n\n### Runtime Fallback\n\n```csharp\nvar builder = GameApplication.CreateBuilder(args);\n\n// Try GPU first, fallback to Legacy\nbuilder.Services.AddSDL3Rendering(options =&gt;\n{\n    var backendSetting = builder.Configuration[\"Rendering:Backend\"];\n\n    options.Backend = backendSetting?.ToLower() switch\n    {\n        \"gpu\" =&gt; GraphicsBackend.GPU,\n        \"legacy\" =&gt; GraphicsBackend.LegacyRenderer,\n        _ =&gt; GraphicsBackend.Auto  // Let SDL3 decide\n    };\n\n    builder.Configuration.GetSection(\"Rendering\").Bind(options);\n});</code></pre></p>"},{"location":"guides/rendering/choosing-renderer/#platform-recommendations","title":"Platform Recommendations","text":""},{"location":"guides/rendering/choosing-renderer/#windows","title":"Windows","text":"<pre><code>// Recommended: GPU renderer with D3D11\noptions.Backend = GraphicsBackend.GPU;\noptions.PreferredGPUDriver = null;  // Auto-select D3D11\n\n// Alternative: Force Vulkan for testing\n// options.PreferredGPUDriver = \"Vulkan\";\n\n// Fallback: Legacy for older systems\n// options.Backend = GraphicsBackend.LegacyRenderer;</code></pre> <p>Target Hardware: - GPU: Windows 7+ with D3D11 GPU (2010+) - Legacy: Windows XP+ with any GPU</p>"},{"location":"guides/rendering/choosing-renderer/#macos-ios","title":"macOS / iOS","text":"<pre><code>// Recommended: GPU renderer (Metal only)\noptions.Backend = GraphicsBackend.GPU;\n// PreferredGPUDriver ignored (Metal automatic)\n\n// Fallback: Legacy for older Macs\n// options.Backend = GraphicsBackend.LegacyRenderer;</code></pre> <p>Target Hardware: - GPU: macOS 10.15+ (2019+), iOS 13+ - Legacy: macOS 10.9+ (2013+)</p>"},{"location":"guides/rendering/choosing-renderer/#linux","title":"Linux","text":"<pre><code>// Recommended: GPU renderer (Vulkan)\noptions.Backend = GraphicsBackend.GPU;\n// Vulkan automatic on Linux\n\n// Fallback: Legacy if Vulkan unavailable\n// options.Backend = GraphicsBackend.LegacyRenderer;</code></pre> <p>Target Hardware: - GPU: Vulkan-capable GPU + drivers - Legacy: Any GPU with OpenGL 2.1+</p> <p>Check Vulkan support: <pre><code>vulkaninfo | grep \"Vulkan Instance Version\"</code></pre></p>"},{"location":"guides/rendering/choosing-renderer/#steam-deck","title":"Steam Deck","text":"<pre><code>// Recommended: GPU renderer (optimized for Deck)\noptions.Backend = GraphicsBackend.GPU;\n// Excellent Vulkan performance on Steam Deck</code></pre> <p>Performance: - GPU renderer: 60 FPS with 5,000+ sprites - Legacy renderer: 30-45 FPS with 2,000 sprites</p>"},{"location":"guides/rendering/choosing-renderer/#decision-matrix","title":"Decision Matrix","text":"<p>Use this table to help choose:</p> Game Type Sprite Count Target Hardware Recommended Renderer Puzzle game &lt;100 Any Legacy Platformer 100-500 Modern GPU Platformer 100-500 Old PC Legacy Bullet hell 1,000+ Modern GPU Bullet hell 1,000+ Old PC GPU (with settings) RPG 200-500 Any Either RTS 500-2,000 Modern GPU RTS 500-2,000 Old PC Legacy Particle demo 10,000+ Modern GPU only Turn-based &lt;50 Any Legacy <p>Key: - GPU = Strongly recommended - GPU = Recommended - Either = No significant difference - Legacy = Better choice</p>"},{"location":"guides/rendering/choosing-renderer/#testing-both-renderers","title":"Testing Both Renderers","text":""},{"location":"guides/rendering/choosing-renderer/#method-1-configuration-switch","title":"Method 1: Configuration Switch","text":"<p>```json gamesettings.json {   \"Rendering\": {     \"Backend\": \"GPU\"  // Change to \"LegacyRenderer\" to test   } } <pre><code>\n### Method 2: Command-Line Override\n\n```csharp\nvar builder = GameApplication.CreateBuilder(args);\n\nbuilder.Services.AddSDL3Rendering(options =&gt;\n{\n    // Check for --legacy argument\n    var useLegacy = args.Contains(\"--legacy\");\n\n    options.Backend = useLegacy \n        ? GraphicsBackend.LegacyRenderer \n        : GraphicsBackend.GPU;\n});</code></pre></p> <p>Run with: <pre><code># GPU renderer (default)\ndotnet run\n\n# Legacy renderer\ndotnet run -- --legacy</code></pre></p>"},{"location":"guides/rendering/choosing-renderer/#method-3-performance-comparison","title":"Method 3: Performance Comparison","text":"<pre><code>using Brine2D.Rendering.Performance;\n\npublic class BenchmarkScene : Scene\n{\n    private readonly PerformanceOverlay _perfOverlay;\n    private int _spriteCount = 1000;\n\n    protected override void OnRender(GameTime gameTime)\n    {\n        // Draw many sprites\n        for (int i = 0; i &lt; _spriteCount; i++)\n        {\n            _renderer.DrawTexture(_texture, i % 1280, i / 1280 * 32);\n        }\n\n        // Show FPS\n        _perfOverlay.Render(gameTime);\n        _renderer.DrawText($\"Sprites: {_spriteCount}\", 10, 50, Color.White);\n    }\n\n    protected override void OnUpdate(GameTime gameTime)\n    {\n        // Increase sprite count to test performance\n        if (_input.IsKeyPressed(Keys.Up))\n            _spriteCount += 100;\n    }\n}</code></pre> <p>Test both renderers and compare FPS at different sprite counts.</p>"},{"location":"guides/rendering/choosing-renderer/#migration-guide","title":"Migration Guide","text":""},{"location":"guides/rendering/choosing-renderer/#from-legacy-to-gpu","title":"From Legacy to GPU","text":"<p>Step 1: Update configuration</p> <p>```json gamesettings.json {   \"Rendering\": {     \"Backend\": \"GPU\"  // Changed from \"LegacyRenderer\"   } } <pre><code>\n**Step 2:** Test your game\n\n- Run and verify graphics display correctly\n- Check console for GPU driver messages\n- Test window resizing\n- Verify textures load properly\n\n**Step 3:** Optimize for GPU\n\n```csharp\n// Group sprites by texture for better batching\n// Before: Mixed drawing\nforeach (var entity in allEntities)\n    _renderer.DrawTexture(entity.Texture, entity.X, entity.Y);\n\n// After: Batched by texture\nforeach (var enemy in enemies)\n    _renderer.DrawTexture(_enemyTexture, enemy.X, enemy.Y);\n\nforeach (var coin in coins)\n    _renderer.DrawTexture(_coinTexture, coin.X, coin.Y);</code></pre></p> <p>Step 4: Monitor performance</p> <pre><code>// Add performance overlay to verify improvement\nbuilder.Services.AddSingleton&lt;PerformanceOverlay&gt;();</code></pre>"},{"location":"guides/rendering/choosing-renderer/#from-gpu-to-legacy","title":"From GPU to Legacy","text":"<p>Step 1: Update configuration</p> <p>```json gamesettings.json {   \"Rendering\": {     \"Backend\": \"LegacyRenderer\"  // Changed from \"GPU\"   } } <pre><code>\n**Step 2:** Test compatibility\n\n- Run on target hardware\n- Verify acceptable performance\n- Check for rendering issues\n\n**Step 3:** Adjust expectations\n\n```csharp\n// Reduce sprite count if needed\nprivate const int MaxSprites = 1000;  // Instead of 10,000\n\n// Use sprite sheets more aggressively\n// Minimize texture switches</code></pre></p>"},{"location":"guides/rendering/choosing-renderer/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guides/rendering/choosing-renderer/#gpu-renderer-issues","title":"GPU Renderer Issues","text":"<p>Problem: Black screen on startup</p> <pre><code>[ERR] Failed to create GPU device</code></pre> <p>Solutions: 1. Update graphics drivers 2. Try different <code>PreferredGPUDriver</code>:    <pre><code>options.PreferredGPUDriver = \"D3D11\";  // Windows\n// or\noptions.PreferredGPUDriver = \"Vulkan\";</code></pre> 3. Fallback to Legacy renderer</p> <p>Problem: Poor performance with GPU renderer</p> <p>Possible causes: - Too many texture switches - Not batching sprites - Old GPU (pre-2015)</p> <p>Solutions: <pre><code>// Batch sprites by texture\n// Use sprite sheets\n// Or switch to Legacy renderer\noptions.Backend = GraphicsBackend.LegacyRenderer;</code></pre></p>"},{"location":"guides/rendering/choosing-renderer/#legacy-renderer-issues","title":"Legacy Renderer Issues","text":"<p>Problem: Low FPS with many sprites</p> <p>Solutions: 1. Switch to GPU renderer:    <pre><code>options.Backend = GraphicsBackend.GPU;</code></pre></p> <ol> <li> <p>Reduce sprite count:    <pre><code>// Cull off-screen sprites\nvar visibleSprites = sprites.Where(s =&gt; IsOnScreen(s));</code></pre></p> </li> <li> <p>Use sprite sheets:    <pre><code>// One texture for all sprites</code></pre></p> </li> </ol>"},{"location":"guides/rendering/choosing-renderer/#summary","title":"Summary","text":"Aspect GPU Renderer Legacy Renderer Recommendation Default choice Fallback/compatibility Best For Modern games, high sprite counts Simple games, old hardware Performance Excellent Good Compatibility Modern systems (2015+) Broader (2005+) Future Features Yes (shaders, etc.) No Setup <code>Backend = GraphicsBackend.GPU</code> <code>Backend = GraphicsBackend.LegacyRenderer</code> <p>Quick Recommendation: - New projects: Start with GPU renderer - Existing projects: Test GPU renderer, keep Legacy as fallback - Simple games: Either works - Complex games: GPU renderer strongly recommended</p>"},{"location":"guides/rendering/choosing-renderer/#next-steps","title":"Next Steps","text":"<ul> <li>GPU Renderer Guide - Deep dive into GPU renderer</li> <li>Sprites &amp; Textures - Load and draw sprites</li> <li>Performance Optimization - Maximize FPS</li> <li>What's New v0.7.0 - All v0.7.0 changes</li> </ul> <p>Ready to choose? Check out the GPU Renderer Guide or start with Sprites &amp; Textures!</p>"},{"location":"guides/rendering/gpu-renderer/","title":"SDL3 GPU Renderer","text":"<p>The SDL3 GPU renderer provides modern, shader-based rendering with automatic graphics API selection across platforms.</p>"},{"location":"guides/rendering/gpu-renderer/#overview","title":"Overview","text":"<p>SDL3GPURenderer is Brine2D's high-performance renderer using SDL3's GPU API. It supports Vulkan, Metal, DirectX 11, and DirectX 12 for hardware-accelerated 2D rendering.</p> <p>Key Features:</p> <ul> <li>Modern GPU APIs - Vulkan, Metal, D3D11, D3D12</li> <li>Shader-based rendering - Custom rendering pipeline</li> <li>High-performance batching - 10,000+ vertices per frame</li> <li>Cross-platform - Automatic API selection</li> <li>Future-proof - Foundation for advanced features</li> </ul> <pre><code>graph TB\n    APP[\"Your Game\"] --&gt; API[\"SDL3 GPU API\"]\n    API --&gt; VULKAN[\"Vulkan&lt;br/&gt;(Linux, Windows, Android)\"]\n    API --&gt; METAL[\"Metal&lt;br/&gt;(macOS, iOS)\"]\n    API --&gt; D3D11[\"Direct3D 11&lt;br/&gt;(Windows)\"]\n    API --&gt; D3D12[\"Direct3D 12&lt;br/&gt;(Windows)\"]\n\n    VULKAN --&gt; GPU[\"Graphics Card\"]\n    METAL --&gt; GPU\n    D3D11 --&gt; GPU\n    D3D12 --&gt; GPU\n\n    style APP fill:#1e3a5f,stroke:#569cd6,stroke-width:2px,color:#fff\n    style API fill:#2d5016,stroke:#4ec9b0,stroke-width:2px,color:#fff\n    style VULKAN fill:#4a2d4a,stroke:#c586c0,stroke-width:2px,color:#fff\n    style METAL fill:#4a2d4a,stroke:#c586c0,stroke-width:2px,color:#fff\n    style D3D11 fill:#4a2d4a,stroke:#c586c0,stroke-width:2px,color:#fff\n    style D3D12 fill:#4a2d4a,stroke:#c586c0,stroke-width:2px,color:#fff\n    style GPU fill:#4a3d1f,stroke:#ce9178,stroke-width:2px,color:#fff</code></pre>"},{"location":"guides/rendering/gpu-renderer/#prerequisites","title":"Prerequisites","text":"<ul> <li>SDL3 (included via NuGet)</li> <li>Graphics card with GPU API support:</li> <li>Vulkan 1.0+</li> <li>Metal (macOS 10.15+, iOS 13+)</li> <li>Direct3D 11 (Windows Vista+)</li> <li>Direct3D 12 (Windows 10+)</li> </ul>"},{"location":"guides/rendering/gpu-renderer/#quick-start","title":"Quick Start","text":""},{"location":"guides/rendering/gpu-renderer/#basic-setup","title":"Basic Setup","text":"<pre><code>using Brine2D.Hosting;\nusing Brine2D.Rendering.SDL;\n\nvar builder = GameApplication.CreateBuilder(args);\n\n// Configure GPU renderer (default in v0.7.0)\nbuilder.Services.AddSDL3Rendering(options =&gt;\n{\n    options.Backend = GraphicsBackend.GPU;  // Explicitly set GPU renderer\n    options.WindowWidth = 1280;\n    options.WindowHeight = 720;\n    options.WindowTitle = \"GPU Renderer Demo\";\n});\n\n// Register scenes\nbuilder.Services.AddScene&lt;GameScene&gt;();\n\nvar game = builder.Build();\nawait game.RunAsync&lt;GameScene&gt;();</code></pre>"},{"location":"guides/rendering/gpu-renderer/#configuration-file","title":"Configuration File","text":"<p>```json gamesettings.json {   \"Rendering\": {     \"Backend\": \"GPU\",     \"WindowTitle\": \"My Game\",     \"WindowWidth\": 1280,     \"WindowHeight\": 720,     \"VSync\": true,     \"Resizable\": true,     \"Fullscreen\": false,     \"PreferredGPUDriver\": null   } } <pre><code>\n```csharp\nbuilder.Services.AddSDL3Rendering(options =&gt;\n{\n    builder.Configuration.GetSection(\"Rendering\").Bind(options);\n});</code></pre></p>"},{"location":"guides/rendering/gpu-renderer/#gpu-vs-legacy-renderer","title":"GPU vs Legacy Renderer","text":""},{"location":"guides/rendering/gpu-renderer/#feature-comparison","title":"Feature Comparison","text":"Feature GPU Renderer Legacy Renderer Graphics API Vulkan/Metal/D3D11/D3D12 SDL_Renderer (varied) Rendering Shader-based Fixed-function Performance High (10k+ sprites) Moderate Batching Vertex batching Basic Texture switches Optimized Moderate overhead Platform support Modern systems Broader compatibility Future features Shaders, post-processing Limited"},{"location":"guides/rendering/gpu-renderer/#performance-comparison","title":"Performance Comparison","text":"<pre><code>Sprites Rendered (60 FPS target):\n\nLegacy Renderer:        GPU Renderer:\n1,000:  \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588    1,000:  \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 (same)\n5,000:  \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2591    5,000:  \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 (33% faster)\n10,000: \u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591    10,000: \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 (140% faster)\n        25 FPS                  60 FPS</code></pre> <p>GPU Renderer excels at: - Large sprite counts (1,000+) - Frequent texture switches - Particle systems - Dynamic scenes</p> <p>Legacy Renderer is better for: - Simple games (&lt;500 sprites) - Maximum compatibility - Older hardware</p>"},{"location":"guides/rendering/gpu-renderer/#gpu-api-selection","title":"GPU API Selection","text":""},{"location":"guides/rendering/gpu-renderer/#automatic-selection","title":"Automatic Selection","text":"<p>By default, SDL3 automatically selects the best GPU API for your platform:</p> Platform Default API Fallback Windows Direct3D 11 D3D12, Vulkan macOS Metal - iOS Metal - Linux Vulkan - Android Vulkan -"},{"location":"guides/rendering/gpu-renderer/#manual-selection","title":"Manual Selection","text":"<p>Override automatic selection with <code>PreferredGPUDriver</code>:</p> <pre><code>builder.Services.AddSDL3Rendering(options =&gt;\n{\n    options.Backend = GraphicsBackend.GPU;\n\n    // Force Vulkan (cross-platform)\n    options.PreferredGPUDriver = \"Vulkan\";\n\n    // Or force Direct3D 11 (Windows)\n    // options.PreferredGPUDriver = \"D3D11\";\n\n    // Or force Metal (macOS/iOS)\n    // options.PreferredGPUDriver = \"Metal\";\n\n    // Or auto-select (recommended)\n    // options.PreferredGPUDriver = null;\n});</code></pre> <p>Supported drivers: - <code>\"Vulkan\"</code> - Cross-platform (Windows, Linux, Android) - <code>\"Metal\"</code> - Apple platforms (macOS, iOS) - <code>\"D3D11\"</code> - Windows (Vista+) - <code>\"D3D12\"</code> - Windows (10+) - <code>null</code> - Auto-select (recommended)</p>"},{"location":"guides/rendering/gpu-renderer/#advanced-configuration","title":"Advanced Configuration","text":""},{"location":"guides/rendering/gpu-renderer/#performance-options","title":"Performance Options","text":"<pre><code>builder.Services.AddSDL3Rendering(options =&gt;\n{\n    options.Backend = GraphicsBackend.GPU;\n    options.VSync = true;  // Lock to display refresh rate\n    options.Resizable = true;  // Allow window resizing\n    options.Fullscreen = false;\n\n    // GPU-specific (optional)\n    options.PreferredGPUDriver = null;  // Auto-select\n});</code></pre>"},{"location":"guides/rendering/gpu-renderer/#window-events","title":"Window Events","text":"<p>The GPU renderer automatically handles window events:</p> <pre><code>using Brine2D.Core;\nusing Brine2D.SDL.Common.Events;\n\npublic class GameScene : Scene\n{\n    private readonly EventBus? _eventBus;\n\n    public GameScene(EventBus? eventBus, ILogger&lt;GameScene&gt; logger) : base(logger)\n    {\n        _eventBus = eventBus;\n    }\n\n    protected override void OnInitialize()\n    {\n        // Subscribe to window resize\n        _eventBus?.Subscribe&lt;WindowResizedEvent&gt;(OnWindowResized);\n    }\n\n    private void OnWindowResized(WindowResizedEvent evt)\n    {\n        Logger.LogInformation(\"Window resized to {Width}x{Height}\", \n            evt.Width, evt.Height);\n\n        // Viewport is automatically updated by renderer\n        // Update your UI layout, camera, etc.\n    }\n\n    protected override void OnDispose()\n    {\n        _eventBus?.Unsubscribe&lt;WindowResizedEvent&gt;(OnWindowResized);\n    }\n}</code></pre>"},{"location":"guides/rendering/gpu-renderer/#rendering-pipeline","title":"Rendering Pipeline","text":""},{"location":"guides/rendering/gpu-renderer/#how-gpu-rendering-works","title":"How GPU Rendering Works","text":"<pre><code>sequenceDiagram\n    participant Game\n    participant Renderer\n    participant Batch\n    participant GPU\n\n    Game-&gt;&gt;Renderer: BeginFrame()\n    Renderer-&gt;&gt;GPU: Acquire command buffer\n\n    loop For each draw call\n        Game-&gt;&gt;Renderer: DrawTexture()\n        Renderer-&gt;&gt;Batch: Add to vertex batch\n\n        alt Batch full or texture change\n            Batch-&gt;&gt;GPU: Upload vertices\n            Batch-&gt;&gt;GPU: Submit draw call\n            Batch-&gt;&gt;Batch: Clear\n        end\n    end\n\n    Game-&gt;&gt;Renderer: EndFrame()\n    Renderer-&gt;&gt;Batch: Flush remaining\n    Batch-&gt;&gt;GPU: Upload &amp; draw\n    Renderer-&gt;&gt;GPU: Present frame\n\n    box rgba(30, 58, 95, 0.3) Application Layer\n    participant Game\n    end\n\n    box rgba(45, 80, 22, 0.3) Rendering Layer\n    participant Renderer\n    end\n\n    box rgba(61, 61, 42, 0.3) Batching Layer\n    participant Batch\n    end\n\n    box rgba(74, 45, 74, 0.3) GPU Hardware\n    participant GPU\n    end</code></pre>"},{"location":"guides/rendering/gpu-renderer/#vertex-batching","title":"Vertex Batching","text":"<p>The GPU renderer batches draw calls for efficiency:</p> <pre><code>// Each of these is batched together (same texture)\nfor (int i = 0; i &lt; 1000; i++)\n{\n    _renderer.DrawTexture(_playerTexture, x, y);\n}\n// Single GPU draw call for all 1,000 sprites!\n\n// Different texture = new batch\n_renderer.DrawTexture(_enemyTexture, x, y);\n// Flushes previous batch, starts new one</code></pre> <p>Performance tip: Group sprites by texture to minimize batch breaks.</p>"},{"location":"guides/rendering/gpu-renderer/#texture-management","title":"Texture Management","text":""},{"location":"guides/rendering/gpu-renderer/#gpu-memory","title":"GPU Memory","text":"<p>Textures are stored in GPU memory (VRAM):</p> <pre><code>protected override async Task OnLoadAsync(CancellationToken ct)\n{\n    // Allocates GPU memory\n    _texture = await _textureLoader.LoadTextureAsync(\n        \"assets/player.png\",\n        TextureScaleMode.Nearest,\n        ct);\n\n    Logger.LogInformation(\"Texture in GPU memory: {Width}x{Height}\", \n        _texture.Width, _texture.Height);\n}\n\nprotected override Task OnUnloadAsync(CancellationToken ct)\n{\n    // IMPORTANT: Free GPU memory!\n    if (_texture != null)\n    {\n        _textureLoader.UnloadTexture(_texture);\n    }\n\n    return Task.CompletedTask;\n}</code></pre>"},{"location":"guides/rendering/gpu-renderer/#texture-formats","title":"Texture Formats","text":"<p>GPU renderer supports:</p> Format Alpha Compression Best For PNG Yes Lossless Sprites, UI JPG No Lossy Backgrounds BMP No None Development <p>All formats are converted to GPU-compatible format internally.</p>"},{"location":"guides/rendering/gpu-renderer/#performance-tips","title":"Performance Tips","text":""},{"location":"guides/rendering/gpu-renderer/#1-batch-sprites-by-texture","title":"1. Batch Sprites by Texture","text":"<pre><code>// \u2705 Good - batched together\nforeach (var enemy in _enemies)\n{\n    _renderer.DrawTexture(_enemyTexture, enemy.X, enemy.Y);\n}\n\nforeach (var coin in _coins)\n{\n    _renderer.DrawTexture(_coinTexture, coin.X, coin.Y);\n}\n\n// \u274c Bad - alternating textures breaks batching\nforeach (var entity in _allEntities)\n{\n    _renderer.DrawTexture(entity.Texture, entity.X, entity.Y);\n    // Many texture switches = many draw calls!\n}</code></pre>"},{"location":"guides/rendering/gpu-renderer/#2-use-sprite-sheets","title":"2. Use Sprite Sheets","text":"<pre><code>// \u2705 One texture, multiple sprites = single batch\n_renderer.DrawTexture(_spriteSheet, 0, 0, 32, 32, x, y, 32, 32);\n_renderer.DrawTexture(_spriteSheet, 32, 0, 32, 32, x2, y2, 32, 32);\n_renderer.DrawTexture(_spriteSheet, 64, 0, 32, 32, x3, y3, 32, 32);\n// All batched together!\n\n// \u274c Individual textures = multiple batches\n_renderer.DrawTexture(_sprite1, x, y);\n_renderer.DrawTexture(_sprite2, x2, y2);\n_renderer.DrawTexture(_sprite3, x3, y3);\n// Each might be a separate draw call</code></pre>"},{"location":"guides/rendering/gpu-renderer/#3-minimize-state-changes","title":"3. Minimize State Changes","text":"<pre><code>// State changes flush the current batch:\n// - Texture change\n// - Blend mode change (future feature)\n// - Shader change (future feature)\n\n// \u2705 Group by state\nDrawAllEnemies();    // Same texture\nDrawAllCoins();      // Same texture\nDrawAllBullets();    // Same texture\n\n// \u274c Interleaved drawing\nDrawEnemy();\nDrawCoin();\nDrawBullet();  // Constant texture switching!</code></pre>"},{"location":"guides/rendering/gpu-renderer/#4-preload-textures","title":"4. Preload Textures","text":"<pre><code>protected override async Task OnLoadAsync(CancellationToken ct)\n{\n    // Load all textures upfront\n    _playerTexture = await _textureLoader.LoadTextureAsync(\"assets/player.png\", TextureScaleMode.Nearest, ct);\n    _enemyTexture = await _textureLoader.LoadTextureAsync(\"assets/enemy.png\", TextureScaleMode.Nearest, ct);\n    _coinTexture = await _textureLoader.LoadTextureAsync(\"assets/coin.png\", TextureScaleMode.Nearest, ct);\n\n    // NOT during gameplay!\n}</code></pre>"},{"location":"guides/rendering/gpu-renderer/#debugging","title":"Debugging","text":""},{"location":"guides/rendering/gpu-renderer/#check-active-gpu-api","title":"Check Active GPU API","text":"<pre><code>public class GameScene : Scene\n{\n    private readonly IRenderer _renderer;\n\n    protected override void OnInitialize()\n    {\n        // Log renderer info\n        if (_renderer is SDL3GPURenderer gpuRenderer)\n        {\n            Logger.LogInformation(\"Using GPU renderer\");\n            // Driver name logged during initialization\n        }\n        else\n        {\n            Logger.LogInformation(\"Using Legacy renderer\");\n        }\n    }\n}</code></pre> <p>Check console output for:</p> <pre><code>[INF] GPU renderer initialized with driver: Vulkan</code></pre>"},{"location":"guides/rendering/gpu-renderer/#performance-monitoring","title":"Performance Monitoring","text":"<pre><code>using Brine2D.Rendering.Performance;\n\npublic class GameScene : Scene\n{\n    private readonly PerformanceOverlay _perfOverlay;\n\n    protected override void OnRender(GameTime gameTime)\n    {\n        _renderer.Clear(Color.Black);\n        _renderer.BeginFrame();\n\n        // Your rendering...\n\n        // Show performance stats\n        _perfOverlay.Render(gameTime);\n\n        _renderer.EndFrame();\n    }\n}</code></pre> <p>Monitor: - FPS (frames per second) - Frame time (ms per frame) - Sprite count - Draw calls (fewer = better)</p>"},{"location":"guides/rendering/gpu-renderer/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guides/rendering/gpu-renderer/#problem-black-screen","title":"Problem: Black Screen","text":"<p>Symptoms: - Window opens but displays nothing - No error messages</p> <p>Possible Causes:</p> <ol> <li>GPU driver not found <pre><code>// Check logs for:\n[ERR] Failed to create GPU device</code></pre></li> </ol> <p>Solution: Update graphics drivers or use Legacy renderer:    <pre><code>options.Backend = GraphicsBackend.LegacyRenderer;</code></pre></p> <ol> <li>Shaders failed to compile <pre><code>[ERR] Failed to load default shaders</code></pre></li> </ol> <p>Solution: Check GPU API support, update drivers</p> <ol> <li>Texture format issue <pre><code>[WARN] Failed to create texture</code></pre></li> </ol> <p>Solution: Use PNG format, check file exists</p>"},{"location":"guides/rendering/gpu-renderer/#problem-poor-performance","title":"Problem: Poor Performance","text":"<p>Symptoms: - Low FPS despite GPU renderer - Frame drops</p> <p>Solutions:</p> <ol> <li>Check draw calls <pre><code>// Add logging\nLogger.LogDebug(\"Drawing {Count} sprites\", spriteCount);</code></pre></li> </ol> <p>If many texture switches \u2192 use sprite sheets</p> <ol> <li> <p>VSync disabled <pre><code>{\n  \"Rendering\": {\n    \"VSync\": true  // Re-enable\n  }\n}</code></pre></p> </li> <li> <p>Too many vertices <pre><code>// Batch limit: 10,000 vertices per frame\n// Each sprite = 6 vertices (2 triangles)\n// Limit: ~1,666 sprites per batch</code></pre></p> </li> </ol> <p>Consider culling off-screen sprites</p>"},{"location":"guides/rendering/gpu-renderer/#problem-textures-not-loading","title":"Problem: Textures Not Loading","text":"<p>Symptoms: - <code>FileNotFoundException</code> - Textures appear as white/black rectangles</p> <p>Solutions:</p> <ol> <li> <p>Check file path <pre><code>// \u2705 Correct - relative path\n\"assets/player.png\"\n\n// \u274c Wrong - absolute path\n\"C:/Game/assets/player.png\"</code></pre></p> </li> <li> <p>Verify <code>.csproj</code> <pre><code>&lt;ItemGroup&gt;\n  &lt;None Update=\"assets\\**\\*\"&gt;\n    &lt;CopyToOutputDirectory&gt;PreserveNewest&lt;/CopyToOutputDirectory&gt;\n  &lt;/None&gt;\n&lt;/ItemGroup&gt;</code></pre></p> </li> <li> <p>Check format support</p> </li> <li>Use PNG (recommended)</li> <li>Avoid exotic formats</li> </ol>"},{"location":"guides/rendering/gpu-renderer/#problem-window-resize-issues","title":"Problem: Window Resize Issues","text":"<p>Symptoms: - Graphics stretched/distorted on resize - Black bars appear</p> <p>Solution:</p> <pre><code>using Brine2D.SDL.Common.Events;\n\nprotected override void OnInitialize()\n{\n    // Subscribe to resize events\n    _eventBus?.Subscribe&lt;WindowResizedEvent&gt;(OnWindowResized);\n}\n\nprivate void OnWindowResized(WindowResizedEvent evt)\n{\n    // Update camera viewport\n    if (_camera != null)\n    {\n        _camera.ViewportWidth = evt.Width;\n        _camera.ViewportHeight = evt.Height;\n    }\n\n    // Reposition UI\n    UpdateUILayout(evt.Width, evt.Height);\n}</code></pre>"},{"location":"guides/rendering/gpu-renderer/#platform-specific-notes","title":"Platform-Specific Notes","text":""},{"location":"guides/rendering/gpu-renderer/#windows","title":"Windows","text":"<p>Supported APIs: - Direct3D 11 (default, Vista+) - Direct3D 12 (Windows 10+) - Vulkan (if driver installed)</p> <p>Recommendations: - D3D11 for broadest compatibility - D3D12 for Windows 10+ optimization - Vulkan for cross-platform development</p>"},{"location":"guides/rendering/gpu-renderer/#macos-ios","title":"macOS / iOS","text":"<p>Supported API: - Metal (only option)</p> <p>Requirements: - macOS 10.15+ (Catalina) - iOS 13+</p> <p>Notes: - <code>PreferredGPUDriver</code> ignored (Metal always used) - Excellent performance on Apple hardware</p>"},{"location":"guides/rendering/gpu-renderer/#linux","title":"Linux","text":"<p>Supported API: - Vulkan (only option)</p> <p>Requirements: - Vulkan-capable GPU - Vulkan drivers installed</p> <p>Installation: <pre><code># Ubuntu/Debian\nsudo apt install vulkan-tools libvulkan1 mesa-vulkan-drivers\n\n# Fedora\nsudo dnf install vulkan-tools vulkan-loader mesa-vulkan-drivers\n\n# Arch\nsudo pacman -S vulkan-tools vulkan-icd-loader</code></pre></p>"},{"location":"guides/rendering/gpu-renderer/#android","title":"Android","text":"<p>Supported API: - Vulkan (Android 7.0+)</p> <p>Requirements: - Android 7.0+ (API 24) - Vulkan-capable device</p>"},{"location":"guides/rendering/gpu-renderer/#migration-from-legacy-renderer","title":"Migration from Legacy Renderer","text":""},{"location":"guides/rendering/gpu-renderer/#simple-migration","title":"Simple Migration","text":"<p>No code changes needed! Just update configuration:</p> <p>```json gamesettings.json {   \"Rendering\": {     \"Backend\": \"GPU\"  // Changed from \"LegacyRenderer\"   } } <pre><code>\n### Testing Checklist\n\n- [ ] Window opens correctly\n- [ ] Textures display properly\n- [ ] Sprites render at correct positions\n- [ ] Text rendering works\n- [ ] Primitives (rectangles, circles) draw correctly\n- [ ] Window resizing works\n- [ ] Performance is acceptable\n- [ ] No GPU driver errors in logs\n\n### Rollback Plan\n\nIf issues occur, revert to Legacy renderer:\n\n```json\n{\n  \"Rendering\": {\n    \"Backend\": \"LegacyRenderer\"\n  }\n}</code></pre></p>"},{"location":"guides/rendering/gpu-renderer/#future-features","title":"Future Features","text":"<p>The GPU renderer enables upcoming features:</p> <ul> <li>Custom shaders - User-defined rendering effects</li> <li>Post-processing - Screen-space effects</li> <li>Render-to-texture - Off-screen rendering</li> <li>Instanced rendering - Even faster batching</li> <li>Compute shaders - GPU-accelerated game logic</li> </ul>"},{"location":"guides/rendering/gpu-renderer/#best-practices","title":"Best Practices","text":""},{"location":"guides/rendering/gpu-renderer/#do","title":"DO","text":"<ol> <li> <p>Use GPU renderer by default <pre><code>options.Backend = GraphicsBackend.GPU;</code></pre></p> </li> <li> <p>Batch by texture <pre><code>DrawAllSprites(_texture1);\nDrawAllSprites(_texture2);</code></pre></p> </li> <li> <p>Use sprite sheets <pre><code>// One texture, many sprites</code></pre></p> </li> <li> <p>Unload textures <pre><code>protected override Task OnUnloadAsync(CancellationToken ct)\n{\n    _textureLoader.UnloadTexture(_texture);\n    return Task.CompletedTask;\n}</code></pre></p> </li> <li> <p>Handle window events <pre><code>_eventBus?.Subscribe&lt;WindowResizedEvent&gt;(OnResize);</code></pre></p> </li> </ol>"},{"location":"guides/rendering/gpu-renderer/#dont","title":"DON'T","text":"<ol> <li> <p>Don't mix renderers <pre><code>// \u274c Pick one backend\noptions.Backend = GraphicsBackend.GPU;  // Use this</code></pre></p> </li> <li> <p>Don't ignore GPU errors <pre><code>// Check logs for GPU initialization errors</code></pre></p> </li> <li> <p>Don't use Legacy renderer without reason <pre><code>// GPU renderer is faster for most games</code></pre></p> </li> <li> <p>Don't alternate textures unnecessarily <pre><code>// \u274c Breaks batching\nDrawSprite(_texture1);\nDrawSprite(_texture2);\nDrawSprite(_texture1);  // Texture switch!</code></pre></p> </li> </ol>"},{"location":"guides/rendering/gpu-renderer/#summary","title":"Summary","text":"Aspect Details Purpose High-performance, modern rendering APIs Vulkan, Metal, D3D11, D3D12 Performance 10,000+ sprites at 60 FPS Configuration <code>Backend = GraphicsBackend.GPU</code> Platform Windows, macOS, Linux, iOS, Android Best For Games with 1,000+ sprites, particles Compatibility Modern systems (2015+)"},{"location":"guides/rendering/gpu-renderer/#next-steps","title":"Next Steps","text":"<ul> <li>Sprites &amp; Textures - Load and draw sprites</li> <li>Primitives - Draw shapes</li> <li>Cameras - Viewport control</li> <li>Performance Optimization - Maximize FPS</li> </ul> <p>Ready for high-performance rendering? Start with Sprites &amp; Textures!</p>"},{"location":"guides/rendering/particles/","title":"Particle System","text":"<p>Create fire, explosions, smoke, and other visual effects with Brine2D's high-performance particle system featuring textures, rotation, trails, blend modes, and automatic object pooling.</p>"},{"location":"guides/rendering/particles/#overview","title":"Overview","text":"<p>Brine2D's particle system uses object pooling to render thousands of particles without allocating memory. Particles are reused from a pool, ensuring smooth performance even with complex effects.</p> <p>New in v0.8.0-beta: - Particle textures (custom sprite textures) - Rotation support (start, end, rotation speed) - Trail effects (motion trails behind particles) - Blend modes (additive, alpha, none) - 7 emitter shapes (point, circle, ring, box, cone, line, burst)</p> <pre><code>graph LR\n    A[ParticleEmitterComponent] --&gt; B[ObjectPool]\n    B --&gt; C[Particle Instance]\n    C --&gt; D[Update Position]\n    C --&gt; E[Update Color]\n    C --&gt; F[Update Size]\n    C --&gt; G[Update Rotation]\n    D --&gt; H{Expired?}\n    E --&gt; H\n    F --&gt; H\n    G --&gt; H\n    H --&gt;|Yes| I[Return to Pool]\n    H --&gt;|No| J[Render]\n    I --&gt; B</code></pre>"},{"location":"guides/rendering/particles/#quick-start","title":"Quick Start","text":""},{"location":"guides/rendering/particles/#basic-particle-emitter","title":"Basic Particle Emitter","text":"<p>Create a simple particle effect:</p> <pre><code>using Brine2D.ECS;\nusing Brine2D.ECS.Components;\nusing Brine2D.Rendering.ECS;\nusing System.Numerics;\n\npublic class GameScene : Scene\n{\n    private readonly IEntityWorld _world;\n\n    protected override void OnInitialize()\n    {\n        // Create entity with particle emitter\n        var fireEffect = _world.CreateEntity(\"Fire\");\n\n        var transform = fireEffect.AddComponent&lt;TransformComponent&gt;();\n        transform.Position = new Vector2(400, 300);\n\n        var emitter = fireEffect.AddComponent&lt;ParticleEmitterComponent&gt;();\n        emitter.IsEmitting = true;\n        emitter.EmissionRate = 50f; // 50 particles per second\n        emitter.MaxParticles = 200;\n        emitter.ParticleLifetime = 2f; // Seconds\n\n        // Appearance\n        emitter.StartColor = new Color(255, 200, 0, 255); // Bright yellow\n        emitter.EndColor = new Color(255, 50, 0, 0); // Dark red, transparent\n        emitter.StartSize = 8f;\n        emitter.EndSize = 2f;\n\n        // Physics\n        emitter.InitialVelocity = new Vector2(0, -50); // Upward\n        emitter.VelocitySpread = 30f; // Random angle variance\n        emitter.Gravity = new Vector2(0, 100); // Pull down\n    }\n}</code></pre> <p>That's it! The <code>ParticleSystem</code> will automatically update and render particles.</p>"},{"location":"guides/rendering/particles/#new-features-v080","title":"New Features (v0.8.0)","text":""},{"location":"guides/rendering/particles/#particle-textures","title":"Particle Textures","text":"<p>Use custom textures instead of solid circles:</p> <pre><code>var emitter = entity.AddComponent&lt;ParticleEmitterComponent&gt;();\n\n// Use a texture for particles\nemitter.TexturePath = \"assets/particles/fire.png\";\nemitter.TextureScaleMode = TextureScaleMode.Nearest; // For pixel art\n\n// Texture combines with color tint\nemitter.StartColor = new Color(255, 255, 255, 255); // White = no tint\nemitter.EndColor = new Color(255, 100, 0, 0); // Orange fade</code></pre> <p>Best Practices: - Keep textures small (16x16 to 64x64 pixels) - Use semi-transparent textures for blending - White textures work best for color tinting - Use texture atlasing for multiple particle types</p>"},{"location":"guides/rendering/particles/#rotation","title":"Rotation","text":"<p>Rotate particles over their lifetime:</p> <pre><code>var emitter = entity.AddComponent&lt;ParticleEmitterComponent&gt;();\n\n// Rotation angles (in radians)\nemitter.StartRotation = 0f; // Starting angle\nemitter.EndRotation = MathF.PI * 2; // End angle (full rotation)\n\n// OR use rotation speed (overrides lerp)\nemitter.RotationSpeed = 2f; // Radians per second (constant spin)\n\n// Random rotation variance\nemitter.RotationSpread = MathF.PI / 4; // \u00b145 degrees initial rotation</code></pre> <p>Rotation Modes:</p> <pre><code>// Lerp rotation (smooth start \u2192 end)\nemitter.StartRotation = 0f;\nemitter.EndRotation = MathF.PI; // 180 degree rotation over lifetime\nemitter.RotationSpeed = 0f; // Disabled\n\n// Constant spin\nemitter.StartRotation = 0f;\nemitter.RotationSpeed = 3f; // Spin at 3 rad/s regardless of lifetime\n\n// Random initial rotation\nemitter.StartRotation = 0f;\nemitter.RotationSpread = MathF.PI; // Random \u00b1180 degrees\nemitter.RotationSpeed = 1f; // All spin at same speed</code></pre>"},{"location":"guides/rendering/particles/#trail-effects","title":"Trail Effects","text":"<p>Add motion trails behind particles:</p> <pre><code>var emitter = entity.AddComponent&lt;ParticleEmitterComponent&gt;();\n\n// Enable trails\nemitter.TrailEnabled = true;\nemitter.TrailLength = 10; // Number of trail segments\nemitter.TrailColor = new Color(255, 100, 0, 128); // Semi-transparent orange\n\n// Trail particles inherit main particle properties\n// but fade based on trail position</code></pre> <p>Trail Configuration:</p> <pre><code>// Short, faint trails (subtle)\nemitter.TrailEnabled = true;\nemitter.TrailLength = 5;\nemitter.TrailColor = new Color(255, 255, 255, 50); // Very transparent\n\n// Long, visible trails (dramatic)\nemitter.TrailEnabled = true;\nemitter.TrailLength = 15;\nemitter.TrailColor = new Color(255, 100, 0, 200); // More opaque\n\n// Colored trails (different from particle)\nemitter.StartColor = Color.White; // White particles\nemitter.TrailColor = new Color(100, 150, 255, 150); // Blue trails</code></pre>"},{"location":"guides/rendering/particles/#blend-modes","title":"Blend Modes","text":"<p>Control how particles blend with the background:</p> <pre><code>var emitter = entity.AddComponent&lt;ParticleEmitterComponent&gt;();\n\n// Additive blending (fire, explosions, energy)\nemitter.BlendMode = BlendMode.Additive;\n\n// Alpha blending (smoke, fog, default)\nemitter.BlendMode = BlendMode.AlphaBlend;\n\n// No blending (solid particles)\nemitter.BlendMode = BlendMode.None;</code></pre> <p>Blend Mode Effects:</p> Blend Mode Visual Effect Best For <code>Additive</code> Bright, glowing overlaps Fire, explosions, energy, magic <code>AlphaBlend</code> Standard transparency Smoke, fog, water, dust <code>None</code> Solid, opaque Solid objects, debris, sparks"},{"location":"guides/rendering/particles/#emitter-shapes","title":"Emitter Shapes","text":"<p>Choose from 7 emitter shapes for different spawn patterns:</p> <pre><code>var emitter = entity.AddComponent&lt;ParticleEmitterComponent&gt;();\n\n// Point emitter (single point)\nemitter.EmitterShape = EmitterShape.Point;\n\n// Circle emitter (spawn anywhere in circle)\nemitter.EmitterShape = EmitterShape.Circle;\nemitter.SpawnRadius = 20f;\n\n// Ring emitter (spawn on circle edge)\nemitter.EmitterShape = EmitterShape.Ring;\nemitter.SpawnRadius = 30f;\n\n// Box emitter (rectangular spawn area)\nemitter.EmitterShape = EmitterShape.Box;\nemitter.SpawnRadius = 50f; // Half-width/height\n\n// Cone emitter (directional spray)\nemitter.EmitterShape = EmitterShape.Cone;\nemitter.ConeAngle = MathF.PI / 4; // 45 degree cone\n\n// Line emitter (spawn along line)\nemitter.EmitterShape = EmitterShape.Line;\nemitter.LineLength = 100f;\n\n// Burst emitter (radial explosion)\nemitter.EmitterShape = EmitterShape.Burst;\nemitter.BurstCount = 50; // Particles per burst</code></pre>"},{"location":"guides/rendering/particles/#particle-properties","title":"Particle Properties","text":""},{"location":"guides/rendering/particles/#emission-properties","title":"Emission Properties","text":"<p>Control how particles are spawned:</p> <pre><code>var emitter = entity.AddComponent&lt;ParticleEmitterComponent&gt;();\n\n// Basic emission\nemitter.IsEmitting = true; // Toggle emission on/off\nemitter.EmissionRate = 50f; // Particles per second\nemitter.MaxParticles = 200; // Pool size (max concurrent particles)\nemitter.ParticleLifetime = 2f; // How long each particle lives (seconds)\n\n// Emitter shape\nemitter.EmitterShape = EmitterShape.Circle;\nemitter.SpawnRadius = 10f; // Shape-specific size</code></pre>"},{"location":"guides/rendering/particles/#visual-properties","title":"Visual Properties","text":"<p>Control particle appearance:</p> <pre><code>// Color interpolation (start \u2192 end over lifetime)\nemitter.StartColor = new Color(255, 200, 0, 255); // Bright yellow, opaque\nemitter.EndColor = new Color(255, 50, 0, 0); // Dark red, transparent\n\n// Size interpolation (start \u2192 end over lifetime)\nemitter.StartSize = 8f; // pixels\nemitter.EndSize = 2f; // Shrink over time\n\n// Texture (new in v0.8.0)\nemitter.TexturePath = \"assets/particles/spark.png\";\nemitter.TextureScaleMode = TextureScaleMode.Linear;\n\n// Rotation (new in v0.8.0)\nemitter.StartRotation = 0f;\nemitter.EndRotation = MathF.PI * 2;\nemitter.RotationSpeed = 2f;\nemitter.RotationSpread = MathF.PI / 4;\n\n// Trails (new in v0.8.0)\nemitter.TrailEnabled = true;\nemitter.TrailLength = 10;\nemitter.TrailColor = new Color(255, 100, 0, 128);\n\n// Blend mode (new in v0.8.0)\nemitter.BlendMode = BlendMode.Additive;</code></pre>"},{"location":"guides/rendering/particles/#physics-properties","title":"Physics Properties","text":"<p>Control particle movement:</p> <pre><code>// Initial velocity (pixels per second)\nemitter.InitialVelocity = new Vector2(0, -100); // Upward\n\n// Velocity spread (random angle variance in degrees)\nemitter.VelocitySpread = 45f; // \u00b145\u00b0 cone\n\n// Gravity (acceleration, pixels per second\u00b2)\nemitter.Gravity = new Vector2(0, 200); // Pull down\n\n// No gravity (floating particles)\nemitter.Gravity = Vector2.Zero;</code></pre>"},{"location":"guides/rendering/particles/#preset-effects","title":"Preset Effects","text":""},{"location":"guides/rendering/particles/#fire-effect-enhanced","title":"Fire Effect (Enhanced)","text":"<pre><code>var fireEmitter = entity.AddComponent&lt;ParticleEmitterComponent&gt;();\n\n// Emission\nfireEmitter.IsEmitting = true;\nfireEmitter.EmissionRate = 100f;\nfireEmitter.MaxParticles = 200;\nfireEmitter.ParticleLifetime = 1.5f;\nfireEmitter.EmitterShape = EmitterShape.Circle;\nfireEmitter.SpawnRadius = 15f;\n\n// Appearance\nfireEmitter.TexturePath = \"assets/particles/fire.png\"; // \u2190 NEW\nfireEmitter.BlendMode = BlendMode.Additive; // \u2190 NEW\nfireEmitter.StartColor = new Color(255, 200, 0, 255);\nfireEmitter.EndColor = new Color(255, 50, 0, 0);\nfireEmitter.StartSize = 8f;\nfireEmitter.EndSize = 2f;\n\n// Rotation (NEW)\nfireEmitter.StartRotation = 0f;\nfireEmitter.RotationSpeed = 2f;\nfireEmitter.RotationSpread = MathF.PI / 2;\n\n// Trails (NEW)\nfireEmitter.TrailEnabled = true;\nfireEmitter.TrailLength = 5;\nfireEmitter.TrailColor = new Color(255, 100, 0, 100);\n\n// Physics\nfireEmitter.InitialVelocity = new Vector2(0, -100);\nfireEmitter.VelocitySpread = 30f;\nfireEmitter.Gravity = new Vector2(0, -20);</code></pre>"},{"location":"guides/rendering/particles/#explosion-effect-enhanced","title":"Explosion Effect (Enhanced)","text":"<pre><code>var explosionEmitter = entity.AddComponent&lt;ParticleEmitterComponent&gt;();\n\n// Emission (burst)\nexplosionEmitter.EmitterShape = EmitterShape.Burst; // \u2190 NEW\nexplosionEmitter.BurstCount = 100; // \u2190 NEW\nexplosionEmitter.IsEmitting = false;\nexplosionEmitter.MaxParticles = 100;\nexplosionEmitter.ParticleLifetime = 1f;\n\n// Appearance\nexplosionEmitter.TexturePath = \"assets/particles/explosion.png\"; // \u2190 NEW\nexplosionEmitter.BlendMode = BlendMode.Additive; // \u2190 NEW\nexplosionEmitter.StartColor = new Color(255, 255, 255, 255);\nexplosionEmitter.EndColor = new Color(255, 100, 0, 0);\nexplosionEmitter.StartSize = 12f;\nexplosionEmitter.EndSize = 2f;\n\n// Rotation (NEW)\nexplosionEmitter.StartRotation = 0f;\nexplosionEmitter.RotationSpeed = 5f;\n\n// Physics\nexplosionEmitter.InitialVelocity = new Vector2(0, -200);\nexplosionEmitter.VelocitySpread = 180f;\nexplosionEmitter.Gravity = new Vector2(0, 500);\n\n// Trigger explosion\nexplosionEmitter.EmitBurst(100);</code></pre>"},{"location":"guides/rendering/particles/#smoke-effect-enhanced","title":"Smoke Effect (Enhanced)","text":"<pre><code>var smokeEmitter = entity.AddComponent&lt;ParticleEmitterComponent&gt;();\n\n// Emission\nsmokeEmitter.IsEmitting = true;\nsmokeEmitter.EmissionRate = 20f;\nsmokeEmitter.MaxParticles = 100;\nsmokeEmitter.ParticleLifetime = 3f;\nsmokeEmitter.EmitterShape = EmitterShape.Circle; // \u2190 NEW\nsmokeEmitter.SpawnRadius = 5f;\n\n// Appearance\nsmokeEmitter.TexturePath = \"assets/particles/smoke.png\"; // \u2190 NEW\nsmokeEmitter.BlendMode = BlendMode.AlphaBlend; // \u2190 NEW\nsmokeEmitter.StartColor = new Color(60, 60, 60, 200);\nsmokeEmitter.EndColor = new Color(150, 150, 150, 0);\nsmokeEmitter.StartSize = 4f;\nsmokeEmitter.EndSize = 12f;\n\n// Rotation (NEW)\nsmokeEmitter.StartRotation = 0f;\nsmokeEmitter.RotationSpeed = 0.5f;\nsmokeEmitter.RotationSpread = MathF.PI;\n\n// Physics\nsmokeEmitter.InitialVelocity = new Vector2(0, -30);\nsmokeEmitter.VelocitySpread = 20f;\nsmokeEmitter.Gravity = new Vector2(0, -10);</code></pre>"},{"location":"guides/rendering/particles/#magic-spell-effect-new","title":"Magic Spell Effect (NEW)","text":"<pre><code>var spellEmitter = entity.AddComponent&lt;ParticleEmitterComponent&gt;();\n\n// Emission\nspellEmitter.EmitterShape = EmitterShape.Ring; // \u2190 Ring shape\nspellEmitter.SpawnRadius = 40f;\nspellEmitter.IsEmitting = true;\nspellEmitter.EmissionRate = 60f;\nspellEmitter.MaxParticles = 200;\nspellEmitter.ParticleLifetime = 2f;\n\n// Appearance\nspellEmitter.TexturePath = \"assets/particles/magic.png\";\nspellEmitter.BlendMode = BlendMode.Additive; // Glowing effect\nspellEmitter.StartColor = new Color(150, 100, 255, 255); // Purple\nspellEmitter.EndColor = new Color(150, 100, 255, 0);\nspellEmitter.StartSize = 6f;\nspellEmitter.EndSize = 1f;\n\n// Rotation\nspellEmitter.StartRotation = 0f;\nspellEmitter.RotationSpeed = 3f;\n\n// Trails\nspellEmitter.TrailEnabled = true;\nspellEmitter.TrailLength = 8;\nspellEmitter.TrailColor = new Color(150, 100, 255, 100);\n\n// Physics (spiral inward)\nspellEmitter.InitialVelocity = new Vector2(-50, 0);\nspellEmitter.VelocitySpread = 10f;\nspellEmitter.Gravity = Vector2.Zero;</code></pre>"},{"location":"guides/rendering/particles/#projectile-trail-new","title":"Projectile Trail (NEW)","text":"<pre><code>// Attach to moving projectile\nvar trailEmitter = projectile.AddComponent&lt;ParticleEmitterComponent&gt;();\n\n// Emission\ntrailEmitter.EmitterShape = EmitterShape.Point;\ntrailEmitter.IsEmitting = true;\ntrailEmitter.EmissionRate = 100f;\ntrailEmitter.MaxParticles = 200;\ntrailEmitter.ParticleLifetime = 0.5f;\n\n// Appearance\ntrailEmitter.TexturePath = \"assets/particles/spark.png\";\ntrailEmitter.BlendMode = BlendMode.Additive;\ntrailEmitter.StartColor = new Color(100, 200, 255, 255);\ntrailEmitter.EndColor = new Color(100, 200, 255, 0);\ntrailEmitter.StartSize = 6f;\ntrailEmitter.EndSize = 1f;\n\n// Rotation\ntrailEmitter.RotationSpeed = 10f;\n\n// Trails (trail of a trail!)\ntrailEmitter.TrailEnabled = true;\ntrailEmitter.TrailLength = 5;\ntrailEmitter.TrailColor = new Color(100, 200, 255, 80);\n\n// Physics (no velocity, stay where spawned)\ntrailEmitter.InitialVelocity = Vector2.Zero;\ntrailEmitter.Gravity = Vector2.Zero;</code></pre>"},{"location":"guides/rendering/particles/#fountain-effect-new","title":"Fountain Effect (NEW)","text":"<pre><code>var fountainEmitter = entity.AddComponent&lt;ParticleEmitterComponent&gt;();\n\n// Emission\nfountainEmitter.EmitterShape = EmitterShape.Cone; // \u2190 Cone shape\nfountainEmitter.ConeAngle = MathF.PI / 6; // 30 degree cone\nfountainEmitter.IsEmitting = true;\nfountainEmitter.EmissionRate = 80f;\nfountainEmitter.MaxParticles = 300;\nfountainEmitter.ParticleLifetime = 2.5f;\n\n// Appearance\nfountainEmitter.TexturePath = \"assets/particles/water.png\";\nfountainEmitter.BlendMode = BlendMode.AlphaBlend;\nfountainEmitter.StartColor = new Color(100, 150, 255, 200);\nfountainEmitter.EndColor = new Color(100, 150, 255, 0);\nfountainEmitter.StartSize = 4f;\nfountainEmitter.EndSize = 2f;\n\n// Physics (upward spray)\nfountainEmitter.InitialVelocity = new Vector2(0, -300);\nfountainEmitter.VelocitySpread = 15f;\nfountainEmitter.Gravity = new Vector2(0, 500); // Strong gravity</code></pre>"},{"location":"guides/rendering/particles/#advanced-techniques","title":"Advanced Techniques","text":""},{"location":"guides/rendering/particles/#layered-particles","title":"Layered Particles","text":"<p>Combine multiple emitters for complex effects:</p> <pre><code>public void CreateExplosion(Vector2 position)\n{\n    var explosionEntity = _world.CreateEntity(\"Explosion\");\n    var transform = explosionEntity.AddComponent&lt;TransformComponent&gt;();\n    transform.Position = position;\n\n    // Layer 1: Bright flash\n    var flashEmitter = explosionEntity.AddComponent&lt;ParticleEmitterComponent&gt;();\n    flashEmitter.EmitterShape = EmitterShape.Burst;\n    flashEmitter.BurstCount = 20;\n    flashEmitter.TexturePath = \"assets/particles/flash.png\";\n    flashEmitter.BlendMode = BlendMode.Additive;\n    flashEmitter.StartColor = Color.White;\n    flashEmitter.EndColor = new Color(255, 255, 255, 0);\n    flashEmitter.ParticleLifetime = 0.2f;\n    flashEmitter.StartSize = 20f;\n    flashEmitter.EndSize = 40f;\n\n    // Layer 2: Fire burst\n    var fireEmitter = CreateChildEmitter(explosionEntity);\n    fireEmitter.EmitterShape = EmitterShape.Burst;\n    fireEmitter.BurstCount = 50;\n    fireEmitter.BlendMode = BlendMode.Additive;\n    fireEmitter.StartColor = new Color(255, 200, 0, 255);\n    fireEmitter.EndColor = new Color(255, 50, 0, 0);\n    fireEmitter.ParticleLifetime = 1f;\n    fireEmitter.InitialVelocity = new Vector2(0, -200);\n    fireEmitter.VelocitySpread = 180f;\n\n    // Layer 3: Smoke aftermath\n    var smokeEmitter = CreateChildEmitter(explosionEntity);\n    smokeEmitter.EmissionRate = 30f;\n    smokeEmitter.BlendMode = BlendMode.AlphaBlend;\n    smokeEmitter.StartColor = new Color(60, 60, 60, 200);\n    smokeEmitter.EndColor = new Color(120, 120, 120, 0);\n    smokeEmitter.ParticleLifetime = 3f;\n    smokeEmitter.StartSize = 4f;\n    smokeEmitter.EndSize = 20f;\n\n    // Trigger effects\n    flashEmitter.EmitBurst(20);\n    fireEmitter.EmitBurst(50);\n}</code></pre>"},{"location":"guides/rendering/particles/#dynamic-emitter-movement","title":"Dynamic Emitter Movement","text":"<p>Create moving particle sources:</p> <pre><code>public class MovingEmitterSystem : IUpdateSystem\n{\n    public void Update(GameTime gameTime)\n    {\n        var emitters = _world.GetEntitiesWithComponent&lt;ParticleEmitterComponent&gt;();\n\n        foreach (var entity in emitters)\n        {\n            var transform = entity.GetComponent&lt;TransformComponent&gt;();\n            var emitter = entity.GetComponent&lt;ParticleEmitterComponent&gt;();\n\n            // Move in a circle\n            var time = (float)gameTime.TotalTime * 2f;\n            transform.Position = new Vector2(\n                640 + MathF.Cos(time) * 200,\n                360 + MathF.Sin(time) * 200\n            );\n        }\n    }\n}</code></pre>"},{"location":"guides/rendering/particles/#conditional-emission","title":"Conditional Emission","text":"<p>Control emission based on game state:</p> <pre><code>public class ConditionalParticleSystem : IUpdateSystem\n{\n    public void Update(GameTime gameTime)\n    {\n        var player = GetPlayer();\n        var emitter = player.GetComponent&lt;ParticleEmitterComponent&gt;();\n        var velocity = player.GetComponent&lt;VelocityComponent&gt;();\n\n        // Only emit when moving fast\n        var speed = velocity.Velocity.Length();\n        emitter.IsEmitting = speed &gt; 100f;\n\n        // Adjust emission rate based on speed\n        emitter.EmissionRate = speed * 0.5f; // More particles = faster movement\n    }\n}</code></pre>"},{"location":"guides/rendering/particles/#performance","title":"Performance","text":""},{"location":"guides/rendering/particles/#object-pooling","title":"Object Pooling","text":"<p>Particles use object pooling automatically - no GC allocations!</p> <pre><code>// Under the hood (automatic):\npublic class ParticleEmitterComponent\n{\n    private readonly ObjectPool&lt;Particle&gt; _pool;\n\n    private void EmitParticle()\n    {\n        var particle = _pool.Get(); // \u2705 Reuse from pool\n        // Configure particle...\n    }\n\n    private void KillParticle(Particle particle)\n    {\n        _pool.Return(particle); // \u2705 Return to pool\n    }\n}</code></pre>"},{"location":"guides/rendering/particles/#performance-tips","title":"Performance Tips","text":"<pre><code>// \u2705 GOOD: Reasonable particle counts\nemitter.MaxParticles = 200; // ~200 particles = negligible cost\n\n// \u26a0\ufe0f ACCEPTABLE: Many particles\nemitter.MaxParticles = 1000; // ~1000 particles = minor cost\n\n// \u274c BAD: Too many particles\nemitter.MaxParticles = 10000; // &gt; 10k particles = significant cost\n\n// \u2705 SOLUTION: Use multiple smaller emitters\nfor (int i = 0; i &lt; 10; i++)\n{\n    var smallEmitter = CreateEmitter();\n    smallEmitter.MaxParticles = 100; // 10 x 100 = 1000 total\n}</code></pre> <p>Performance Guidelines: - &lt; 500 particles per emitter - Excellent performance - 500-1000 particles - Good performance - &gt; 1000 particles - Consider splitting into multiple emitters - Textures - Use texture atlasing for multiple particle types - Trails - Trails multiply particle count (10 trail length = 10x particles) - Blend modes - Additive blending has similar cost to alpha blending</p>"},{"location":"guides/rendering/particles/#texture-optimization","title":"Texture Optimization","text":"<pre><code>// \u2705 GOOD: Pack particle textures into atlas\nvar atlas = await AtlasBuilder.BuildAtlasAsync(\n    _renderer,\n    _textureLoader,\n    new[] {\n        \"assets/particles/fire.png\",\n        \"assets/particles/smoke.png\",\n        \"assets/particles/spark.png\"\n    },\n    padding: 2,\n    maxSize: 1024\n);\n\n// Use atlas regions\nemitter.TexturePath = \"assets/particles/fire.png\"; // Automatically uses atlas</code></pre>"},{"location":"guides/rendering/particles/#monitoring","title":"Monitoring","text":""},{"location":"guides/rendering/particles/#check-particle-count","title":"Check Particle Count","text":"<pre><code>var emitter = entity.GetComponent&lt;ParticleEmitterComponent&gt;();\n\nLogger.LogDebug($\"Active particles: {emitter.ParticleCount}/{emitter.MaxParticles}\");\n\nif (emitter.ParticleCount &gt;= emitter.MaxParticles)\n{\n    Logger.LogWarning(\"Particle pool exhausted! Increase MaxParticles.\");\n}</code></pre>"},{"location":"guides/rendering/particles/#performance-stats","title":"Performance Stats","text":"<pre><code>// Enable performance monitoring\nbuilder.Services.AddPerformanceMonitoring(options =&gt;\n{\n    options.EnableOverlay = true;\n});\n\n// Press F3 in-game to toggle detailed stats\n// Look for:\n// - \"Sprites\" count (includes particles)\n// - \"Draw Calls\" (should batch with atlasing)\n// - Frame time (&lt; 16.67ms for 60 FPS)</code></pre>"},{"location":"guides/rendering/particles/#best-practices","title":"Best Practices","text":""},{"location":"guides/rendering/particles/#do","title":"Do","text":"<ul> <li>Use texture atlasing - Pack all particle textures together</li> <li>Set reasonable MaxParticles - Start with 200, adjust as needed</li> <li>Use additive blending for bright effects - Fire, explosions, energy</li> <li>Use alpha blending for soft effects - Smoke, fog, water</li> <li>Enable trails sparingly - They multiply particle count</li> <li>Test on target hardware - Performance varies by device</li> </ul>"},{"location":"guides/rendering/particles/#dont","title":"Don't","text":"<ul> <li>Don't use massive textures - Keep particles 16x16 to 64x64</li> <li>Don't create too many emitters - Prefer fewer, larger emitters</li> <li>Don't enable trails on all particles - Use selectively</li> <li>Don't forget to set BlendMode - Defaults to AlphaBlend</li> <li>Don't use None blend mode with transparency - Use Alpha or Additive</li> </ul>"},{"location":"guides/rendering/particles/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guides/rendering/particles/#particles-not-visible","title":"Particles Not Visible","text":"<p>Problem: Emitter is active but no particles appear.</p> <p>Solutions:</p> <pre><code>// 1. Check emission is enabled\nemitter.IsEmitting = true;\n\n// 2. Verify EmissionRate is reasonable\nemitter.EmissionRate = 50f; // Not 0!\n\n// 3. Check ParticleLifetime\nemitter.ParticleLifetime = 2f; // Not too short\n\n// 4. Verify colors have opacity\nemitter.StartColor = new Color(255, 255, 255, 255); // Alpha = 255\n\n// 5. Check blend mode\nemitter.BlendMode = BlendMode.AlphaBlend; // Or Additive</code></pre>"},{"location":"guides/rendering/particles/#textures-not-loading","title":"Textures Not Loading","text":"<p>Problem: Particles show as solid circles instead of texture.</p> <p>Solution:</p> <pre><code>// Verify texture path is correct\nif (!File.Exists(\"assets/particles/fire.png\"))\n{\n    Logger.LogError(\"Particle texture not found!\");\n}\n\n// Check texture loaded successfully\nemitter.TexturePath = \"assets/particles/fire.png\";\n\n// Fallback: If no texture, particles render as circles (expected)</code></pre>"},{"location":"guides/rendering/particles/#poor-performance","title":"Poor Performance","text":"<p>Problem: Frame rate drops with particles active.</p> <p>Solutions:</p> <pre><code>// 1. Reduce MaxParticles\nemitter.MaxParticles = 200; // Instead of 2000\n\n// 2. Reduce trail length\nemitter.TrailLength = 5; // Instead of 20\n\n// 3. Use texture atlasing\n// Pack all particle textures into one atlas\n\n// 4. Disable distant emitters\nif (distance &gt; 1000f)\n{\n    emitter.IsEmitting = false;\n}\n\n// 5. Check particle count\nLogger.LogInfo($\"Total particles: {GetTotalParticleCount()}\");</code></pre>"},{"location":"guides/rendering/particles/#trails-look-wrong","title":"Trails Look Wrong","text":"<p>Problem: Trails appear disconnected or too faint.</p> <p>Solutions:</p> <pre><code>// 1. Increase trail opacity\nemitter.TrailColor = new Color(255, 100, 0, 200); // More opaque\n\n// 2. Increase trail length\nemitter.TrailLength = 10; // More segments\n\n// 3. Match trail color to particle\nemitter.StartColor = new Color(255, 100, 0, 255);\nemitter.TrailColor = new Color(255, 100, 0, 150);\n\n// 4. Increase emission rate for continuous trails\nemitter.EmissionRate = 100f; // More particles = smoother trails</code></pre>"},{"location":"guides/rendering/particles/#see-also","title":"See Also","text":"<ul> <li>Texture Atlasing - Pack particle textures for better performance</li> <li>Sprites &amp; Textures - Learn about texture loading</li> <li>ECS Systems - ParticleSystem implementation details</li> <li>Performance Optimization - General optimization techniques</li> </ul> <p>Next Steps: - Experiment with different emitter shapes - Try combining blend modes - Create layered particle effects - Add particle textures with atlasing - Use trails for motion effects</p>"},{"location":"guides/rendering/primitives/","title":"Drawing Primitives","text":"<p>Master the fundamentals of rendering in Brine2D by learning to draw shapes, lines, colors, and primitives.</p>"},{"location":"guides/rendering/primitives/#overview","title":"Overview","text":"<p>Brine2D's rendering system provides simple, immediate-mode drawing APIs for 2D graphics: - \u2705 Rectangles - Filled and outlined rectangles - \u2705 Circles - Filled and outlined circles - \u2705 Lines - Lines with configurable thickness - \u2705 Text - String rendering with fonts - \u2705 Textures - Images and sprites (covered in Sprites)</p> <pre><code>sequenceDiagram\n    participant Scene as Your Scene\n    participant Renderer as IRenderer\n    participant SDL as SDL3\n\n    Note over Scene: Every Frame\n\n    Scene-&gt;&gt;Renderer: DrawRectangleFilled(...)\n    Renderer-&gt;&gt;SDL: SDL_RenderFillRect\n\n    Scene-&gt;&gt;Renderer: DrawLine(...)\n    Renderer-&gt;&gt;SDL: SDL_RenderLine\n\n    Scene-&gt;&gt;Renderer: DrawCircleFilled(...)\n    Renderer-&gt;&gt;SDL: Draw circle algorithm\n\n    Scene-&gt;&gt;Renderer: DrawText(...)\n    Renderer-&gt;&gt;SDL: SDL_TTF render\n\n    Note over Renderer,SDL: Frame management automatic!</code></pre>"},{"location":"guides/rendering/primitives/#prerequisites","title":"Prerequisites","text":"<ul> <li>\u2705 Quick Start - Basic scene setup</li> <li>\u2705 Basic C# knowledge</li> </ul>"},{"location":"guides/rendering/primitives/#automatic-frame-management","title":"Automatic Frame Management","text":"<p>In Brine2D, frame management happens automatically! You don't need to call <code>Clear()</code>, <code>BeginFrame()</code>, or <code>EndFrame()</code>:</p> <pre><code>public class DrawingScene : Scene\n{\n    protected override void OnRender(GameTime gameTime)\n    {\n        // Just draw! Frame management is automatic\n        _renderer.DrawRectangleFilled(100, 100, 200, 150, Color.Red);\n        _renderer.DrawCircleFilled(400, 300, 50, Color.Blue);\n        _renderer.DrawLine(100, 100, 300, 200, Color.Yellow, 2f);\n    }\n}</code></pre> <p>Manual Control Available</p> <p>Need manual control? Set <code>EnableAutomaticFrameManagement = false</code> in your scene. See Lifecycle Hooks.</p>"},{"location":"guides/rendering/primitives/#drawing-rectangles","title":"Drawing Rectangles","text":""},{"location":"guides/rendering/primitives/#filled-rectangle","title":"Filled Rectangle","text":"<pre><code>// DrawRectangleFilled(x, y, width, height, color)\n_renderer.DrawRectangleFilled(100, 100, 50, 50, Color.Red);</code></pre> <p>Parameters: - <code>x</code> - Left edge position - <code>y</code> - Top edge position - <code>width</code> - Rectangle width - <code>height</code> - Rectangle height - <code>color</code> - Fill color</p> <pre><code>Screen Coordinates:\n(0,0) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba X\n  \u2502\n  \u2502    (100,100)\n  \u2502      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n  \u2502      \u2502 50x50 px \u2502\n  \u2502      \u2502  rect    \u2502\n  \u2502      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n  \u25bc\n  Y</code></pre>"},{"location":"guides/rendering/primitives/#rectangle-outline","title":"Rectangle Outline","text":"<pre><code>// DrawRectangleOutline(x, y, width, height, color, thickness)\n_renderer.DrawRectangleOutline(100, 100, 200, 150, Color.White, 2f);</code></pre> <p>Thickness parameter: - Default: <code>1.0f</code> (1 pixel) - Larger values = thicker lines</p>"},{"location":"guides/rendering/primitives/#drawing-circles","title":"Drawing Circles","text":""},{"location":"guides/rendering/primitives/#filled-circle","title":"Filled Circle","text":"<pre><code>// DrawCircleFilled(centerX, centerY, radius, color)\n_renderer.DrawCircleFilled(400, 300, 50, Color.Blue);</code></pre>"},{"location":"guides/rendering/primitives/#circle-outline","title":"Circle Outline","text":"<pre><code>// DrawCircleOutline(centerX, centerY, radius, color, thickness)\n_renderer.DrawCircleOutline(400, 300, 50, Color.White, 2f);</code></pre>"},{"location":"guides/rendering/primitives/#drawing-lines","title":"Drawing Lines","text":"<p>Draw lines between two points with configurable thickness:</p>"},{"location":"guides/rendering/primitives/#basic-line","title":"Basic Line","text":"<pre><code>// DrawLine(x1, y1, x2, y2, color, thickness)\n_renderer.DrawLine(100, 100, 300, 200, Color.Yellow, 1f);</code></pre> <p>Parameters: - <code>x1, y1</code> - Start point - <code>x2, y2</code> - End point - <code>color</code> - Line color - <code>thickness</code> - Line thickness (default: 1.0f)</p>"},{"location":"guides/rendering/primitives/#thick-lines","title":"Thick Lines","text":"<pre><code>// Thin line\n_renderer.DrawLine(100, 100, 300, 100, Color.Red, 1f);\n\n// Medium line\n_renderer.DrawLine(100, 150, 300, 150, Color.Green, 3f);\n\n// Thick line\n_renderer.DrawLine(100, 200, 300, 200, Color.Blue, 5f);\n\n// Very thick line\n_renderer.DrawLine(100, 250, 300, 250, Color.Yellow, 10f);</code></pre>"},{"location":"guides/rendering/primitives/#line-patterns","title":"Line Patterns","text":"<p>Draw a cross:</p> <pre><code>var centerX = 640f;\nvar centerY = 360f;\nvar size = 50f;\n\n_renderer.DrawLine(centerX - size, centerY, centerX + size, centerY, Color.White, 2f);\n_renderer.DrawLine(centerX, centerY - size, centerX, centerY + size, Color.White, 2f);</code></pre> <p>Draw a box with lines:</p> <pre><code>float x = 100, y = 100, w = 200, h = 150;\n\n_renderer.DrawLine(x, y, x + w, y, Color.White, 2f);         // Top\n_renderer.DrawLine(x + w, y, x + w, y + h, Color.White, 2f); // Right\n_renderer.DrawLine(x + w, y + h, x, y + h, Color.White, 2f); // Bottom\n_renderer.DrawLine(x, y + h, x, y, Color.White, 2f);         // Left</code></pre> <p>Velocity vectors (from collision demo):</p> <pre><code>private void DrawVelocityVector(Vector2 position, Vector2 velocity, Color color)\n{\n    var end = position + velocity * 0.1f;\n    _renderer.DrawLine(position.X, position.Y, end.X, end.Y, color, 2f);\n\n    // Arrow head\n    var direction = Vector2.Normalize(velocity);\n    var perpendicular = new Vector2(-direction.Y, direction.X);\n\n    var arrowPoint1 = end - direction * 10f + perpendicular * 5f;\n    var arrowPoint2 = end - direction * 10f - perpendicular * 5f;\n\n    _renderer.DrawLine(end.X, end.Y, arrowPoint1.X, arrowPoint1.Y, color, 2f);\n    _renderer.DrawLine(end.X, end.Y, arrowPoint2.X, arrowPoint2.Y, color, 2f);\n}</code></pre> <p>Grid with lines:</p> <pre><code>private void DrawLineGrid(int gridSize, Color gridColor)\n{\n    // Vertical lines\n    for (int x = 0; x &lt;= 1280; x += gridSize)\n    {\n        _renderer.DrawLine(x, 0, x, 720, gridColor, 1f);\n    }\n\n    // Horizontal lines\n    for (int y = 0; y &lt;= 720; y += gridSize)\n    {\n        _renderer.DrawLine(0, y, 1280, y, gridColor, 1f);\n    }\n}</code></pre>"},{"location":"guides/rendering/primitives/#working-with-colors","title":"Working with Colors","text":""},{"location":"guides/rendering/primitives/#predefined-colors","title":"Predefined Colors","text":"<pre><code>Color.White           // (255, 255, 255)\nColor.Black           // (0, 0, 0)\nColor.Red             // (255, 0, 0)\nColor.Green           // (0, 255, 0)\nColor.Blue            // (0, 0, 255)\nColor.Cyan            // (0, 255, 255)\nColor.Yellow          // (255, 255, 0)\nColor.Gray            // (128, 128, 128)\nColor.CornflowerBlue  // (100, 149, 237)\nColor.Transparent     // (0, 0, 0, 0)</code></pre>"},{"location":"guides/rendering/primitives/#custom-colors","title":"Custom Colors","text":"<p>RGB Color</p> <pre><code>var purple = new Color(128, 0, 128);</code></pre> <p>RGBA Color (with transparency)</p> <pre><code>var semiTransparentRed = new Color(255, 0, 0, 128); // 50% transparent</code></pre> <p>Helper Methods</p> <pre><code>var color1 = Color.FromRgb(100, 150, 200);\nvar color2 = Color.FromRgba(100, 150, 200, 128);</code></pre>"},{"location":"guides/rendering/primitives/#drawing-text","title":"Drawing Text","text":""},{"location":"guides/rendering/primitives/#basic-text","title":"Basic Text","text":"<pre><code>_renderer.DrawText(\"Hello, World!\", 100, 100, Color.White);</code></pre> <p>Note: Brine2D includes an embedded font that loads automatically!</p>"},{"location":"guides/rendering/primitives/#complete-drawing-example","title":"Complete Drawing Example","text":"<p>Here's a scene with all drawing primitives:</p> <pre><code>using Brine2D.Core;\nusing Brine2D.Input;\nusing Brine2D.Rendering;\nusing Microsoft.Extensions.Logging;\n\npublic class PrimitivesDemo : Scene\n{\n    private readonly IRenderer _renderer;\n    private readonly IInputService _input;\n    private readonly IGameContext _gameContext;\n\n    private float _pulse = 0f;\n\n    public PrimitivesDemo(\n        IRenderer renderer,\n        IInputService input,\n        IGameContext gameContext,\n        ILogger&lt;PrimitivesDemo&gt; logger\n    ) : base(logger)\n    {\n        _renderer = renderer;\n        _input = input;\n        _gameContext = gameContext;\n    }\n\n    protected override void OnUpdate(GameTime gameTime)\n    {\n        if (_input.IsKeyPressed(Keys.Escape))\n        {\n            _gameContext.RequestExit();\n        }\n\n        _pulse += (float)gameTime.DeltaTime * 2f;\n    }\n\n    protected override void OnRender(GameTime gameTime)\n    {\n        // Frame management automatic! Just draw\n\n        // Grid background\n        DrawGrid();\n\n        // Filled rectangles\n        _renderer.DrawRectangleFilled(100, 100, 100, 100, Color.Red);\n        _renderer.DrawRectangleFilled(250, 100, 150, 80, Color.Green);\n\n        // Rectangle outlines\n        _renderer.DrawRectangleOutline(100, 250, 100, 100, Color.Yellow, 3f);\n        _renderer.DrawRectangleOutline(250, 250, 150, 80, Color.Cyan, 2f);\n\n        // Filled circles\n        _renderer.DrawCircleFilled(600, 150, 50, Color.Red);\n        _renderer.DrawCircleFilled(750, 150, 30, Color.Green);\n\n        // Circle outlines\n        _renderer.DrawCircleOutline(600, 300, 50, Color.Yellow, 3f);\n        _renderer.DrawCircleOutline(750, 300, 30, Color.Cyan, 2f);\n\n        // Lines with different thickness\n        _renderer.DrawLine(100, 400, 300, 400, Color.White, 1f);\n        _renderer.DrawLine(100, 430, 300, 430, Color.White, 3f);\n        _renderer.DrawLine(100, 470, 300, 470, Color.White, 5f);\n\n        // Cross pattern\n        DrawCross(500, 450, 50, Color.Yellow, 3f);\n\n        // Pulsing square\n        DrawPulsingSquare();\n\n        // Text\n        _renderer.DrawText(\"Primitives Demo\", 10, 10, Color.White);\n        _renderer.DrawText($\"FPS: {(int)(1.0 / gameTime.DeltaTime)}\", 10, 30, Color.Yellow);\n    }\n\n    private void DrawGrid()\n    {\n        var gridSize = 50;\n        var gridColor = new Color(60, 60, 60);\n\n        for (int x = 0; x &lt;= 1280; x += gridSize)\n        {\n            _renderer.DrawLine(x, 0, x, 720, gridColor, 1f);\n        }\n\n        for (int y = 0; y &lt;= 720; y += gridSize)\n        {\n            _renderer.DrawLine(0, y, 1280, y, gridColor, 1f);\n        }\n    }\n\n    private void DrawCross(float centerX, float centerY, float size, Color color, float thickness)\n    {\n        _renderer.DrawLine(centerX - size, centerY, centerX + size, centerY, color, thickness);\n        _renderer.DrawLine(centerX, centerY - size, centerX, centerY + size, color, thickness);\n    }\n\n    private void DrawPulsingSquare()\n    {\n        var scale = 1.0f + MathF.Sin(_pulse) * 0.3f;\n        var size = 80 * scale;\n        var centerX = 900f;\n        var centerY = 500f;\n\n        var intensity = (byte)(128 + MathF.Sin(_pulse * 2) * 127);\n        var color = new Color(intensity, 0, intensity);\n\n        _renderer.DrawRectangleFilled(\n            centerX - size / 2,\n            centerY - size / 2,\n            size,\n            size,\n            color);\n    }\n}</code></pre>"},{"location":"guides/rendering/primitives/#see-it-in-action","title":"See It In Action","text":"<p>Check out the Collision Demo in FeatureDemos to see <code>DrawLine</code> used for velocity vectors!</p> <pre><code>cd samples/FeatureDemos\ndotnet run\n# Select \"Collision Detection\" from the menu\n# Press F2 to toggle velocity vectors</code></pre>"},{"location":"guides/rendering/primitives/#api-reference","title":"API Reference","text":""},{"location":"guides/rendering/primitives/#rectangles","title":"Rectangles","text":"<pre><code>DrawRectangleFilled(float x, float y, float width, float height, Color color)\nDrawRectangleOutline(float x, float y, float width, float height, Color color, float thickness = 1f)</code></pre>"},{"location":"guides/rendering/primitives/#circles","title":"Circles","text":"<pre><code>DrawCircleFilled(float centerX, float centerY, float radius, Color color)\nDrawCircleOutline(float centerX, float centerY, float radius, Color color, float thickness = 1f)</code></pre>"},{"location":"guides/rendering/primitives/#lines","title":"Lines","text":"<pre><code>DrawLine(float x1, float y1, float x2, float y2, Color color, float thickness = 1f)</code></pre>"},{"location":"guides/rendering/primitives/#text","title":"Text","text":"<pre><code>DrawText(string text, float x, float y, Color color)</code></pre>"},{"location":"guides/rendering/primitives/#best-practices","title":"Best Practices","text":""},{"location":"guides/rendering/primitives/#do","title":"DO","text":"<p>\u2705 Let the framework manage frames</p> <pre><code>protected override void OnRender(GameTime gameTime)\n{\n    // Just draw!\n    _renderer.DrawRectangleFilled(...);\n}</code></pre> <p>\u2705 Use constants for repeated values</p> <pre><code>private const float PLAYER_SIZE = 50f;\n_renderer.DrawRectangleFilled(x, y, PLAYER_SIZE, PLAYER_SIZE, Color.Red);</code></pre> <p>\u2705 Cache colors</p> <pre><code>private static readonly Color PlayerColor = new Color(100, 200, 255);</code></pre>"},{"location":"guides/rendering/primitives/#dont","title":"DON'T","text":"<p>\u274c Don't create colors every frame</p> <pre><code>// Bad\n_renderer.DrawRectangleFilled(x, y, 100, 100, new Color(255, 0, 0));\n\n// Good\nprivate static readonly Color Red = Color.Red;\n_renderer.DrawRectangleFilled(x, y, 100, 100, Red);</code></pre> <p>\u274c Don't draw off-screen objects</p> <pre><code>if (IsVisible(entity))\n{\n    DrawEntity(entity);\n}</code></pre>"},{"location":"guides/rendering/primitives/#next-steps","title":"Next Steps","text":"<ul> <li> <p>Sprites</p> <p>Load and draw images</p> <p> Sprites Guide</p> </li> <li> <p>Cameras</p> <p>Move the viewport</p> <p> Camera Guide</p> </li> <li> <p>FeatureDemos</p> <p>See primitives in action</p> <p> View Demos</p> </li> </ul> <p>Remember: Frame management is automatic - just draw!</p>"},{"location":"guides/rendering/sprites/","title":"Sprites &amp; Textures","text":"<p>Learn how to load images, draw sprites, work with sprite sheets, and create animations for your 2D games.</p>"},{"location":"guides/rendering/sprites/#overview","title":"Overview","text":"<p>Textures are images loaded into memory for rendering. Sprites are textures (or portions of textures) displayed in your game.</p> <p>What you'll learn:</p> <ul> <li>\u2705 Loading textures from image files</li> <li>\u2705 Drawing sprites at any position/size</li> <li>\u2705 Sprite sheets for efficient texture atlases</li> <li>\u2705 Scale modes for pixel art vs smooth graphics</li> <li>\u2705 Memory management (loading/unloading)</li> </ul> <pre><code>graph LR\n    A[\"Image File&lt;br/&gt;(PNG, JPG, BMP)\"] --&gt; B[\"ITextureLoader\"]\n    B --&gt; C[\"ITexture&lt;br/&gt;(GPU Memory)\"]\n    C --&gt; D[\"IRenderer\"]\n    D --&gt; E[\"Screen\"]\n\n    F[\"Sprite Sheet&lt;br/&gt;(Multiple Sprites)\"] --&gt; B</code></pre>"},{"location":"guides/rendering/sprites/#prerequisites","title":"Prerequisites","text":"<ul> <li>\u2705 Drawing Basics - Understanding rendering</li> <li>\u2705 Quick Start - Scene setup</li> <li>Image files (PNG, JPG, or BMP)</li> </ul>"},{"location":"guides/rendering/sprites/#quick-example","title":"Quick Example","text":""},{"location":"guides/rendering/sprites/#load-and-draw-a-sprite","title":"Load and Draw a Sprite","text":"<pre><code>using Brine2D.Core;\nusing Brine2D.Rendering;\nusing Microsoft.Extensions.Logging;\n\npublic class SpriteScene : Scene\n{\n    private readonly IRenderer _renderer;\n    private readonly ITextureLoader _textureLoader;\n\n    private ITexture? _playerTexture;\n\n    public SpriteScene(\n        IRenderer renderer,\n        ITextureLoader textureLoader,\n        ILogger&lt;SpriteScene&gt; logger\n    ) : base(logger)\n    {\n        _renderer = renderer;\n        _textureLoader = textureLoader;\n    }\n\n    protected override async Task OnLoadAsync(CancellationToken cancellationToken)\n    {\n        // Load texture asynchronously\n        _playerTexture = await _textureLoader.LoadTextureAsync(\n            \"assets/player.png\",\n            TextureScaleMode.Nearest, // For pixel art\n            cancellationToken);\n    }\n\n    protected override void OnRender(GameTime gameTime)\n    {\n        _renderer.Clear(Color.Black);\n        _renderer.BeginFrame();\n\n        if (_playerTexture != null)\n        {\n            // Draw at position (100, 100)\n            _renderer.DrawTexture(_playerTexture, 100, 100);\n        }\n\n        _renderer.EndFrame();\n    }\n\n    protected override Task OnUnloadAsync(CancellationToken cancellationToken)\n    {\n        // Important: Always unload textures!\n        if (_playerTexture != null)\n        {\n            _textureLoader.UnloadTexture(_playerTexture);\n        }\n\n        return Task.CompletedTask;\n    }\n}</code></pre> <p>Result: Your sprite appears on screen!</p>"},{"location":"guides/rendering/sprites/#project-structure","title":"Project Structure","text":"<p>Organize your assets:</p> <pre><code>YourGame/\n\u251c\u2500\u2500 Program.cs\n\u251c\u2500\u2500 GameScene.cs\n\u251c\u2500\u2500 YourGame.csproj\n\u251c\u2500\u2500 gamesettings.json\n\u2514\u2500\u2500 assets/\n    \u251c\u2500\u2500 sprites/\n    \u2502   \u251c\u2500\u2500 player.png\n    \u2502   \u251c\u2500\u2500 enemy.png\n    \u2502   \u2514\u2500\u2500 character_sheet.png (sprite sheet)\n    \u251c\u2500\u2500 backgrounds/\n    \u2502   \u2514\u2500\u2500 background.png\n    \u2514\u2500\u2500 ui/\n        \u2514\u2500\u2500 button.png</code></pre> <p>In <code>.csproj</code>, copy assets to output:</p> <p>```xml YourGame.csproj  PreserveNewest <pre><code>\n---\n\n## Loading Textures\n\n### Async Loading (Recommended)\n\n```csharp\nprotected override async Task OnLoadAsync(CancellationToken cancellationToken)\n{\n    // Load texture asynchronously\n    _texture = await _textureLoader.LoadTextureAsync(\n        \"assets/player.png\",\n        TextureScaleMode.Nearest,\n        cancellationToken);\n\n    Logger.LogInformation(\"Texture loaded: {Width}x{Height}\", \n        _texture.Width, _texture.Height);\n}</code></pre></p> <p>Parameters: - <code>path</code> - Relative path to image file - <code>scaleMode</code> - <code>Nearest</code> (pixel art) or <code>Linear</code> (smooth) - <code>cancellationToken</code> - For cancellation support</p>"},{"location":"guides/rendering/sprites/#synchronous-loading","title":"Synchronous Loading","text":"<pre><code>protected override void OnInitialize()\n{\n    // Load synchronously (blocks thread)\n    _texture = _textureLoader.LoadTexture(\n        \"assets/player.png\",\n        TextureScaleMode.Nearest);\n}</code></pre> <p>\u26a0\ufe0f Warning: Blocks the thread. Use async loading when possible!</p>"},{"location":"guides/rendering/sprites/#scale-modes","title":"Scale Modes","text":"Mode Best For Effect <code>TextureScaleMode.Nearest</code> Pixel art, retro games Sharp, pixelated scaling <code>TextureScaleMode.Linear</code> Photos, smooth graphics Smooth, blurred scaling <p>Visual Comparison:</p> <pre><code>Nearest (Pixel Art):        Linear (Smooth):\n\u250c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2510                \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 \u2588\u2588 \u2502 \u2588\u2588 \u2502                \u2502\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2502\n\u251c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2524  Scaled \u2192      \u2502\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2502\n\u2502 \u2588\u2588 \u2502 \u2588\u2588 \u2502   2x           \u2502\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2502\n\u2514\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2518                \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n Sharp edges!               Blended edges!</code></pre> <p>Choose: - Nearest - Pixel art, 8-bit style, sharp edges - Linear - Realistic graphics, photos, smooth scaling</p>"},{"location":"guides/rendering/sprites/#supported-formats","title":"Supported Formats","text":"<p>Brine2D supports common image formats via SDL3_image: - \u2705 PNG (recommended, alpha support) - \u2705 JPG/JPEG (no alpha, smaller files) - \u2705 BMP (uncompressed, large files)</p> <p>File size tips: - PNG - Best for sprites (lossless + transparency) - JPG - Best for backgrounds (smaller, no alpha)</p>"},{"location":"guides/rendering/sprites/#drawing-textures","title":"Drawing Textures","text":""},{"location":"guides/rendering/sprites/#method-1-draw-at-position","title":"Method 1: Draw at Position","text":"<pre><code>// Draw at (x, y) with original size\n_renderer.DrawTexture(_texture, 100, 100);</code></pre> <p>Result: Texture drawn at position, original dimensions.</p>"},{"location":"guides/rendering/sprites/#method-2-draw-with-scaling","title":"Method 2: Draw with Scaling","text":"<pre><code>// Draw at (x, y) with custom width/height\n_renderer.DrawTexture(_texture, 100, 100, 200, 200);</code></pre> <p>Parameters: - <code>x, y</code> - Position - <code>width, height</code> - Destination size</p> <p>Example:</p> <pre><code>// Double size\n_renderer.DrawTexture(_texture, 100, 100, \n    _texture.Width * 2, _texture.Height * 2);\n\n// Half size\n_renderer.DrawTexture(_texture, 100, 100, \n    _texture.Width / 2, _texture.Height / 2);</code></pre>"},{"location":"guides/rendering/sprites/#method-3-sprite-sheet-partial-draw","title":"Method 3: Sprite Sheet (Partial Draw)","text":"<pre><code>// Draw a portion of texture (for sprite sheets)\n_renderer.DrawTexture(\n    _texture,\n    sourceX, sourceY, sourceWidth, sourceHeight, // Source rectangle in texture\n    destX, destY, destWidth, destHeight);        // Destination on screen</code></pre> <p>Use for: - Sprite sheets/texture atlases - Animation frames - UI elements</p> <p>Example:</p> <pre><code>// Draw top-left 32x32 region from sprite sheet\n_renderer.DrawTexture(\n    _spriteSheet,\n    0, 0, 32, 32,      // Source: top-left 32x32 pixels\n    100, 100, 64, 64); // Draw at (100,100) scaled to 64x64</code></pre>"},{"location":"guides/rendering/sprites/#sprite-sheets","title":"Sprite Sheets","text":"<p>A sprite sheet (texture atlas) combines multiple sprites into one image for efficiency.</p>"},{"location":"guides/rendering/sprites/#what-is-a-sprite-sheet","title":"What is a Sprite Sheet?","text":"<pre><code>character_sheet.png (256x256):\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Frame 1\u2502 Frame 2\u2502 Frame 3\u2502 Frame 4\u2502  \u2190 Walk animation\n\u2502  32x32 \u2502  32x32 \u2502  32x32 \u2502  32x32 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Frame 5\u2502 Frame 6\u2502 Frame 7\u2502 Frame 8\u2502  \u2190 Run animation\n\u2502  32x32 \u2502  32x32 \u2502  32x32 \u2502  32x32 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n8 sprites in 1 texture!</code></pre> <p>Benefits: - \u2705 Fewer draw calls (faster rendering) - \u2705 Less memory (one texture vs many) - \u2705 Easier management (one file)</p>"},{"location":"guides/rendering/sprites/#drawing-from-sprite-sheet","title":"Drawing from Sprite Sheet","text":"<pre><code>public class SpriteSheetScene : Scene\n{\n    private readonly IRenderer _renderer;\n    private readonly ITextureLoader _textureLoader;\n\n    private ITexture? _spriteSheet;\n    private int _currentFrame = 0;\n\n    // Sprite sheet info\n    private const int FrameWidth = 32;\n    private const int FrameHeight = 32;\n    private const int FramesPerRow = 8;\n\n    protected override async Task OnLoadAsync(CancellationToken cancellationToken)\n    {\n        _spriteSheet = await _textureLoader.LoadTextureAsync(\n            \"assets/character_sheet.png\",\n            TextureScaleMode.Nearest,\n            cancellationToken);\n    }\n\n    protected override void OnRender(GameTime gameTime)\n    {\n        _renderer.Clear(Color.Black);\n        _renderer.BeginFrame();\n\n        if (_spriteSheet != null)\n        {\n            // Calculate source rectangle for current frame\n            int frameX = (_currentFrame % FramesPerRow) * FrameWidth;\n            int frameY = (_currentFrame / FramesPerRow) * FrameHeight;\n\n            // Draw frame scaled 4x\n            _renderer.DrawTexture(\n                _spriteSheet,\n                frameX, frameY, FrameWidth, FrameHeight,    // Source\n                100, 100, FrameWidth * 4, FrameHeight * 4); // Dest (4x scale)\n        }\n\n        _renderer.EndFrame();\n    }\n\n    protected override void OnUpdate(GameTime gameTime)\n    {\n        // Cycle through frames (simple animation)\n        _currentFrame = (_currentFrame + 1) % (FramesPerRow * 2); // 16 frames total\n    }\n}</code></pre>"},{"location":"guides/rendering/sprites/#complete-sprite-example","title":"Complete Sprite Example","text":"<p>Here's a full scene with player movement:</p> <pre><code>using Brine2D.Core;\nusing Brine2D.Input;\nusing Brine2D.Rendering;\nusing Microsoft.Extensions.Logging;\nusing System.Numerics;\n\npublic class PlayerSpriteScene : Scene\n{\n    private readonly IRenderer _renderer;\n    private readonly IInputService _input;\n    private readonly ITextureLoader _textureLoader;\n    private readonly IGameContext _gameContext;\n\n    private ITexture? _playerTexture;\n    private Vector2 _playerPosition = new Vector2(400, 300);\n    private float _playerSpeed = 200f;\n\n    public PlayerSpriteScene(\n        IRenderer renderer,\n        IInputService input,\n        ITextureLoader textureLoader,\n        IGameContext gameContext,\n        ILogger&lt;PlayerSpriteScene&gt; logger\n    ) : base(logger)\n    {\n        _renderer = renderer;\n        _input = input;\n        _textureLoader = textureLoader;\n        _gameContext = gameContext;\n    }\n\n    // ============================================\n    // LOAD\n    // ============================================\n    protected override async Task OnLoadAsync(CancellationToken cancellationToken)\n    {\n        Logger.LogInformation(\"Loading player sprite...\");\n\n        _playerTexture = await _textureLoader.LoadTextureAsync(\n            \"assets/player.png\",\n            TextureScaleMode.Nearest,\n            cancellationToken);\n\n        Logger.LogInformation(\"Player sprite loaded: {Width}x{Height}\",\n            _playerTexture.Width, _playerTexture.Height);\n    }\n\n    // ============================================\n    // UPDATE\n    // ============================================\n    protected override void OnUpdate(GameTime gameTime)\n    {\n        var deltaTime = (float)gameTime.DeltaTime;\n\n        // Exit\n        if (_input.IsKeyPressed(Keys.Escape))\n        {\n            _gameContext.RequestExit();\n        }\n\n        // Movement\n        var movement = Vector2.Zero;\n\n        if (_input.IsKeyDown(Keys.W)) movement.Y -= 1;\n        if (_input.IsKeyDown(Keys.S)) movement.Y += 1;\n        if (_input.IsKeyDown(Keys.A)) movement.X -= 1;\n        if (_input.IsKeyDown(Keys.D)) movement.X += 1;\n\n        if (movement != Vector2.Zero)\n        {\n            movement = Vector2.Normalize(movement);\n            _playerPosition += movement * _playerSpeed * deltaTime;\n\n            // Keep on screen\n            _playerPosition.X = Math.Clamp(_playerPosition.X, 0, 1280);\n            _playerPosition.Y = Math.Clamp(_playerPosition.Y, 0, 720);\n        }\n    }\n\n    // ============================================\n    // RENDER\n    // ============================================\n    protected override void OnRender(GameTime gameTime)\n    {\n        _renderer.Clear(new Color(40, 40, 40));\n        _renderer.BeginFrame();\n\n        if (_playerTexture != null)\n        {\n            // Center sprite on position\n            var drawX = _playerPosition.X - _playerTexture.Width / 2;\n            var drawY = _playerPosition.Y - _playerTexture.Height / 2;\n\n            _renderer.DrawTexture(_playerTexture, drawX, drawY);\n        }\n\n        // Draw instructions\n        _renderer.DrawText(\"WASD to move\", 10, 10, Color.White);\n        _renderer.DrawText(\"ESC to exit\", 10, 30, Color.White);\n\n        _renderer.EndFrame();\n    }\n\n    // ============================================\n    // CLEANUP\n    // ============================================\n    protected override Task OnUnloadAsync(CancellationToken cancellationToken)\n    {\n        // IMPORTANT: Always unload!\n        if (_playerTexture != null)\n        {\n            _textureLoader.UnloadTexture(_playerTexture);\n            Logger.LogInformation(\"Player sprite unloaded\");\n        }\n\n        return Task.CompletedTask;\n    }\n}</code></pre>"},{"location":"guides/rendering/sprites/#sprite-animations","title":"Sprite Animations","text":"<p>For frame-by-frame animations, see Animation Guide.</p> <p>Quick preview:</p> <pre><code>// Load sprite sheet\n_spriteSheet = await _textureLoader.LoadTextureAsync(\n    \"assets/character.png\",\n    TextureScaleMode.Nearest,\n    cancellationToken);\n\n// Create animator\n_animator = new SpriteAnimator();\n\n// Create animation from sprite sheet\nvar walkAnim = AnimationClip.FromSpriteSheet(\n    \"walk\",           // Name\n    32,               // Frame width\n    32,               // Frame height\n    4,                // Frame count\n    8,                // Columns\n    0.1f,             // Duration per frame\n    true);            // Loop?\n\n_animator.AddAnimation(walkAnim);\n_animator.Play(\"walk\");\n\n// Update every frame\n_animator.Update(deltaTime);\n\n// Draw current frame\nif (_animator.CurrentFrame != null)\n{\n    var frame = _animator.CurrentFrame.SourceRect;\n    _renderer.DrawTexture(\n        _spriteSheet,\n        frame.X, frame.Y, frame.Width, frame.Height,\n        playerX, playerY, 64, 64);\n}</code></pre> <p>Full Animation Tutorial \u2192</p>"},{"location":"guides/rendering/sprites/#memory-management","title":"Memory Management","text":""},{"location":"guides/rendering/sprites/#textures-use-gpu-memory","title":"Textures Use GPU Memory!","text":"<p>ALWAYS unload textures when done:</p> <pre><code>protected override Task OnUnloadAsync(CancellationToken cancellationToken)\n{\n    if (_playerTexture != null)\n    {\n        _textureLoader.UnloadTexture(_playerTexture);\n    }\n\n    if (_backgroundTexture != null)\n    {\n        _textureLoader.UnloadTexture(_backgroundTexture);\n    }\n\n    return Task.CompletedTask;\n}</code></pre> <p>Why? - Textures live in GPU memory - Not garbage collected automatically - Memory leaks if not unloaded!</p>"},{"location":"guides/rendering/sprites/#texture-lifecycle","title":"Texture Lifecycle","text":"<pre><code>stateDiagram-v2\n    [*] --&gt; Loading: LoadTextureAsync()\n    Loading --&gt; Loaded: Success\n    Loading --&gt; [*]: Error\n\n    Loaded --&gt; Drawing: DrawTexture()\n    Drawing --&gt; Loaded: Each Frame\n\n    Loaded --&gt; Unloaded: UnloadTexture()\n    Unloaded --&gt; [*]\n\n    note right of Loaded\n        Texture in GPU memory\n        Uses VRAM!\n    end note\n\n    note right of Unloaded\n        Memory freed\n        No longer usable\n    end note</code></pre>"},{"location":"guides/rendering/sprites/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guides/rendering/sprites/#problem-texture-not-found","title":"Problem: Texture Not Found","text":"<p>Symptom: <code>FileNotFoundException</code> when loading</p> <p>Solutions:</p> <ol> <li> <p>Check file path <pre><code>// \u274c Wrong - absolute path\n\"C:/MyGame/assets/player.png\"\n\n// \u2705 Correct - relative path\n\"assets/player.png\"</code></pre></p> </li> <li> <p>Verify file exists <pre><code>if (!File.Exists(\"assets/player.png\"))\n{\n    Logger.LogError(\"Texture not found!\");\n}</code></pre></p> </li> <li> <p>Check <code>.csproj</code> copy settings <pre><code>&lt;ItemGroup&gt;\n  &lt;None Update=\"assets\\**\\*\"&gt;\n    &lt;CopyToOutputDirectory&gt;PreserveNewest&lt;/CopyToOutputDirectory&gt;\n  &lt;/None&gt;\n&lt;/ItemGroup&gt;</code></pre></p> </li> </ol>"},{"location":"guides/rendering/sprites/#problem-blurry-pixel-art","title":"Problem: Blurry Pixel Art","text":"<p>Symptom: Pixelated sprites look blurry</p> <p>Solution: Use <code>TextureScaleMode.Nearest</code>:</p> <pre><code>// \u274c Bad - blurry pixel art\n_texture = await _textureLoader.LoadTextureAsync(\n    \"assets/player.png\",\n    TextureScaleMode.Linear); // WRONG for pixel art\n\n// \u2705 Good - sharp pixel art\n_texture = await _textureLoader.LoadTextureAsync(\n    \"assets/player.png\",\n    TextureScaleMode.Nearest); // CORRECT for pixel art</code></pre>"},{"location":"guides/rendering/sprites/#problem-memory-leak","title":"Problem: Memory Leak","text":"<p>Symptom: Memory usage increases over time</p> <p>Cause: Not unloading textures</p> <p>Solution:</p> <pre><code>// \u274c Bad - memory leak!\nprotected override Task OnUnloadAsync(CancellationToken cancellationToken)\n{\n    return Task.CompletedTask; // Forgot to unload!\n}\n\n// \u2705 Good - proper cleanup\nprotected override Task OnUnloadAsync(CancellationToken cancellationToken)\n{\n    if (_texture != null)\n    {\n        _textureLoader.UnloadTexture(_texture);\n    }\n\n    return Task.CompletedTask;\n}</code></pre>"},{"location":"guides/rendering/sprites/#problem-texture-appears-blackwrong","title":"Problem: Texture Appears Black/Wrong","text":"<p>Symptom: Texture renders as solid color</p> <p>Causes &amp; Solutions:</p> <ol> <li>File corrupted</li> <li>Re-export image</li> <li> <p>Try different format (PNG recommended)</p> </li> <li> <p>Wrong color format</p> </li> <li>Ensure PNG has RGB/RGBA</li> <li> <p>Avoid grayscale/indexed color</p> </li> <li> <p>Texture not loaded <pre><code>if (_texture != null &amp;&amp; _texture.IsLoaded)\n{\n    _renderer.DrawTexture(_texture, x, y);\n}</code></pre></p> </li> </ol>"},{"location":"guides/rendering/sprites/#best-practices","title":"Best Practices","text":""},{"location":"guides/rendering/sprites/#do","title":"DO","text":"<ol> <li> <p>Use PNG for sprites <pre><code>// \u2705 PNG - transparency, lossless\n\"assets/player.png\"</code></pre></p> </li> <li> <p>Load async in OnLoadAsync <pre><code>protected override async Task OnLoadAsync(CancellationToken ct)\n{\n    _texture = await _textureLoader.LoadTextureAsync(..., ct);\n}</code></pre></p> </li> <li> <p>Use Nearest for pixel art <pre><code>TextureScaleMode.Nearest // Sharp scaling</code></pre></p> </li> <li> <p>Always unload <pre><code>protected override Task OnUnloadAsync(CancellationToken ct)\n{\n    _textureLoader.UnloadTexture(_texture);\n    return Task.CompletedTask;\n}</code></pre></p> </li> <li> <p>Use sprite sheets</p> </li> <li>One texture vs many = faster rendering</li> <li> <p>Less texture switches</p> </li> <li> <p>Cache texture references <pre><code>private ITexture? _cachedTexture;\n\n// \u2705 Load once, use many times\nprotected override async Task OnLoadAsync(CancellationToken ct)\n{\n    _cachedTexture = await _textureLoader.LoadTextureAsync(..., ct);\n}</code></pre></p> </li> </ol>"},{"location":"guides/rendering/sprites/#dont","title":"DON'T","text":"<ol> <li> <p>Don't load every frame <pre><code>// \u274c TERRIBLE - loads every frame!\nprotected override void OnRender(GameTime gt)\n{\n    var texture = _textureLoader.LoadTexture(...); // NO!\n    _renderer.DrawTexture(texture, x, y);\n}</code></pre></p> </li> <li> <p>Don't use absolute paths <pre><code>// \u274c Bad\n\"C:/Users/Me/Game/assets/player.png\"\n\n// \u2705 Good\n\"assets/player.png\"</code></pre></p> </li> <li> <p>Don't forget to unload <pre><code>// \u274c Memory leak!\nprotected override Task OnUnloadAsync(CancellationToken ct)\n{\n    // Forgot _textureLoader.UnloadTexture(_texture);\n    return Task.CompletedTask;\n}</code></pre></p> </li> <li> <p>Don't use Linear for pixel art <pre><code>// \u274c Blurry pixel art\nTextureScaleMode.Linear\n\n// \u2705 Sharp pixel art\nTextureScaleMode.Nearest</code></pre></p> </li> </ol>"},{"location":"guides/rendering/sprites/#performance-tips","title":"Performance Tips","text":"<ol> <li> <p>Batch sprites by texture <pre><code>// Draw all enemies (same texture) together\nforeach (var enemy in _enemies)\n{\n    _renderer.DrawTexture(_enemyTexture, enemy.X, enemy.Y);\n}\n\n// Then draw all coins (same texture)\nforeach (var coin in _coins)\n{\n    _renderer.DrawTexture(_coinTexture, coin.X, coin.Y);\n}</code></pre></p> </li> <li> <p>Use sprite sheets</p> </li> <li>Reduces texture switches</li> <li> <p>Faster than individual files</p> </li> <li> <p>Preload textures</p> </li> <li>Load in <code>OnLoadAsync</code>, not during gameplay</li> <li> <p>Show loading screen if many textures</p> </li> <li> <p>Unload unused textures</p> </li> <li>Free GPU memory when switching levels</li> <li>Reload when needed</li> </ol>"},{"location":"guides/rendering/sprites/#summary","title":"Summary","text":"Task Code Notes Load texture <code>LoadTextureAsync(path, scaleMode, ct)</code> Async, returns ITexture Draw at position <code>DrawTexture(texture, x, y)</code> Original size Draw scaled <code>DrawTexture(texture, x, y, w, h)</code> Custom size Draw from sheet <code>DrawTexture(texture, sx, sy, sw, sh, dx, dy, dw, dh)</code> 9 params Unload <code>UnloadTexture(texture)</code> Free GPU memory Scale mode <code>TextureScaleMode.Nearest</code> Pixel art Scale mode <code>TextureScaleMode.Linear</code> Smooth graphics"},{"location":"guides/rendering/sprites/#next-steps","title":"Next Steps","text":"<ul> <li>Animation - Animate sprites frame-by-frame</li> <li>Camera - Follow sprites with camera</li> <li>Collision - Detect sprite collisions</li> <li>Tilemaps - Build levels with tiles</li> </ul> <p>Ready to bring sprites to life? Try Sprite Animation!</p>"},{"location":"guides/rendering/texture-atlasing/","title":"Texture Atlasing","text":"<p>Texture atlasing combines multiple sprites into a single texture to dramatically reduce draw calls and improve rendering performance.</p>"},{"location":"guides/rendering/texture-atlasing/#what-is-texture-atlasing","title":"What is Texture Atlasing?","text":"<p>A texture atlas (also called a sprite sheet or texture pack) is a single large texture containing multiple smaller images. Instead of switching textures for every sprite, the renderer draws from different regions of the same atlas.</p> <p>Without Atlasing: - 100 unique sprites = 100 texture binds = 100 draw calls - Expensive GPU state changes - Lower frame rates</p> <p>With Atlasing: - 100 sprites packed into 1 atlas = 1 texture bind = 1 draw call - Minimal state changes - Dramatically improved performance</p>"},{"location":"guides/rendering/texture-atlasing/#benefits","title":"Benefits","text":""},{"location":"guides/rendering/texture-atlasing/#performance","title":"Performance","text":"<ul> <li>Reduce draw calls by 90-99% - Batch sprites that share an atlas</li> <li>Eliminate texture switching overhead - One texture stays bound</li> <li>Improve frame rates - Especially on lower-end hardware</li> <li>Better GPU utilization - Larger batches = more efficient rendering</li> </ul>"},{"location":"guides/rendering/texture-atlasing/#memory","title":"Memory","text":"<ul> <li>Shared texture memory - GPU loads one large texture instead of many small ones</li> <li>Better cache locality - Related sprites stored together</li> <li>Reduced texture overhead - Fewer texture objects to manage</li> </ul>"},{"location":"guides/rendering/texture-atlasing/#workflow","title":"Workflow","text":"<ul> <li>Runtime generation - No prebuild step required</li> <li>Automatic integration - Works transparently with existing code</li> <li>Flexible packing - Pack what makes sense for your game</li> </ul>"},{"location":"guides/rendering/texture-atlasing/#creating-an-atlas","title":"Creating an Atlas","text":""},{"location":"guides/rendering/texture-atlasing/#basic-usage","title":"Basic Usage","text":"<pre><code>using Brine2D.Rendering;\n\n// Load individual textures\nvar playerTexture = await _textureLoader.LoadTextureAsync(\"assets/player.png\");\nvar enemyTexture = await _textureLoader.LoadTextureAsync(\"assets/enemy.png\");\nvar bulletTexture = await _textureLoader.LoadTextureAsync(\"assets/bullet.png\");\n\n// Build atlas from textures\nvar textures = new[] { playerTexture, enemyTexture, bulletTexture };\nvar atlas = await AtlasBuilder.BuildAtlasAsync(\n    _renderer,\n    _textureLoader,\n    textures,\n    padding: 2,      // Pixels between sprites (prevents bleeding)\n    maxSize: 2048    // Maximum atlas dimension (width/height)\n);\n\n// The atlas is now ready to use\nLogger.LogInfo($\"Atlas created: {atlas.Width}x{atlas.Height} with {atlas.RegionCount} sprites\");</code></pre>"},{"location":"guides/rendering/texture-atlasing/#from-file-paths","title":"From File Paths","text":"<pre><code>// Build atlas directly from file paths\nvar paths = new[]\n{\n    \"assets/sprites/player.png\",\n    \"assets/sprites/enemy1.png\",\n    \"assets/sprites/enemy2.png\",\n    \"assets/sprites/coin.png\",\n    \"assets/sprites/heart.png\"\n};\n\nvar atlas = await AtlasBuilder.BuildAtlasAsync(\n    _renderer,\n    _textureLoader,\n    paths,\n    padding: 2,\n    maxSize: 2048\n);</code></pre>"},{"location":"guides/rendering/texture-atlasing/#directory-packing","title":"Directory Packing","text":"<pre><code>// Pack all PNG files in a directory\nvar directoryPath = \"assets/ui\";\nvar files = Directory.GetFiles(directoryPath, \"*.png\");\n\nvar atlas = await AtlasBuilder.BuildAtlasAsync(\n    _renderer,\n    _textureLoader,\n    files,\n    padding: 4,  // UI often needs more padding\n    maxSize: 2048\n);</code></pre>"},{"location":"guides/rendering/texture-atlasing/#using-atlas-regions","title":"Using Atlas Regions","text":""},{"location":"guides/rendering/texture-atlasing/#manual-drawing","title":"Manual Drawing","text":"<pre><code>// Get the region for a specific texture\nvar playerRegion = atlas.GetRegion(playerTexture);\n\n// Draw using the atlas texture and region's source rect\n_renderer.DrawTexture(\n    atlas.AtlasTexture,\n    playerRegion.SourceRect.X,\n    playerRegion.SourceRect.Y,\n    playerRegion.SourceRect.Width,\n    playerRegion.SourceRect.Height,\n    x, y, width, height\n);</code></pre>"},{"location":"guides/rendering/texture-atlasing/#region-properties","title":"Region Properties","text":"<pre><code>var region = atlas.GetRegion(texture);\n\n// Source rectangle in the atlas\nvar sourceRect = region.SourceRect;\nLogger.LogInfo($\"Region at ({sourceRect.X}, {sourceRect.Y}), size {sourceRect.Width}x{sourceRect.Height}\");\n\n// Original texture reference\nvar originalTexture = region.OriginalTexture;\n\n// Check if texture is in atlas\nif (atlas.TryGetRegion(someTexture, out var foundRegion))\n{\n    // Region exists\n}</code></pre>"},{"location":"guides/rendering/texture-atlasing/#ecs-integration","title":"ECS Integration","text":"<p>The sprite rendering system can automatically use atlases when available.</p>"},{"location":"guides/rendering/texture-atlasing/#basic-setup","title":"Basic Setup","text":"<pre><code>public class GameScene : Scene\n{\n    private TextureAtlas? _gameAtlas;\n\n    protected override async Task OnInitializeAsync(CancellationToken cancellationToken)\n    {\n        // Build atlas during scene initialization\n        var spritePaths = new[]\n        {\n            \"assets/player.png\",\n            \"assets/enemy.png\",\n            \"assets/projectile.png\"\n        };\n\n        _gameAtlas = await AtlasBuilder.BuildAtlasAsync(\n            _renderer,\n            _textureLoader,\n            spritePaths,\n            padding: 2,\n            maxSize: 2048\n        );\n\n        // Entities will automatically use the atlas\n        CreateGameEntities();\n    }\n}</code></pre>"},{"location":"guides/rendering/texture-atlasing/#sprite-components","title":"Sprite Components","text":"<pre><code>// Create sprite component with texture path\nvar player = _world.CreateEntity(\"Player\");\nvar sprite = player.AddComponent&lt;SpriteComponent&gt;();\nsprite.TexturePath = \"assets/player.png\";  // Will use atlas if available\nsprite.Layer = 10;\n\n// The SpriteRenderingSystem automatically:\n// 1. Loads the texture\n// 2. Checks if it's in an atlas\n// 3. Uses atlas region if found\n// 4. Falls back to individual texture if not</code></pre>"},{"location":"guides/rendering/texture-atlasing/#custom-atlas-manager","title":"Custom Atlas Manager","text":"<pre><code>public class AtlasManager\n{\n    private readonly Dictionary&lt;string, TextureAtlas&gt; _atlases = new();\n    private readonly IRenderer _renderer;\n    private readonly ITextureLoader _textureLoader;\n\n    public AtlasManager(IRenderer renderer, ITextureLoader textureLoader)\n    {\n        _renderer = renderer;\n        _textureLoader = textureLoader;\n    }\n\n    public async Task LoadAtlasAsync(string name, string[] paths)\n    {\n        var atlas = await AtlasBuilder.BuildAtlasAsync(\n            _renderer,\n            _textureLoader,\n            paths,\n            padding: 2,\n            maxSize: 2048\n        );\n\n        _atlases[name] = atlas;\n    }\n\n    public TextureAtlas? GetAtlas(string name)\n    {\n        return _atlases.TryGetValue(name, out var atlas) ? atlas : null;\n    }\n\n    public void UnloadAtlas(string name)\n    {\n        if (_atlases.TryGetValue(name, out var atlas))\n        {\n            atlas.Dispose();\n            _atlases.Remove(name);\n        }\n    }\n\n    public void UnloadAll()\n    {\n        foreach (var atlas in _atlases.Values)\n        {\n            atlas.Dispose();\n        }\n        _atlases.Clear();\n    }\n}</code></pre>"},{"location":"guides/rendering/texture-atlasing/#scene-based-atlases","title":"Scene-Based Atlases","text":"<pre><code>public class LevelScene : Scene\n{\n    private AtlasManager? _atlasManager;\n\n    protected override async Task OnInitializeAsync(CancellationToken cancellationToken)\n    {\n        _atlasManager = new AtlasManager(_renderer, _textureLoader);\n\n        // Load atlases for different sprite categories\n        await _atlasManager.LoadAtlasAsync(\"characters\", new[]\n        {\n            \"assets/player.png\",\n            \"assets/enemy1.png\",\n            \"assets/enemy2.png\",\n            \"assets/npc.png\"\n        });\n\n        await _atlasManager.LoadAtlasAsync(\"environment\", new[]\n        {\n            \"assets/tree.png\",\n            \"assets/rock.png\",\n            \"assets/grass.png\",\n            \"assets/water.png\"\n        });\n\n        await _atlasManager.LoadAtlasAsync(\"ui\", new[]\n        {\n            \"assets/ui/button.png\",\n            \"assets/ui/icon_health.png\",\n            \"assets/ui/icon_mana.png\"\n        });\n    }\n\n    protected override void OnDispose()\n    {\n        _atlasManager?.UnloadAll();\n    }\n}</code></pre>"},{"location":"guides/rendering/texture-atlasing/#packing-strategies","title":"Packing Strategies","text":""},{"location":"guides/rendering/texture-atlasing/#game-objects","title":"Game Objects","text":"<p>Pack sprites that render together:</p> <pre><code>// Good: Pack all enemy sprites together\nvar enemyAtlas = await AtlasBuilder.BuildAtlasAsync(\n    _renderer,\n    _textureLoader,\n    new[] \n    {\n        \"assets/enemies/zombie.png\",\n        \"assets/enemies/skeleton.png\",\n        \"assets/enemies/bat.png\",\n        \"assets/enemies/ghost.png\"\n    },\n    padding: 2,\n    maxSize: 2048\n);</code></pre>"},{"location":"guides/rendering/texture-atlasing/#ui-elements","title":"UI Elements","text":"<p>Pack UI components separately from game sprites:</p> <pre><code>// Separate atlas for UI (often rendered on top layer)\nvar uiAtlas = await AtlasBuilder.BuildAtlasAsync(\n    _renderer,\n    _textureLoader,\n    new[]\n    {\n        \"assets/ui/button_normal.png\",\n        \"assets/ui/button_hover.png\",\n        \"assets/ui/panel_bg.png\",\n        \"assets/ui/icon_inventory.png\"\n    },\n    padding: 4,  // UI often needs more padding\n    maxSize: 2048\n);</code></pre>"},{"location":"guides/rendering/texture-atlasing/#effects-and-particles","title":"Effects and Particles","text":"<p>Pack particle textures together:</p> <pre><code>// Atlas for particle system textures\nvar particleAtlas = await AtlasBuilder.BuildAtlasAsync(\n    _renderer,\n    _textureLoader,\n    new[]\n    {\n        \"assets/particles/fire.png\",\n        \"assets/particles/smoke.png\",\n        \"assets/particles/spark.png\",\n        \"assets/particles/dust.png\"\n    },\n    padding: 2,\n    maxSize: 1024  // Particles are usually smaller\n);</code></pre>"},{"location":"guides/rendering/texture-atlasing/#animated-sprites","title":"Animated Sprites","text":"<pre><code>// Pack all frames of an animation\nvar playerWalkFrames = Enumerable.Range(0, 8)\n    .Select(i =&gt; $\"assets/player/walk_{i:00}.png\")\n    .ToArray();\n\nvar playerAtlas = await AtlasBuilder.BuildAtlasAsync(\n    _renderer,\n    _textureLoader,\n    playerWalkFrames,\n    padding: 2,\n    maxSize: 2048\n);</code></pre>"},{"location":"guides/rendering/texture-atlasing/#advanced-features","title":"Advanced Features","text":""},{"location":"guides/rendering/texture-atlasing/#multiple-atlases","title":"Multiple Atlases","text":"<p>Use multiple atlases for different sprite categories:</p> <pre><code>public class MultiAtlasScene : Scene\n{\n    private TextureAtlas? _characterAtlas;\n    private TextureAtlas? _environmentAtlas;\n    private TextureAtlas? _effectsAtlas;\n\n    protected override async Task OnInitializeAsync(CancellationToken cancellationToken)\n    {\n        // Characters (high resolution, infrequent updates)\n        _characterAtlas = await BuildCharacterAtlas();\n\n        // Environment (medium resolution, static)\n        _environmentAtlas = await BuildEnvironmentAtlas();\n\n        // Effects (low resolution, frequently changed)\n        _effectsAtlas = await BuildEffectsAtlas();\n    }\n\n    private async Task&lt;TextureAtlas&gt; BuildCharacterAtlas()\n    {\n        var paths = Directory.GetFiles(\"assets/characters\", \"*.png\");\n        return await AtlasBuilder.BuildAtlasAsync(\n            _renderer, _textureLoader, paths,\n            padding: 2, maxSize: 2048\n        );\n    }\n}</code></pre>"},{"location":"guides/rendering/texture-atlasing/#dynamic-atlas-updates","title":"Dynamic Atlas Updates","text":"<p>For games that load sprites dynamically:</p> <pre><code>public class DynamicAtlasManager\n{\n    private TextureAtlas? _currentAtlas;\n    private readonly List&lt;string&gt; _loadedPaths = new();\n\n    public async Task AddSpriteAsync(string path)\n    {\n        if (_loadedPaths.Contains(path))\n            return; // Already in atlas\n\n        _loadedPaths.Add(path);\n\n        // Rebuild atlas with new sprite\n        _currentAtlas?.Dispose();\n        _currentAtlas = await AtlasBuilder.BuildAtlasAsync(\n            _renderer,\n            _textureLoader,\n            _loadedPaths.ToArray(),\n            padding: 2,\n            maxSize: 2048\n        );\n    }\n}</code></pre>"},{"location":"guides/rendering/texture-atlasing/#padding-configuration","title":"Padding Configuration","text":"<p>Prevent texture bleeding with appropriate padding:</p> <pre><code>// Minimal padding for pixel art (nearest neighbor)\nvar pixelArtAtlas = await AtlasBuilder.BuildAtlasAsync(\n    _renderer, _textureLoader, textures,\n    padding: 1,  // 1px is often enough\n    maxSize: 2048\n);\n\n// More padding for smooth sprites (linear filtering)\nvar smoothAtlas = await AtlasBuilder.BuildAtlasAsync(\n    _renderer, _textureLoader, textures,\n    padding: 4,  // 4px prevents bleeding with linear filtering\n    maxSize: 2048\n);\n\n// UI with scaling needs extra padding\nvar uiAtlas = await AtlasBuilder.BuildAtlasAsync(\n    _renderer, _textureLoader, textures,\n    padding: 8,  // 8px for UI that may scale\n    maxSize: 2048\n);</code></pre>"},{"location":"guides/rendering/texture-atlasing/#performance-considerations","title":"Performance Considerations","text":""},{"location":"guides/rendering/texture-atlasing/#atlas-size-limits","title":"Atlas Size Limits","text":"<p>Different hardware has different texture size limits:</p> <pre><code>// Conservative size (works on most hardware)\nmaxSize: 2048\n\n// Larger size (requires modern GPU)\nmaxSize: 4096\n\n// Multiple atlases if needed\nif (textures.Length &gt; 100)\n{\n    // Split into multiple atlases\n    var atlas1 = await BuildAtlas(textures.Take(50).ToArray());\n    var atlas2 = await BuildAtlas(textures.Skip(50).ToArray());\n}</code></pre>"},{"location":"guides/rendering/texture-atlasing/#when-to-use-atlasing","title":"When to Use Atlasing","text":"<p>Good Use Cases: - Games with 10+ unique sprites - UI systems with many icons/buttons - Particle effects using sprite textures - Any game targeting lower-end hardware - Mobile games</p> <p>Less Beneficial: - Games with &lt; 5 unique sprites - Sprites rarely rendered together - Extremely large textures (&gt; 1024x1024 each) - Dynamically generated textures</p>"},{"location":"guides/rendering/texture-atlasing/#benchmark-results","title":"Benchmark Results","text":"<p>Real-world performance improvements:</p> Sprite Count Draw Calls (No Atlas) Draw Calls (Atlas) Improvement 10 sprites 10 1 90% 50 sprites 50 1-2 96-98% 100 sprites 100 1-2 98-99% 500 sprites (10 types) 10 1 90% <p>Frame Rate Impact:</p> Scenario Without Atlas With Atlas Improvement Platformer (50 sprites) 55 FPS 60 FPS 9% faster Top-down (200 sprites) 45 FPS 60 FPS 33% faster UI (100 buttons) 40 FPS 60 FPS 50% faster"},{"location":"guides/rendering/texture-atlasing/#best-practices","title":"Best Practices","text":""},{"location":"guides/rendering/texture-atlasing/#do","title":"Do","text":"<ul> <li>Pack sprites rendered together - Same layer, similar lifecycle</li> <li>Use appropriate padding - 2-4px for most cases</li> <li>Separate atlases by category - Characters, UI, effects</li> <li>Pack frequently used sprites - Player, common enemies, UI</li> <li>Profile before and after - Measure actual performance gains</li> </ul>"},{"location":"guides/rendering/texture-atlasing/#dont","title":"Don't","text":"<ul> <li>Pack unrelated sprites - Wastes atlas space</li> <li>Use too little padding - Causes texture bleeding</li> <li>Create massive atlases - Stick to 2048x2048 or 4096x4096</li> <li>Pack huge textures - Keep individual sprites &lt; 512x512</li> <li>Rebuild atlases every frame - Build during initialization</li> </ul>"},{"location":"guides/rendering/texture-atlasing/#padding-guidelines","title":"Padding Guidelines","text":"<pre><code>// Pixel art (nearest neighbor filtering)\npadding: 1  // Minimal padding, no bleeding with nearest neighbor\n\n// Smooth sprites (linear filtering)\npadding: 2-4  // Prevents bleeding with bilinear filtering\n\n// UI elements (may scale)\npadding: 4-8  // Extra padding for scaling operations\n\n// High-res sprites (&gt; 512x512)\npadding: 8  // More padding for large textures</code></pre>"},{"location":"guides/rendering/texture-atlasing/#common-patterns","title":"Common Patterns","text":""},{"location":"guides/rendering/texture-atlasing/#scene-initialization","title":"Scene Initialization","text":"<pre><code>public class GameScene : Scene\n{\n    private readonly AtlasManager _atlasManager;\n\n    public GameScene(AtlasManager atlasManager, /* ... */)\n    {\n        _atlasManager = atlasManager;\n    }\n\n    protected override async Task OnInitializeAsync(CancellationToken cancellationToken)\n    {\n        // Load atlases before creating entities\n        await _atlasManager.LoadAtlasAsync(\"game\", new[]\n        {\n            \"assets/player.png\",\n            \"assets/enemy.png\",\n            \"assets/bullet.png\"\n        });\n\n        // Now create entities (they'll use the atlas)\n        CreatePlayer();\n        CreateEnemies();\n    }\n}</code></pre>"},{"location":"guides/rendering/texture-atlasing/#resource-preloading","title":"Resource Preloading","text":"<pre><code>public class PreloadScene : Scene\n{\n    protected override async Task OnInitializeAsync(CancellationToken cancellationToken)\n    {\n        // Build all atlases during loading screen\n        var atlases = new Dictionary&lt;string, string[]&gt;\n        {\n            [\"characters\"] = new[] { \"assets/player.png\", \"assets/enemy.png\" },\n            [\"environment\"] = new[] { \"assets/tree.png\", \"assets/rock.png\" },\n            [\"ui\"] = new[] { \"assets/ui/button.png\", \"assets/ui/icon.png\" }\n        };\n\n        foreach (var (name, paths) in atlases)\n        {\n            await _atlasManager.LoadAtlasAsync(name, paths);\n            UpdateLoadingProgress();\n        }\n\n        // Transition to game scene\n        await _sceneManager.LoadSceneAsync&lt;GameScene&gt;();\n    }\n}</code></pre>"},{"location":"guides/rendering/texture-atlasing/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guides/rendering/texture-atlasing/#texture-bleeding","title":"Texture Bleeding","text":"<p>Problem: Lines or artifacts appear around sprites.</p> <p>Solution: Increase padding:</p> <pre><code>// Increase from 2 to 4 pixels\nvar atlas = await AtlasBuilder.BuildAtlasAsync(\n    _renderer, _textureLoader, textures,\n    padding: 4,  // Increased padding\n    maxSize: 2048\n);</code></pre>"},{"location":"guides/rendering/texture-atlasing/#atlas-too-large","title":"Atlas Too Large","text":"<p>Problem: Atlas exceeds hardware limits (texture too big).</p> <p>Solution: Split into multiple atlases:</p> <pre><code>// Split large sprite sets\nvar characterAtlas = await BuildAtlas(characterSprites);\nvar environmentAtlas = await BuildAtlas(environmentSprites);</code></pre>"},{"location":"guides/rendering/texture-atlasing/#poor-packing-efficiency","title":"Poor Packing Efficiency","text":"<p>Problem: Atlas has lots of wasted space.</p> <p>Solution: Only pack sprites of similar sizes together:</p> <pre><code>// Separate small and large sprites\nvar smallSprites = textures.Where(t =&gt; t.Width &lt; 64 &amp;&amp; t.Height &lt; 64);\nvar largeSprites = textures.Where(t =&gt; t.Width &gt;= 64 || t.Height &gt;= 64);\n\nvar smallAtlas = await BuildAtlas(smallSprites.ToArray());\nvar largeAtlas = await BuildAtlas(largeSprites.ToArray());</code></pre>"},{"location":"guides/rendering/texture-atlasing/#memory-usage","title":"Memory Usage","text":"<p>Problem: High memory consumption.</p> <p>Solution: Dispose atlases when no longer needed:</p> <pre><code>protected override void OnDispose()\n{\n    // Clean up atlases\n    _characterAtlas?.Dispose();\n    _environmentAtlas?.Dispose();\n    _effectsAtlas?.Dispose();\n}</code></pre>"},{"location":"guides/rendering/texture-atlasing/#see-also","title":"See Also","text":"<ul> <li>Sprites &amp; Textures - Basic sprite rendering</li> <li>GPU Renderer - Modern rendering backend</li> <li>Performance Optimization - Other optimization techniques</li> <li>Particles - Using atlases with particle effects</li> </ul> <p>Next Steps: - Implement texture atlasing in your game - Profile draw call reduction - Experiment with different packing strategies - Monitor texture memory usage</p>"},{"location":"guides/scenes/lifecycle-hooks/","title":"Lifecycle Hooks","text":"<p>Lifecycle hooks provide fine-grained control over when and how your game logic executes. This guide covers advanced usage for power users who need manual control.</p> <p>Advanced Feature</p> <p>Most games should use automatic execution. Only opt-out if you have a specific need for manual control.</p>"},{"location":"guides/scenes/lifecycle-hooks/#what-are-lifecycle-hooks","title":"What Are Lifecycle Hooks?","text":"<p>Lifecycle hooks are integration points where Brine2D automatically executes systems (like ECS pipelines) at specific points in the game loop:</p> <pre><code>graph LR\n    A[Input] --&gt; B[PreUpdate Hooks]\n    B --&gt; C[Scene.Update]\n    C --&gt; D[PostUpdate Hooks]\n    D --&gt; E[PreRender Hooks]\n    E --&gt; F[Scene.Render]\n    F --&gt; G[PostRender Hooks]\n\n    style A fill:#264f78,stroke:#4fc1ff,stroke-width:2px,color:#fff\n    style B fill:#2d5016,stroke:#4ec9b0,stroke-width:2px,color:#fff\n    style C fill:#1e3a5f,stroke:#569cd6,stroke-width:2px,color:#fff\n    style D fill:#2d5016,stroke:#4ec9b0,stroke-width:2px,color:#fff\n    style E fill:#2d5016,stroke:#4ec9b0,stroke-width:2px,color:#fff\n    style F fill:#1e3a5f,stroke:#569cd6,stroke-width:2px,color:#fff\n    style G fill:#2d5016,stroke:#4ec9b0,stroke-width:2px,color:#fff</code></pre> <p>Default behavior (automatic execution):</p> <ul> <li>\u2705 Input layers process input automatically</li> <li>\u2705 ECS systems run automatically at correct times</li> <li>\u2705 Frame management handled automatically (<code>Clear</code>/<code>BeginFrame</code>/<code>EndFrame</code>)</li> <li>\u2705 Components update automatically</li> </ul>"},{"location":"guides/scenes/lifecycle-hooks/#automatic-vs-manual-execution","title":"Automatic vs Manual Execution","text":""},{"location":"guides/scenes/lifecycle-hooks/#automatic-execution-default","title":"Automatic Execution (Default)","text":"<p>This is what most games should use:</p> <pre><code>public class GameScene : Scene\n{\n    private readonly IEntityWorld _world;\n\n    protected override void OnUpdate(GameTime gameTime)\n    {\n        // Just write your game logic\n        CheckWinCondition();\n\n        // Systems run automatically!\n        // Components update automatically!\n    }\n\n    protected override void OnRender(GameTime gameTime)\n    {\n        // Frame management automatic!\n        // ECS rendering automatic!\n\n        _renderer.DrawText($\"Score: {_score}\", 10, 10, Color.White);\n    }\n}</code></pre> <p>Benefits:</p> <ul> <li>Simple and straightforward</li> <li>Less boilerplate code</li> <li>Hard to mess up</li> <li>ASP.NET-like developer experience</li> </ul>"},{"location":"guides/scenes/lifecycle-hooks/#manual-execution-power-users","title":"Manual Execution (Power Users)","text":"<p>Disable automatic behavior when you need fine control:</p> <pre><code>public class ManualControlScene : Scene\n{\n    private readonly UpdatePipeline _updatePipeline;\n\n    // Disable automatic system execution\n    public override bool EnableLifecycleHooks =&gt; false;\n\n    protected override void OnUpdate(GameTime gameTime)\n    {\n        // Manually execute systems\n        _updatePipeline.Execute(gameTime);\n        _world.Update(gameTime);\n    }\n}</code></pre> <p>Use manual control when:</p> <ul> <li>You need custom execution order</li> <li>You want conditional system execution</li> <li>You're implementing fixed timestep logic</li> <li>You need to skip systems based on game state</li> </ul>"},{"location":"guides/scenes/lifecycle-hooks/#disabling-automatic-behavior","title":"Disabling Automatic Behavior","text":""},{"location":"guides/scenes/lifecycle-hooks/#option-1-disable-lifecycle-hooks-only","title":"Option 1: Disable Lifecycle Hooks Only","text":"<p>Keep automatic frame management but control systems manually:</p> <pre><code>public class ManualSystemsScene : Scene\n{\n    private readonly UpdatePipeline _updatePipeline;\n    private readonly RenderPipeline _renderPipeline;\n\n    public override bool EnableLifecycleHooks =&gt; false;\n\n    public ManualSystemsScene(\n        UpdatePipeline updatePipeline,\n        RenderPipeline renderPipeline,\n        ILogger&lt;ManualSystemsScene&gt; logger) : base(logger)\n    {\n        _updatePipeline = updatePipeline;\n        _renderPipeline = renderPipeline;\n    }\n\n    protected override void OnUpdate(GameTime gameTime)\n    {\n        _updatePipeline.Execute(gameTime);\n    }\n\n    protected override void OnRender(GameTime gameTime)\n    {\n        // Frame management still automatic\n        _renderPipeline.Execute(_renderer);\n    }\n}</code></pre>"},{"location":"guides/scenes/lifecycle-hooks/#option-2-full-manual-control","title":"Option 2: Full Manual Control","text":"<p>Disable both system execution and frame management:</p> <pre><code>public class FullManualControlScene : Scene\n{\n    private readonly IRenderer _renderer;\n    private readonly UpdatePipeline _updatePipeline;\n    private readonly RenderPipeline _renderPipeline;\n\n    public override bool EnableLifecycleHooks =&gt; false;\n    public override bool EnableAutomaticFrameManagement =&gt; false;\n\n    protected override void OnUpdate(GameTime gameTime)\n    {\n        _updatePipeline.Execute(gameTime);\n    }\n\n    protected override void OnRender(GameTime gameTime)\n    {\n        _renderer.Clear(Color.Black);\n        _renderer.BeginFrame();\n\n        _renderPipeline.Execute(_renderer);\n\n        _renderer.EndFrame();\n    }\n}</code></pre>"},{"location":"guides/scenes/lifecycle-hooks/#understanding-hook-execution-order","title":"Understanding Hook Execution Order","text":"<pre><code>sequenceDiagram\n    participant GL as Game Loop\n    participant SM as SceneManager\n    participant H as Lifecycle Hooks\n    participant S as Scene\n\n    GL-&gt;&gt;SM: Update()\n\n    SM-&gt;&gt;H: PreUpdate Hooks\n    Note over H: Input layers, etc.\n\n    SM-&gt;&gt;S: OnUpdate()\n    Note over S: Your game logic\n\n    SM-&gt;&gt;H: PostUpdate Hooks\n    Note over H: ECS systems, physics\n\n    GL-&gt;&gt;SM: Render()\n\n    SM-&gt;&gt;H: PreRender Hooks\n    Note over H: ECS rendering\n\n    SM-&gt;&gt;S: OnRender()\n    Note over S: Your UI/debug\n\n    SM-&gt;&gt;H: PostRender Hooks\n    Note over H: Debug overlays</code></pre> <p>Built-in hooks:</p> Hook Order Phase Purpose InputLayerHook 0 PreUpdate Process input layers ECSUpdateHook 100 PostUpdate Run ECS update systems ECSRenderHook 0 PreRender Run ECS render systems"},{"location":"guides/scenes/lifecycle-hooks/#practical-examples","title":"Practical Examples","text":""},{"location":"guides/scenes/lifecycle-hooks/#pausable-game","title":"Pausable Game","text":"<p>Run systems only when game is not paused:</p> <pre><code>public class PausableGameScene : Scene\n{\n    private readonly UpdatePipeline _updatePipeline;\n    private readonly IEntityWorld _world;\n    private readonly IInputService _input;\n    private bool _isPaused;\n\n    public override bool EnableLifecycleHooks =&gt; false;\n\n    protected override void OnUpdate(GameTime gameTime)\n    {\n        // Always handle input\n        if (_input.IsKeyPressed(Keys.P))\n        {\n            _isPaused = !_isPaused;\n            Logger.LogInformation(\"Game {State}\", _isPaused ? \"PAUSED\" : \"RESUMED\");\n        }\n\n        // Only run systems when not paused\n        if (!_isPaused)\n        {\n            _updatePipeline.Execute(gameTime);\n            _world.Update(gameTime);\n        }\n    }\n}</code></pre>"},{"location":"guides/scenes/lifecycle-hooks/#fixed-timestep","title":"Fixed Timestep","text":"<p>Implement frame-rate independent physics:</p> <pre><code>public class FixedTimestepScene : Scene\n{\n    private readonly UpdatePipeline _updatePipeline;\n    private const float FixedDeltaTime = 1f / 60f;\n    private float _accumulator;\n\n    public override bool EnableLifecycleHooks =&gt; false;\n\n    protected override void OnUpdate(GameTime gameTime)\n    {\n        var deltaTime = (float)gameTime.DeltaTime;\n        _accumulator += deltaTime;\n\n        while (_accumulator &gt;= FixedDeltaTime)\n        {\n            var fixedGameTime = new GameTime(\n                gameTime.TotalTime,\n                FixedDeltaTime,\n                gameTime.FrameCount\n            );\n\n            _updatePipeline.Execute(fixedGameTime);\n            _accumulator -= FixedDeltaTime;\n        }\n    }\n}</code></pre>"},{"location":"guides/scenes/lifecycle-hooks/#selective-system-execution","title":"Selective System Execution","text":"<p>Run only specific systems:</p> <pre><code>public class CustomPipelineScene : Scene\n{\n    private readonly PlayerControllerSystem _playerController;\n    private readonly PhysicsSystem _physics;\n    private readonly SpriteRenderingSystem _spriteRenderer;\n\n    public override bool EnableLifecycleHooks =&gt; false;\n    public override bool EnableAutomaticFrameManagement =&gt; false;\n\n    protected override void OnUpdate(GameTime gameTime)\n    {\n        _playerController.Update(gameTime);\n        _physics.Update(gameTime);\n        // Skip AI, audio, etc.\n    }\n\n    protected override void OnRender(GameTime gameTime)\n    {\n        _renderer.Clear(Color.Black);\n        _renderer.BeginFrame();\n\n        _spriteRenderer.Render(_renderer);\n        // Skip particles, debug rendering\n\n        _renderer.EndFrame();\n    }\n}</code></pre>"},{"location":"guides/scenes/lifecycle-hooks/#best-practices","title":"Best Practices","text":"<p>Do This</p> <p>\u2705 Use automatic execution by default \u2705 Document why you disabled hooks \u2705 Keep manual logic simple \u2705 Test thoroughly  </p> <p>Avoid This</p> <p>\u274c Disabling hooks without a reason \u274c Forgetting to call systems \u274c Mixing automatic and manual in same scene \u274c Skipping frame management calls  </p>"},{"location":"guides/scenes/lifecycle-hooks/#performance-considerations","title":"Performance Considerations","text":"<p>Automatic execution overhead:</p> <p>The overhead of automatic hooks is negligible (~0.01ms). Don't disable for performance unless profiling proves it's necessary.</p> <p>Manual control CAN help when:</p> <ul> <li>Skipping entire systems based on game state</li> <li>Batching expensive operations</li> <li>Running systems at different intervals</li> <li>Implementing custom scheduling</li> </ul> <pre><code>public class OptimizedScene : Scene\n{\n    private readonly AISystem _aiSystem;\n    private int _frameCount;\n\n    public override bool EnableLifecycleHooks =&gt; false;\n\n    protected override void OnUpdate(GameTime gameTime)\n    {\n        _frameCount++;\n\n        // Run AI every 3 frames instead of every frame\n        if (_frameCount % 3 == 0)\n        {\n            _aiSystem.Update(gameTime);\n        }\n    }\n}</code></pre>"},{"location":"guides/scenes/lifecycle-hooks/#debugging-manual-execution","title":"Debugging Manual Execution","text":""},{"location":"guides/scenes/lifecycle-hooks/#check-hook-status-at-startup","title":"Check Hook Status at Startup","text":"<pre><code>protected override void OnInitialize()\n{\n    if (!EnableLifecycleHooks)\n    {\n        Logger.LogWarning(\"Lifecycle hooks DISABLED - manual control active\");\n    }\n\n    if (!EnableAutomaticFrameManagement)\n    {\n        Logger.LogWarning(\"Frame management DISABLED - you must call Clear/BeginFrame/EndFrame\");\n    }\n}</code></pre>"},{"location":"guides/scenes/lifecycle-hooks/#common-issues","title":"Common Issues","text":"<p>Problem: Systems not running</p> <pre><code>// Check if hooks are enabled\npublic override bool EnableLifecycleHooks =&gt; true; // \u2190 Make sure this is true\n\n// Or call systems manually\n_updatePipeline.Execute(gameTime);</code></pre> <p>Problem: Black screen</p> <pre><code>// Enable automatic frame management\npublic override bool EnableAutomaticFrameManagement =&gt; true;\n\n// Or call manually\n_renderer.Clear(Color.Black);\n_renderer.BeginFrame();\n// ... rendering ...\n_renderer.EndFrame();</code></pre>"},{"location":"guides/scenes/lifecycle-hooks/#migration-guide","title":"Migration Guide","text":""},{"location":"guides/scenes/lifecycle-hooks/#from-automatic-to-manual","title":"From Automatic to Manual","text":"<p>Before:</p> <pre><code>public class GameScene : Scene\n{\n    protected override void OnUpdate(GameTime gameTime)\n    {\n        // Game logic\n    }\n}</code></pre> <p>After:</p> <pre><code>public class GameScene : Scene\n{\n    private readonly UpdatePipeline _updatePipeline;\n    private readonly IEntityWorld _world;\n\n    public override bool EnableLifecycleHooks =&gt; false; // Add this\n\n    public GameScene(\n        UpdatePipeline updatePipeline,\n        IEntityWorld world,\n        ILogger&lt;GameScene&gt; logger) : base(logger)\n    {\n        _updatePipeline = updatePipeline;\n        _world = world;\n    }\n\n    protected override void OnUpdate(GameTime gameTime)\n    {\n        // Game logic\n\n        _updatePipeline.Execute(gameTime); // Add this\n        _world.Update(gameTime);           // Add this\n    }\n}</code></pre>"},{"location":"guides/scenes/lifecycle-hooks/#from-manual-to-automatic","title":"From Manual to Automatic","text":"<p>Remove the overrides and manual calls:</p> <pre><code>public class GameScene : Scene\n{\n    // Remove: public override bool EnableLifecycleHooks =&gt; false;\n    // Remove: _updatePipeline.Execute(gameTime);\n\n    protected override void OnUpdate(GameTime gameTime)\n    {\n        // Just your game logic\n    }\n}</code></pre>"},{"location":"guides/scenes/lifecycle-hooks/#summary","title":"Summary","text":"Feature Automatic Manual Complexity Low High Flexibility Medium Maximum Error-prone Low High Performance Excellent Excellent Recommended Most games Advanced needs <p>Key takeaway: Start with automatic execution. Only switch to manual control when you hit a specific limitation.</p>"},{"location":"guides/scenes/lifecycle-hooks/#see-also","title":"See Also","text":"<ul> <li>Scene Lifecycle - Understanding scene phases</li> <li>Scene Transitions - Loading screens and fades</li> <li>ECS Systems - Creating custom systems</li> <li>Game Loop - How the game loop works</li> </ul>"},{"location":"guides/scenes/lifecycle-hooks/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Scene Transitions for smooth scene changes</li> <li>Explore ECS Systems to create custom game logic</li> <li>Check out the Manual Control Sample for complete examples</li> </ul>"},{"location":"guides/scenes/transitions/","title":"Scene Transitions","text":"<p>Scene transitions make your game feel polished by smoothly fading between scenes instead of abruptly switching. Brine2Dintroduces a powerful transition system with built-in effects and custom loading screens.</p>"},{"location":"guides/scenes/transitions/#why-use-transitions","title":"Why Use Transitions?","text":"<p>Transitions provide:</p> <ul> <li>Smooth visual experience</li> <li>Time to load heavy scenes</li> <li>Professional polish</li> <li>Progress feedback to players</li> </ul>"},{"location":"guides/scenes/transitions/#quick-start","title":"Quick Start","text":""},{"location":"guides/scenes/transitions/#basic-fade-transition","title":"Basic Fade Transition","text":"<pre><code>using Brine2D.Engine;\nusing Brine2D.Engine.Transitions;\n\npublic class MenuScene : Scene\n{\n    private readonly ISceneManager _sceneManager;\n\n    public MenuScene(ISceneManager sceneManager, ILogger&lt;MenuScene&gt; logger) : base(logger)\n    {\n        _sceneManager = sceneManager;\n    }\n\n    protected override void OnUpdate(GameTime gameTime)\n    {\n        if (_input.IsKeyPressed(Keys.Enter))\n        {\n            // Fade to game scene\n            await _sceneManager.LoadSceneAsync&lt;GameScene&gt;(\n                new FadeTransition(duration: 0.5f, color: Color.Black)\n            );\n        }\n    }\n}</code></pre> <p>That's it! The scene will fade out, load, and fade in automatically.</p>"},{"location":"guides/scenes/transitions/#fadetransition","title":"FadeTransition","text":"<p>The <code>FadeTransition</code> is the built-in transition effect that fades to a solid color.</p>"},{"location":"guides/scenes/transitions/#basic-usage","title":"Basic Usage","text":"<pre><code>// Black fade, 500ms\nvar transition = new FadeTransition(duration: 0.5f, color: Color.Black);\n\nawait _sceneManager.LoadSceneAsync&lt;GameScene&gt;(transition);</code></pre>"},{"location":"guides/scenes/transitions/#constructor-parameters","title":"Constructor Parameters","text":"Parameter Type Description Default <code>duration</code> <code>float</code> Total fade time (seconds) Required <code>color</code> <code>Color</code> Fade color Required"},{"location":"guides/scenes/transitions/#fade-colors","title":"Fade Colors","text":"<p>Choose a fade color that matches your game's aesthetic:</p> <pre><code>// Black fade (classic)\nnew FadeTransition(0.5f, Color.Black)\n\n// White fade (bright/dreamy)\nnew FadeTransition(0.5f, Color.White)\n\n// Color fade (thematic)\nnew FadeTransition(0.5f, new Color(50, 0, 100)) // Dark purple\n\n// Custom alpha (transparent fade)\nnew FadeTransition(0.5f, new Color(0, 0, 0, 128)) // Semi-transparent</code></pre>"},{"location":"guides/scenes/transitions/#timing","title":"Timing","text":"<p>Adjust duration based on scene complexity:</p> <pre><code>// Quick transition (UI screens)\nnew FadeTransition(0.3f, Color.Black)\n\n// Standard transition (most scenes)\nnew FadeTransition(0.5f, Color.Black)\n\n// Slow transition (dramatic moments)\nnew FadeTransition(1.0f, Color.Black)\n\n// Very slow (cinematic)\nnew FadeTransition(2.0f, Color.Black)</code></pre>"},{"location":"guides/scenes/transitions/#loading-screens","title":"Loading Screens","text":"<p>For scenes that take time to load, show a loading screen with progress feedback.</p>"},{"location":"guides/scenes/transitions/#basic-loading-screen","title":"Basic Loading Screen","text":"<pre><code>public class SimpleLoadingScreen : LoadingScene\n{\n    protected override void OnRender(GameTime gameTime)\n    {\n        // Progress is 0.0 to 1.0\n        _renderer.DrawText($\"Loading... {Progress:P0}\", 500, 300, Color.White);\n    }\n}\n\n// Use the loading screen\nawait _sceneManager.LoadSceneAsync&lt;GameScene&gt;(\n    loadingScreen: new SimpleLoadingScreen(),\n    transition: new FadeTransition(0.5f, Color.Black)\n);</code></pre>"},{"location":"guides/scenes/transitions/#advanced-loading-screen","title":"Advanced Loading Screen","text":"<p>Show detailed progress with a progress bar:</p> <pre><code>public class GameLoadingScreen : LoadingScene\n{\n    protected override void OnRender(GameTime gameTime)\n    {\n        var centerX = 640;\n        var centerY = 360;\n\n        // Title\n        _renderer.DrawText(\"Loading Game...\", centerX - 80, centerY - 50, Color.White);\n\n        // Progress percentage\n        _renderer.DrawText($\"{Progress:P0}\", centerX - 20, centerY, Color.White);\n\n        // Progress bar background\n        _renderer.DrawRectangleFilled(\n            centerX - 200, centerY + 40,\n            400, 30,\n            new Color(50, 50, 50)\n        );\n\n        // Progress bar fill\n        _renderer.DrawRectangleFilled(\n            centerX - 200, centerY + 40,\n            400 * Progress, 30,\n            new Color(0, 200, 0)\n        );\n\n        // Progress bar outline\n        _renderer.DrawRectangleOutline(\n            centerX - 200, centerY + 40,\n            400, 30,\n            Color.White, 2f\n        );\n\n        // Loading tip\n        _renderer.DrawText(\"Tip: Press F1 for help\", centerX - 100, centerY + 100, Color.Gray);\n    }\n}</code></pre>"},{"location":"guides/scenes/transitions/#animated-loading-screen","title":"Animated Loading Screen","text":"<p>Add animation for visual interest:</p> <pre><code>public class AnimatedLoadingScreen : LoadingScene\n{\n    private float _rotation = 0f;\n\n    protected override void OnUpdate(GameTime gameTime)\n    {\n        base.OnUpdate(gameTime);\n        _rotation += (float)gameTime.DeltaTime * 2f; // Rotate spinner\n    }\n\n    protected override void OnRender(GameTime gameTime)\n    {\n        var centerX = 640;\n        var centerY = 360;\n\n        // Draw spinning circle segments (pseudo-spinner)\n        for (int i = 0; i &lt; 8; i++)\n        {\n            var angle = _rotation + (i * MathF.PI / 4);\n            var x = centerX + MathF.Cos(angle) * 50;\n            var y = centerY + MathF.Sin(angle) * 50;\n            var alpha = (byte)(255 * (i / 8f));\n\n            _renderer.DrawCircleFilled(x, y, 5, new Color(255, 255, 255, alpha));\n        }\n\n        // Progress text\n        _renderer.DrawText($\"Loading... {Progress:P0}\", centerX - 80, centerY + 80, Color.White);\n    }\n}</code></pre>"},{"location":"guides/scenes/transitions/#loading-screen-with-assets","title":"Loading Screen with Assets","text":"<p>Load and display images/textures:</p> <pre><code>public class BrandedLoadingScreen : LoadingScene\n{\n    private ITexture? _logoTexture;\n\n    protected override async Task OnLoadAsync(CancellationToken cancellationToken)\n    {\n        // Load logo texture\n        _logoTexture = await _textureLoader.LoadTextureAsync(\n            \"assets/logo.png\",\n            TextureScaleMode.Nearest,\n            cancellationToken\n        );\n    }\n\n    protected override void OnRender(GameTime gameTime)\n    {\n        // Draw logo\n        if (_logoTexture != null)\n        {\n            _renderer.DrawTexture(_logoTexture, 540, 200, 200, 100);\n        }\n\n        // Progress bar\n        var barWidth = 400 * Progress;\n        _renderer.DrawRectangleFilled(440, 350, barWidth, 20, Color.Green);\n        _renderer.DrawRectangleOutline(440, 350, 400, 20, Color.White, 2f);\n\n        _renderer.DrawText($\"{Progress:P0}\", 620, 380, Color.White);\n    }\n}</code></pre>"},{"location":"guides/scenes/transitions/#scene-chaining","title":"Scene Chaining","text":"<p>Transition through multiple scenes in sequence.</p>"},{"location":"guides/scenes/transitions/#manual-chaining","title":"Manual Chaining","text":"<pre><code>public class IntroScene : Scene\n{\n    protected override async void OnUpdate(GameTime gameTime)\n    {\n        if (_input.IsKeyPressed(Keys.Enter))\n        {\n            // Intro \u2192 Tutorial \u2192 Game\n            await _sceneManager.LoadSceneAsync&lt;TutorialScene&gt;(\n                new FadeTransition(0.5f, Color.Black)\n            );\n        }\n    }\n}\n\npublic class TutorialScene : Scene\n{\n    protected override async void OnUpdate(GameTime gameTime)\n    {\n        if (_tutorialComplete)\n        {\n            await _sceneManager.LoadSceneAsync&lt;GameScene&gt;(\n                new FadeTransition(0.5f, Color.Black)\n            );\n        }\n    }\n}</code></pre>"},{"location":"guides/scenes/transitions/#automatic-chaining","title":"Automatic Chaining","text":"<p>Create a scene that auto-progresses:</p> <pre><code>public class SplashScreenScene : Scene\n{\n    private float _timer = 0f;\n    private const float DisplayTime = 3f;\n\n    protected override async void OnUpdate(GameTime gameTime)\n    {\n        _timer += (float)gameTime.DeltaTime;\n\n        if (_timer &gt;= DisplayTime)\n        {\n            // Automatically transition after 3 seconds\n            await _sceneManager.LoadSceneAsync&lt;MenuScene&gt;(\n                new FadeTransition(0.5f, Color.Black)\n            );\n        }\n    }\n\n    protected override void OnRender(GameTime gameTime)\n    {\n        _renderer.DrawText(\"Studio Logo Here\", 500, 300, Color.White);\n    }\n}</code></pre>"},{"location":"guides/scenes/transitions/#circular-chaining","title":"Circular Chaining","text":"<p>Loop through scenes (A \u2192 B \u2192 C \u2192 A):</p> <pre><code>public class SceneA : Scene\n{\n    protected override async void OnUpdate(GameTime gameTime)\n    {\n        if (_input.IsKeyPressed(Keys.Enter))\n        {\n            await _sceneManager.LoadSceneAsync&lt;SceneB&gt;(\n                new FadeTransition(0.5f, Color.Black)\n            );\n        }\n    }\n}\n\npublic class SceneB : Scene\n{\n    protected override async void OnUpdate(GameTime gameTime)\n    {\n        if (_input.IsKeyPressed(Keys.Enter))\n        {\n            await _sceneManager.LoadSceneAsync&lt;SceneC&gt;(\n                new FadeTransition(0.5f, Color.Blue)\n            );\n        }\n    }\n}\n\npublic class SceneC : Scene\n{\n    protected override async void OnUpdate(GameTime gameTime)\n    {\n        if (_input.IsKeyPressed(Keys.Enter))\n        {\n            // Back to A\n            await _sceneManager.LoadSceneAsync&lt;SceneA&gt;(\n                new FadeTransition(0.5f, Color.Red)\n            );\n        }\n    }\n}</code></pre>"},{"location":"guides/scenes/transitions/#transition-lifecycle","title":"Transition Lifecycle","text":"<p>Understanding what happens during a transition:</p> <pre><code>sequenceDiagram\n    participant Current Scene\n    participant Transition (Fade Out)\n    participant Loading Screen\n    participant New Scene\n    participant Transition (Fade In)\n\n    Current Scene-&gt;&gt;Transition (Fade Out): LoadSceneAsync called\n    Transition (Fade Out)-&gt;&gt;Transition (Fade Out): Fade to color (duration/2)\n    Transition (Fade Out)-&gt;&gt;Loading Screen: Show loading screen\n    Loading Screen-&gt;&gt;New Scene: Load scene async\n    Note over Loading Screen,New Scene: OnLoadAsync runs\n    New Scene--&gt;&gt;Loading Screen: Loading complete\n    Loading Screen-&gt;&gt;Transition (Fade In): Hide loading screen\n    Transition (Fade In)-&gt;&gt;Transition (Fade In): Fade from color (duration/2)\n    Transition (Fade In)-&gt;&gt;New Scene: Transition complete\n    Note over New Scene: OnInitialize runs</code></pre>"},{"location":"guides/scenes/transitions/#phase-breakdown","title":"Phase Breakdown","text":"Phase Duration What Happens Fade Out <code>duration / 2</code> Current scene fades to transition color Load Variable New scene's <code>OnLoadAsync</code> executes Loading Screen During load Progress updates, renders loading UI Fade In <code>duration / 2</code> New scene fades in from transition color Complete \u2014 New scene's <code>OnInitialize</code> runs"},{"location":"guides/scenes/transitions/#common-patterns","title":"Common Patterns","text":""},{"location":"guides/scenes/transitions/#return-to-menu","title":"Return to Menu","text":"<pre><code>public class GameScene : Scene\n{\n    protected override async void OnUpdate(GameTime gameTime)\n    {\n        if (_input.IsKeyPressed(Keys.Escape))\n        {\n            // Show confirmation dialog\n            var confirmed = await ShowConfirmDialog(\"Return to menu?\");\n\n            if (confirmed)\n            {\n                await _sceneManager.LoadSceneAsync&lt;MainMenuScene&gt;(\n                    new FadeTransition(0.5f, Color.Black)\n                );\n            }\n        }\n    }\n}</code></pre>"},{"location":"guides/scenes/transitions/#death-screen","title":"Death Screen","text":"<pre><code>public class GameScene : Scene\n{\n    protected override async void OnUpdate(GameTime gameTime)\n    {\n        if (_player.IsDead)\n        {\n            // Slow dramatic fade to death screen\n            await _sceneManager.LoadSceneAsync&lt;DeathScene&gt;(\n                new FadeTransition(2.0f, Color.Red)\n            );\n        }\n    }\n}</code></pre>"},{"location":"guides/scenes/transitions/#level-progression","title":"Level Progression","text":"<pre><code>public class Level1Scene : Scene\n{\n    protected override async void OnUpdate(GameTime gameTime)\n    {\n        if (_levelComplete)\n        {\n            await _sceneManager.LoadSceneAsync&lt;Level2Scene&gt;(\n                loadingScreen: new LevelLoadingScreen(\"Level 2\"),\n                transition: new FadeTransition(0.5f, Color.Black)\n            );\n        }\n    }\n}</code></pre>"},{"location":"guides/scenes/transitions/#save-and-quit","title":"Save and Quit","text":"<pre><code>public class GameScene : Scene\n{\n    protected override async void OnUpdate(GameTime gameTime)\n    {\n        if (_saveAndQuitRequested)\n        {\n            // Save game state\n            await SaveGameAsync();\n\n            // Return to menu with slow fade\n            await _sceneManager.LoadSceneAsync&lt;MainMenuScene&gt;(\n                loadingScreen: new SavingScreen(),\n                transition: new FadeTransition(1.0f, Color.Black)\n            );\n        }\n    }\n}</code></pre>"},{"location":"guides/scenes/transitions/#best-practices","title":"Best Practices","text":""},{"location":"guides/scenes/transitions/#dos","title":"Do's","text":"<p>\u2705 Use transitions for all scene changes - Consistency matters</p> <pre><code>// Good - always use transitions\nawait _sceneManager.LoadSceneAsync&lt;GameScene&gt;(\n    new FadeTransition(0.5f, Color.Black)\n);</code></pre> <p>\u2705 Match transition duration to load time</p> <pre><code>// Quick load \u2192 short transition\nawait _sceneManager.LoadSceneAsync&lt;MenuScene&gt;(\n    new FadeTransition(0.3f, Color.Black)\n);\n\n// Heavy load \u2192 use loading screen\nawait _sceneManager.LoadSceneAsync&lt;GameScene&gt;(\n    loadingScreen: new GameLoadingScreen(),\n    transition: new FadeTransition(0.5f, Color.Black)\n);</code></pre> <p>\u2705 Use thematic colors</p> <pre><code>// Red fade for danger/death\nnew FadeTransition(1.0f, Color.Red)\n\n// Blue fade for water levels\nnew FadeTransition(0.5f, new Color(0, 100, 200))\n\n// White fade for bright/happy moments\nnew FadeTransition(0.5f, Color.White)</code></pre> <p>\u2705 Show progress for long loads</p> <pre><code>await _sceneManager.LoadSceneAsync&lt;GameScene&gt;(\n    loadingScreen: new DetailedLoadingScreen(),\n    transition: new FadeTransition(0.5f, Color.Black)\n);</code></pre>"},{"location":"guides/scenes/transitions/#donts","title":"Don'ts","text":"<p>\u274c Don't make transitions too fast</p> <pre><code>// Bad - too jarring\nnew FadeTransition(0.1f, Color.Black) // Feels broken</code></pre> <p>\u274c Don't make transitions too slow</p> <pre><code>// Bad - frustrating for players\nnew FadeTransition(5.0f, Color.Black) // Way too long</code></pre> <p>\u274c Don't skip transitions for important moments</p> <pre><code>// Bad - no transition for game over\nawait _sceneManager.LoadSceneAsync&lt;GameOverScene&gt;(); // Jarring</code></pre> <p>\u274c Don't load heavy assets in loading screen</p> <pre><code>// Bad - defeats the purpose\npublic class LoadingScreen : LoadingScene\n{\n    protected override async Task OnLoadAsync(CancellationToken ct)\n    {\n        // DON'T load heavy assets here!\n        await LoadGiantTextureAsync(); // Wrong place!\n    }\n}</code></pre>"},{"location":"guides/scenes/transitions/#performance-tips","title":"Performance Tips","text":""},{"location":"guides/scenes/transitions/#optimize-scene-loading","title":"Optimize Scene Loading","text":"<pre><code>public class GameScene : Scene\n{\n    protected override async Task OnLoadAsync(CancellationToken ct)\n    {\n        // Load critical assets first (shown during loading screen)\n        await LoadEssentialAssetsAsync(ct);\n\n        // Load optional assets after scene is visible\n        _ = Task.Run(async () =&gt;\n        {\n            await LoadOptionalAssetsAsync(ct);\n        });\n    }\n}</code></pre>"},{"location":"guides/scenes/transitions/#preload-next-scene","title":"Preload Next Scene","text":"<pre><code>public class MenuScene : Scene\n{\n    protected override async Task OnLoadAsync(CancellationToken ct)\n    {\n        // Preload game scene in background\n        _ = Task.Run(async () =&gt;\n        {\n            await PreloadAssetsForScene&lt;GameScene&gt;(ct);\n        });\n    }\n}</code></pre>"},{"location":"guides/scenes/transitions/#unload-previous-scene-assets","title":"Unload Previous Scene Assets","text":"<pre><code>public class GameScene : Scene\n{\n    protected override async Task OnUnloadAsync(CancellationToken ct)\n    {\n        // Clean up to free memory\n        UnloadTextures();\n        UnloadSounds();\n\n        await base.OnUnloadAsync(ct);\n    }\n}</code></pre>"},{"location":"guides/scenes/transitions/#see-it-in-action","title":"See It In Action","text":"<p>Check out the Scene Transitions Demo in FeatureDemos!</p> <pre><code>cd samples/FeatureDemos\ndotnet run\n# Select \"4\" for Scene Transitions Demo</code></pre> <p>The demo shows: - Basic fade transitions - Scene chaining (A \u2192 B \u2192 C \u2192 A) - Loading screen example - Different fade colors - Transition timing</p>"},{"location":"guides/scenes/transitions/#api-reference","title":"API Reference","text":""},{"location":"guides/scenes/transitions/#iscenemanagerloadsceneasync","title":"ISceneManager.LoadSceneAsync","text":"<pre><code>Task LoadSceneAsync&lt;TScene&gt;(\n    ITransition? transition = null,\n    LoadingScene? loadingScreen = null\n) where TScene : Scene</code></pre> <p>Parameters: - <code>transition</code> - Transition effect (e.g., <code>FadeTransition</code>) - <code>loadingScreen</code> - Loading screen scene (optional)</p> <p>Returns: <code>Task</code> that completes when transition finishes</p>"},{"location":"guides/scenes/transitions/#fadetransition-constructor","title":"FadeTransition Constructor","text":"<pre><code>public FadeTransition(float duration, Color color)</code></pre> <p>Parameters: - <code>duration</code> - Total fade time in seconds (both fade out and in) - <code>color</code> - Color to fade to/from</p>"},{"location":"guides/scenes/transitions/#loadingscene","title":"LoadingScene","text":"<p>Base class for custom loading screens:</p> <pre><code>public abstract class LoadingScene : Scene\n{\n    protected float Progress { get; } // 0.0 to 1.0\n\n    protected override void OnRender(GameTime gameTime)\n    {\n        // Draw loading UI\n    }\n}</code></pre>"},{"location":"guides/scenes/transitions/#next-steps","title":"Next Steps","text":"<ul> <li> <p>Scene Lifecycle</p> <p>Understanding scene lifecycle methods</p> <p> Lifecycle Guide</p> </li> <li> <p>Lifecycle Hooks</p> <p>Automatic vs manual scene control</p> <p> Hooks Guide</p> </li> <li> <p>FeatureDemos</p> <p>See transitions in action</p> <p> View Demos</p> </li> </ul> <p>Remember: Good transitions make your game feel polished and professional. Use them everywhere!</p>"},{"location":"samples/","title":"Samples","text":"<p>Learn by example! The Brine2D samples demonstrate real-world usage of the engine's features. Each sample is a complete, runnable project that showcases specific functionality.</p>"},{"location":"samples/#featuredemos","title":"FeatureDemos","text":"<p>Location: <code>samples/FeatureDemos/</code> Difficulty: Beginner to Advanced Topics Covered: ECS Queries, Particles, Collision, Scene Transitions, UI, Manual Control</p> <p>The FeatureDemos project is an interactive showcase of Brine2D's major features. Run the project to see a menu-driven demo selector where you can explore each feature independently.</p> <pre><code>graph TD\n    A[\"FeatureDemos Project\"] --&gt; B[\"MainMenuScene\"]\n    B --&gt; C[\"Query System Demo\"]\n    B --&gt; D[\"Particle System Demo\"]\n    B --&gt; E[\"Collision Demo\"]\n    B --&gt; F[\"Scene Transitions Demo\"]\n    B --&gt; G[\"UI Components Demo\"]\n    B --&gt; H[\"Manual Control Demo\"]\n\n    C --&gt; I[\"Fluent Query API\"]\n    C --&gt; J[\"Cached Queries\"]\n    C --&gt; K[\"Complex Filters\"]\n\n    D --&gt; L[\"GPU Particles\"]\n    D --&gt; M[\"Emitter Systems\"]\n    D --&gt; N[\"Performance\"]\n\n    E --&gt; O[\"AABB Colliders\"]\n    E --&gt; P[\"Circle Colliders\"]\n    E --&gt; Q[\"Physics Response\"]\n\n    F --&gt; R[\"FadeTransition\"]\n    F --&gt; S[\"Loading Screens\"]\n    F --&gt; T[\"Scene Chaining\"]\n\n    G --&gt; U[\"Complete UI Library\"]\n    G --&gt; V[\"Tooltips &amp; Dialogs\"]\n    G --&gt; W[\"Input Layers\"]\n\n    H --&gt; X[\"Lifecycle Hooks\"]\n    H --&gt; Y[\"Manual Pipelines\"]\n    H --&gt; Z[\"Power User Features\"]\n\n    style A fill:#1e3a5f,stroke:#569cd6,stroke-width:2px,color:#fff\n    style B fill:#2d5016,stroke:#4ec9b0,stroke-width:2px,color:#fff\n    style C fill:#4a2d4a,stroke:#c586c0,stroke-width:2px,color:#fff\n    style D fill:#4a2d4a,stroke:#c586c0,stroke-width:2px,color:#fff\n    style E fill:#4a2d4a,stroke:#c586c0,stroke-width:2px,color:#fff\n    style F fill:#4a2d4a,stroke:#c586c0,stroke-width:2px,color:#fff\n    style G fill:#4a2d4a,stroke:#c586c0,stroke-width:2px,color:#fff\n    style H fill:#4a2d4a,stroke:#c586c0,stroke-width:2px,color:#fff\n    style I fill:#3d3d2a,stroke:#dcdcaa,stroke-width:2px,color:#fff\n    style J fill:#3d3d2a,stroke:#dcdcaa,stroke-width:2px,color:#fff\n    style K fill:#3d3d2a,stroke:#dcdcaa,stroke-width:2px,color:#fff\n    style L fill:#3d3d2a,stroke:#dcdcaa,stroke-width:2px,color:#fff\n    style M fill:#3d3d2a,stroke:#dcdcaa,stroke-width:2px,color:#fff\n    style N fill:#3d3d2a,stroke:#dcdcaa,stroke-width:2px,color:#fff\n    style O fill:#3d3d2a,stroke:#dcdcaa,stroke-width:2px,color:#fff\n    style P fill:#3d3d2a,stroke:#dcdcaa,stroke-width:2px,color:#fff\n    style Q fill:#3d3d2a,stroke:#dcdcaa,stroke-width:2px,color:#fff\n    style R fill:#3d3d2a,stroke:#dcdcaa,stroke-width:2px,color:#fff\n    style S fill:#3d3d2a,stroke:#dcdcaa,stroke-width:2px,color:#fff\n    style T fill:#3d3d2a,stroke:#dcdcaa,stroke-width:2px,color:#fff\n    style U fill:#3d3d2a,stroke:#dcdcaa,stroke-width:2px,color:#fff\n    style V fill:#3d3d2a,stroke:#dcdcaa,stroke-width:2px,color:#fff\n    style W fill:#3d3d2a,stroke:#dcdcaa,stroke-width:2px,color:#fff\n    style X fill:#3d3d2a,stroke:#dcdcaa,stroke-width:2px,color:#fff\n    style Y fill:#3d3d2a,stroke:#dcdcaa,stroke-width:2px,color:#fff\n    style Z fill:#3d3d2a,stroke:#dcdcaa,stroke-width:2px,color:#fff</code></pre>"},{"location":"samples/#demo-scenes","title":"Demo Scenes","text":"Demo Description Key Features Category Query System Advanced entity queries Fluent API, cached queries, complex filters ECS Particle System GPU-accelerated particles 10,000+ particles, emitters, performance ECS Collision Detection Physics and collision AABB/circle colliders, bounce, slide, push Collision Scene Transitions Smooth scene changes FadeTransition, loading screens, async loading Transitions UI Components Complete UI showcase All 15+ components, tooltips, dialogs, tabs UI Manual Control Power user features Opt-out of automatic execution, custom pipelines Advanced"},{"location":"samples/#running-the-demos","title":"Running the Demos","text":""},{"location":"samples/#prerequisites","title":"Prerequisites","text":"<ul> <li>.NET 10 SDK</li> <li>Visual Studio 2022 or VS Code</li> <li>SDL3 (auto-installed via NuGet)</li> </ul>"},{"location":"samples/#option-1-run-from-visual-studio","title":"Option 1: Run from Visual Studio","text":"<ol> <li>Open <code>Brine2D.sln</code> in Visual Studio</li> <li>Set <code>FeatureDemos</code> as startup project</li> <li>Press F5 to run</li> <li>Select a demo from the menu</li> </ol>"},{"location":"samples/#option-2-run-from-command-line","title":"Option 2: Run from Command Line","text":"<pre><code>cd samples/FeatureDemos\ndotnet run</code></pre>"},{"location":"samples/#navigation","title":"Navigation","text":"<ul> <li>Use number keys (1-6) to select a demo</li> <li>ESC returns to menu from any demo</li> <li>F1/F2 toggle debug options in some demos</li> </ul>"},{"location":"samples/#demo-deep-dive","title":"Demo Deep Dive","text":""},{"location":"samples/#1-query-system-demo","title":"1. Query System Demo","text":"<p>What it demonstrates: - Fluent query API for complex entity searches - Cached queries for performance - Multiple filter conditions (<code>With</code>, <code>Without</code>, <code>Where</code>) - Real-time entity statistics</p> <p>Controls: - SPACE - Spawn entities - C - Clear entities - ESC - Return to menu</p> <p>Key Code:</p> <pre><code>// Find low-health enemies near the player\nvar weakEnemies = _world.Query()\n    .With&lt;HealthComponent&gt;()\n    .With&lt;TransformComponent&gt;()\n    .Without&lt;DeadComponent&gt;()\n    .WithTag(\"Enemy\")\n    .Where(e =&gt; \n    {\n        var health = e.GetComponent&lt;HealthComponent&gt;();\n        var transform = e.GetComponent&lt;TransformComponent&gt;();\n        var distance = Vector2.Distance(transform.Position, playerPos);\n\n        return health.CurrentHealth &lt; 50 &amp;&amp; distance &lt; 200f;\n    })\n    .Execute();\n\n// Cached queries (no allocation!)\nvar movingEntities = _world.CreateCachedQuery&lt;TransformComponent, VelocityComponent&gt;();\nforeach (var (transform, velocity) in movingEntities)\n{\n    transform.Position += velocity.Velocity * deltaTime;\n}</code></pre>"},{"location":"samples/#2-particle-system-demo","title":"2. Particle System Demo","text":"<p>What it demonstrates: - GPU-accelerated particle rendering - 10,000+ particles at 60 FPS - Multiple emitter types - Particle lifetime and physics - Performance monitoring</p> <p>Controls: - SPACE - Toggle emission - 1-3 - Change emitter type - ESC - Return to menu</p> <p>Key Code:</p> <pre><code>// Create particle emitter\nvar emitter = entity.AddComponent&lt;ParticleEmitterComponent&gt;();\nemitter.EmissionRate = 100;\nemitter.Lifetime = 2f;\nemitter.StartColor = Color.Red;\nemitter.EndColor = new Color(255, 0, 0, 0);\nemitter.StartSpeed = 100f;\nemitter.SpreadAngle = MathF.PI / 4;</code></pre>"},{"location":"samples/#3-collision-detection-demo","title":"3. Collision Detection Demo","text":"<p>What it demonstrates: - AABB (box) and circle colliders - Collision detection with <code>CollisionSystem</code> - Physics response: bounce, slide, push - Dynamic vs static objects - Trigger colliders (collectibles) - Debug visualization</p> <p>Controls: - WASD - Move player - R - Kick ball (when nearby) - F1 - Toggle collider visualization - F2 - Toggle velocity vectors - SPACE - Reset scene - ESC - Return to menu</p> <p>Key Code:</p> <pre><code>// Player slides along walls\nvar newPosition = _playerPosition + moveVector;\n_playerCollider.Position = newPosition;\n\nvar collisions = _collisionSystem.GetCollisions(_playerCollider);\nif (collisions.Any(c =&gt; _walls.Contains(c)))\n{\n    // Try sliding along X axis\n    var slideX = _playerPosition + new Vector2(moveVector.X, 0);\n    _playerCollider.Position = slideX;\n\n    if (!_collisionSystem.GetCollisions(_playerCollider).Any())\n    {\n        _playerPosition = slideX;\n    }\n}\n\n// Ball bounces with physics\n_ballVelocity = CollisionResponse.Bounce(_ballVelocity, penetration, 0.7f);</code></pre>"},{"location":"samples/#4-scene-transitions-demo","title":"4. Scene Transitions Demo","text":"<p>What it demonstrates: - <code>FadeTransition</code> between scenes - Custom loading screens with progress bars - Async scene loading - Scene chaining (A \u2192 B \u2192 C \u2192 A) - Transition customization (duration, color)</p> <p>Controls: - ENTER - Go to next scene - Number keys - Jump to specific scene - ESC - Return to menu</p> <p>Key Code:</p> <pre><code>// Fade transition\nawait _sceneManager.LoadSceneAsync&lt;SceneB&gt;(\n    new FadeTransition(duration: 0.5f, color: Color.Black)\n);\n\n// Custom loading screen\npublic class CustomLoadingScreen : LoadingScene\n{\n    protected override void OnRender(GameTime gameTime)\n    {\n        _renderer.DrawText($\"Loading... {Progress:P0}\", 500, 300, Color.White);\n        _renderer.DrawRectangleFilled(400, 350, Progress * 400, 20, Color.Green);\n    }\n}\n\nawait _sceneManager.LoadSceneAsync&lt;GameScene&gt;(\n    loadingScreen: new CustomLoadingScreen(),\n    transition: new FadeTransition(0.5f, Color.Black)\n);</code></pre>"},{"location":"samples/#5-ui-components-demo","title":"5. UI Components Demo","text":"<p>What it demonstrates: - Complete UI library - All 15+ components - Buttons, labels, text inputs - Sliders, checkboxes, radio buttons - Progress bars, dropdowns - Tab containers, scroll views - Dialogs with multiple buttons - Tooltips on hover - Input layer management</p> <p>Controls: - Mouse - Interact with all UI elements - TAB - Navigate between inputs - ESC - Return to menu</p> <p>Components Showcased:</p> Component Demo Feature <code>UILabel</code> Title, status messages <code>UIButton</code> Click counter, actions <code>UITextInput</code> Name entry with placeholder <code>UISlider</code> Volume control (0-100) <code>UIProgressBar</code> Health bar with +/- buttons <code>UIDropdown</code> Graphics quality selector <code>UICheckbox</code> Sound/VSync toggles <code>UIRadioButton</code> Difficulty selection <code>UITabContainer</code> Settings organization <code>UIScrollView</code> 25-item scrollable list <code>UIDialog</code> Confirmation popups <code>UITooltip</code> Hover help text <code>UIPanel</code> Visual grouping <p>Key Code:</p> <pre><code>// Button with event\nvar button = new UIButton(\"Click Me!\", pos, size);\nbutton.OnClick += () =&gt; Logger.LogInformation(\"Clicked!\");\n_uiCanvas.Add(button);\n\n// Slider with value display\nvar slider = new UISlider(pos, size)\n{\n    MinValue = 0f,\n    MaxValue = 100f,\n    Value = 75f,\n    ShowValue = true,\n    Tooltip = new UITooltip(\"Adjust volume\")\n};\nslider.OnValueChanged += (value) =&gt; Logger.LogDebug(\"Volume: {Volume}\", value);\n_uiCanvas.Add(slider);\n\n// Dialog with multiple buttons\nvar dialog = new UIDialog(\"Confirm\", \"Are you sure?\", new Vector2(400, 250));\ndialog.AddButton(\"Yes\", () =&gt; dialog.Visible = false);\ndialog.AddButton(\"No\", () =&gt; dialog.Visible = false);\n_uiCanvas.Add(dialog);</code></pre>"},{"location":"samples/#6-manual-control-demo","title":"6. Manual Control Demo","text":"<p>What it demonstrates: - Opt-out of automatic execution - Manual pipeline control - Manual frame management - When and why to use manual control - Power user scenarios (fixed timestep, conditional execution)</p> <p>Controls: - ESC - Return to menu</p> <p>Key Code:</p> <pre><code>public class ManualControlScene : Scene\n{\n    public override bool EnableLifecycleHooks =&gt; false; // Disable automatic execution\n    public override bool EnableAutomaticFrameManagement =&gt; false; // Full manual control\n\n    protected override void OnUpdate(GameTime gameTime)\n    {\n        // You control when systems run\n        _updatePipeline.Execute(gameTime);\n        _world.Update(gameTime);\n    }\n\n    protected override void OnRender(GameTime gameTime)\n    {\n        // You control frame management\n        _renderer.Clear(Color.Black);\n        _renderer.BeginFrame();\n\n        _renderPipeline.Execute(_renderer);\n\n        _renderer.EndFrame();\n    }\n}</code></pre> <p>See Lifecycle Hooks Guide for full documentation.</p>"},{"location":"samples/#project-structure","title":"Project Structure","text":"<pre><code>FeatureDemos/\n\u251c\u2500\u2500 Scenes/\n\u2502   \u251c\u2500\u2500 MainMenuScene.cs           # Interactive demo selector\n\u2502   \u251c\u2500\u2500 DemoSceneBase.cs           # Shared base class\n\u2502   \u251c\u2500\u2500 ECS/\n\u2502   \u2502   \u251c\u2500\u2500 QueryDemoScene.cs      # Query system showcase\n\u2502   \u2502   \u2514\u2500\u2500 ParticleDemoScene.cs   # Particle effects\n\u2502   \u251c\u2500\u2500 Collision/\n\u2502   \u2502   \u2514\u2500\u2500 CollisionDemoScene.cs  # Physics demo\n\u2502   \u251c\u2500\u2500 Transitions/\n\u2502   \u2502   \u251c\u2500\u2500 TransitionDemoScene.cs # Transition showcase\n\u2502   \u2502   \u251c\u2500\u2500 SceneA.cs              # Chain scene A\n\u2502   \u2502   \u251c\u2500\u2500 SceneB.cs              # Chain scene B\n\u2502   \u2502   \u2514\u2500\u2500 SceneC.cs              # Chain scene C\n\u2502   \u251c\u2500\u2500 UI/\n\u2502   \u2502   \u2514\u2500\u2500 UIDemoScene.cs         # Complete UI showcase\n\u2502   \u2514\u2500\u2500 Advanced/\n\u2502       \u2514\u2500\u2500 ManualControlScene.cs  # Power user demo\n\u251c\u2500\u2500 Program.cs                      # Entry point\n\u251c\u2500\u2500 gamesettings.json               # Configuration\n\u2514\u2500\u2500 FeatureDemos.csproj             # Project file</code></pre>"},{"location":"samples/#configuration","title":"Configuration","text":"<pre><code>{\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Information\",\n      \"Brine2D\": \"Debug\"\n    }\n  },\n  \"Rendering\": {\n    \"WindowTitle\": \"Brine2D Feature Demos\",\n    \"WindowWidth\": 1280,\n    \"WindowHeight\": 720,\n    \"VSync\": true,\n    \"Backend\": \"GPU\"\n  }\n}</code></pre>"},{"location":"samples/#dependency-injection-setup","title":"Dependency Injection Setup","text":"<p>FeatureDemos demonstrates complete service configuration:</p> <pre><code>var builder = GameApplication.CreateBuilder(args);\n\n// Core services\nbuilder.Services.AddSDL3Rendering(options =&gt;\n{\n    builder.Configuration.GetSection(\"Rendering\").Bind(options);\n});\nbuilder.Services.AddInputLayerManager().AddSDL3Input();\nbuilder.Services.AddSDL3Audio();\n\n// ECS and systems\nbuilder.Services.AddCollisionSystem();\nbuilder.Services.AddUICanvas();\n\n// Register all demo scenes\nbuilder.Services.AddScene&lt;MainMenuScene&gt;();\nbuilder.Services.AddScene&lt;QueryDemoScene&gt;();\nbuilder.Services.AddScene&lt;ParticleDemoScene&gt;();\nbuilder.Services.AddScene&lt;CollisionDemoScene&gt;();\nbuilder.Services.AddScene&lt;TransitionDemoScene&gt;();\nbuilder.Services.AddScene&lt;UIDemoScene&gt;();\nbuilder.Services.AddScene&lt;ManualControlScene&gt;();\n\nvar game = builder.Build();\nawait game.RunAsync&lt;MainMenuScene&gt;();</code></pre>"},{"location":"samples/#learning-path","title":"Learning Path","text":"<p>We recommend exploring the demos in this order:</p> <ol> <li>Query System - Understand ECS queries (if using ECS)</li> <li>Collision Detection - Learn physics and collision response</li> <li>UI Components - Master the UI framework</li> <li>Scene Transitions - Build polished scene changes</li> <li>Particle System - Add visual effects</li> <li>Manual Control - Advanced power user techniques</li> </ol>"},{"location":"samples/#using-demos-as-templates","title":"Using Demos as Templates","text":"<p>The demo code is production-ready and designed to be copied:</p> <ol> <li>Copy a scene class - Use as a starting point</li> <li>Modify for your game - Change colors, sizes, behaviors</li> <li>Extract patterns - Query builders, UI layouts, collision response</li> <li>Build on top - Extend with your own features</li> </ol>"},{"location":"samples/#troubleshooting","title":"Troubleshooting","text":""},{"location":"samples/#menu-doesnt-appear","title":"Menu doesn't appear?","text":"<ul> <li>Check that <code>MainMenuScene</code> is registered</li> <li>Verify <code>game.RunAsync&lt;MainMenuScene&gt;()</code> is called</li> </ul>"},{"location":"samples/#demo-crashes-on-load","title":"Demo crashes on load?","text":"<ul> <li>Check console for missing dependencies</li> <li>Verify all scenes are registered in DI</li> <li>Try running from Visual Studio with debugger</li> </ul>"},{"location":"samples/#performance-issues","title":"Performance issues?","text":"<ul> <li>Enable VSync in <code>gamesettings.json</code></li> <li>Check particle count in Particle Demo (reduce if needed)</li> <li>Review logging level (set to <code>Information</code>)</li> </ul>"},{"location":"samples/#next-steps","title":"Next Steps","text":"<p>After exploring the demos:</p> <ul> <li>Guides - Deep dive into specific features</li> <li>Tutorials - Build complete games step-by-step</li> <li>Lifecycle Hooks - Advanced manual control</li> <li>ECS Queries - Master the query system</li> </ul> <p>Ready to explore? Clone the repository and run the demos:</p> <pre><code>git clone https://github.com/CrazyPickleStudios/Brine2D.git\ncd Brine2D/samples/FeatureDemos\ndotnet run</code></pre> <p>Press 1-6 to explore each demo!</p> <p>Happy coding!</p>"},{"location":"tutorials/","title":"Tutorials","text":"<p>Welcome to the Brine2D tutorials! These hands-on guides will take you from basic concepts to building complete game systems. Each tutorial includes working code examples and explains the \"why\" behind each step.</p>"},{"location":"tutorials/#learning-path","title":"Learning Path","text":"<p>We recommend following these tutorials in order, but feel free to jump to topics that interest you most.</p> <pre><code>graph LR\n    A[\"Moving Sprites\"] --&gt; B[\"Animation System\"]\n    B --&gt; C[\"Collision Detection\"]\n    C --&gt; D[\"Platformer\"]\n    C --&gt; E[\"Top-Down Adventure\"]\n\n    style A fill:#1e3a5f,stroke:#569cd6,stroke-width:2px,color:#fff\nstyle B fill:#2d5016,stroke:#4ec9b0,stroke-width:2px,color:#fff\nstyle C fill:#2d5016,stroke:#4ec9b0,stroke-width:2px,color:#fff\nstyle D fill:#2d5016,stroke:#4ec9b0,stroke-width:2px,color:#fff\nstyle E fill:#2d5016,stroke:#4ec9b0,stroke-width:2px,color:#fff</code></pre>"},{"location":"tutorials/#available-tutorials","title":"Available Tutorials","text":""},{"location":"tutorials/#moving-sprites","title":"Moving Sprites","text":"<p>Difficulty: Beginner | Time: 15 minutes</p> <p>Learn the fundamentals of sprite rendering in Brine2D. You'll load textures, draw sprites, and create smooth movement with delta time.</p> <p>What you'll learn:</p> <ul> <li>Loading textures with <code>ITextureLoader</code></li> <li>Drawing sprites at screen positions</li> <li>Handling keyboard input for movement</li> <li>Using delta time for frame-rate independent motion</li> <li>Working with <code>Vector2</code> for positions</li> </ul> <p>Prerequisites: Completed Quick Start</p>"},{"location":"tutorials/#animation-system","title":"Animation System","text":"<p>Difficulty: Beginner | Time: 20 minutes</p> <p>Master Brine2D's sprite animation system. Create walking, running, and action animations from sprite sheets.</p> <p>What you'll learn:</p> <ul> <li>Loading sprite sheets</li> <li>Creating <code>AnimationClip</code> objects</li> <li>Using <code>SpriteAnimator</code> to play animations</li> <li>Switching between animations (walk, run, jump)</li> <li>Controlling animation speed and looping</li> </ul> <p>Prerequisites: Moving Sprites</p> <p>Key Concepts:</p> <ul> <li>Sprite sheets and frame extraction</li> <li>Animation clips with multiple frames</li> <li>Frame duration and timing</li> <li>Looping vs one-shot animations</li> </ul>"},{"location":"tutorials/#collision-detection","title":"Collision Detection","text":"<p>Difficulty: Intermediate | Time: 30 minutes</p> <p>Implement collision detection and response using Brine2D's collision system. Build interactive objects and solid walls.</p> <p>What you'll learn:</p> <ul> <li>Understanding <code>CollisionSystem</code></li> <li>Creating <code>BoxCollider</code> and <code>CircleCollider</code> shapes</li> <li>Detecting collisions between objects</li> <li>Implementing collision response (blocking, sliding)</li> <li>Building a coin collection system</li> </ul> <p>Prerequisites: Animation System</p> <p>Key Concepts:</p> <ul> <li>Collision shapes (boxes and circles)</li> <li>Collision detection algorithms</li> <li>Separation and penetration</li> <li>Trigger vs solid collisions</li> </ul>"},{"location":"tutorials/#building-a-platformer","title":"Building a Platformer","text":"<p>Difficulty: Intermediate | Time: 45 minutes</p> <p>Create a complete 2D platformer with jumping, gravity, and platform collision. This tutorial combines everything you've learned.</p> <p>What you'll learn:</p> <ul> <li>Implementing gravity and jumping</li> <li>Platform collision (top-only platforms)</li> <li>Tilemap loading with Tiled</li> <li>Camera following the player</li> <li>Parallax scrolling backgrounds</li> <li>Game state management (lives, score)</li> </ul> <p>Prerequisites: Collision Detection</p> <p>Covers:</p> <ul> <li>Physics simulation (gravity, velocity, acceleration)</li> <li>Tilemap rendering and collision</li> <li>Camera systems with <code>Camera2D</code></li> <li>Scene management for multiple levels</li> </ul>"},{"location":"tutorials/#top-down-adventure","title":"Top-Down Adventure","text":"<p>Difficulty: Intermediate | Time: 45 minutes</p> <p>Build a top-down adventure game with 8-directional movement, NPCs, and dialogue. Perfect for RPG-style games.</p> <p>What you'll learn:</p> <ul> <li>8-directional movement and animation</li> <li>NPC interaction system</li> <li>Dialogue boxes with text rendering</li> <li>Inventory management</li> <li>Tilemap-based world design</li> <li>Trigger zones and events</li> </ul> <p>Prerequisites: Collision Detection</p> <p>Covers:</p> <ul> <li>Grid-based movement</li> <li>State machines for NPCs</li> <li>UI system for dialogue</li> <li>Event-driven interactions</li> </ul>"},{"location":"tutorials/#tutorial-code","title":"Tutorial Code","text":"<p>All tutorial code is available in the samples/BasicGame directory:</p> <ul> <li><code>AnimationDemoScene.cs</code> - Animation system demo</li> <li><code>CameraDemoScene.cs</code> - Camera following and zoom</li> <li><code>CollisionDemoScene.cs</code> - Collision detection and UI</li> </ul> <p>You can run these demos to see the final results before starting each tutorial.</p>"},{"location":"tutorials/#tips-for-learning","title":"Tips for Learning","text":""},{"location":"tutorials/#1-run-the-code-first","title":"1. Run the Code First","text":"<p>Before reading each tutorial, run the demo scene to see what you're building. Understanding the end goal helps you learn faster.</p>"},{"location":"tutorials/#2-experiment-and-break-things","title":"2. Experiment and Break Things","text":"<p>After completing a tutorial, modify the code: - Change animation speeds - Add more collision objects - Adjust physics parameters</p> <p>Breaking things teaches you how they work!</p>"},{"location":"tutorials/#3-use-the-logger","title":"3. Use the Logger","text":"<p>Brine2D uses <code>ILogger&lt;T&gt;</code> for debugging. Add log messages to understand execution flow:</p> <pre><code>Logger.LogInformation(\"Player collided with {Object}\", collision.Name);</code></pre>"},{"location":"tutorials/#4-read-the-api-docs","title":"4. Read the API Docs","text":"<p>Each tutorial references API documentation. Open them side-by-side: - Core API - Rendering API - Input API</p>"},{"location":"tutorials/#5-ask-questions","title":"5. Ask Questions","text":"<p>Stuck? Check out: - Common Issues - GitHub Discussions - Discord Community (coming soon)</p>"},{"location":"tutorials/#after-the-tutorials","title":"After the Tutorials","text":"<p>Once you've completed these tutorials, you'll be ready to:</p> <ol> <li>Build Your Own Game - You have all the tools!</li> <li>Explore Advanced Guides - Check out Guides for deeper topics</li> <li>Study the Samples - See Samples for complete game examples</li> <li>Contribute - Help improve Brine2D! See Contributing</li> </ol>"},{"location":"tutorials/#whats-included-in-each-tutorial","title":"What's Included in Each Tutorial","text":"<p>Every tutorial follows the same structure:</p> Section Description Overview What you'll build and why it matters Prerequisites What you need to know first Setup Project setup and dependencies Step-by-Step Guided implementation with explanations Complete Code Full working example Challenges Exercises to extend what you learned Next Steps Where to go from here"},{"location":"tutorials/#ready-to-start","title":"Ready to Start?","text":"<p>Jump into Moving Sprites to begin your Brine2D journey, or pick any tutorial that interests you!</p> <p>Happy game dev!</p>"},{"location":"tutorials/animations/","title":"Animation System","text":"<p>Difficulty: Beginner | Time: 20 minutes</p> <p>Learn how to bring your sprites to life with Brine2D's animation system. By the end of this tutorial, you'll have a character with multiple animations (walk, run, jump) that you can switch between.</p>"},{"location":"tutorials/animations/#what-youll-build","title":"What You'll Build","text":"<p>An animated character with: - Multiple animation clips (walk, run, idle, jump) - Smooth frame-by-frame animation - Animation switching with keyboard input - Pause/resume controls - Configurable animation speeds</p>"},{"location":"tutorials/animations/#prerequisites","title":"Prerequisites","text":"<ul> <li>Completed Moving Sprites tutorial</li> <li>A sprite sheet image (or use placeholder)</li> <li>Understanding of sprite rendering and delta time</li> </ul>"},{"location":"tutorials/animations/#understanding-sprite-sheets","title":"Understanding Sprite Sheets","text":"<p>A sprite sheet is a single image containing multiple animation frames arranged in a grid.</p>"},{"location":"tutorials/animations/#visual-layout","title":"Visual Layout","text":"<p>Here's what a 576x24 pixel sprite sheet with 24 frames looks like:</p> <pre><code>graph LR\n    subgraph \"character.png (576x24 pixels)\"\n        F0[\"Frame 0&lt;br/&gt;Walk 1&lt;br/&gt;24x24\"]\n        F1[\"Frame 1&lt;br/&gt;Walk 2&lt;br/&gt;24x24\"]\n        F2[\"Frame 2&lt;br/&gt;Walk 3&lt;br/&gt;24x24\"]\n        F3[\"Frame 3&lt;br/&gt;Walk 4&lt;br/&gt;24x24\"]\n        F4[\"Frame 4&lt;br/&gt;Run 1&lt;br/&gt;24x24\"]\n        F5[\"Frame 5&lt;br/&gt;Run 2&lt;br/&gt;24x24\"]\n        F6[\"...\"]\n        F23[\"Frame 23&lt;br/&gt;24x24\"]\n\n        F0 --- F1\n        F1 --- F2\n        F2 --- F3\n        F3 --- F4\n        F4 --- F5\n        F5 --- F6\n        F6 --- F23\n\n        style F0 fill:#2d5016,stroke:#4ec9b0,stroke-width:2px,color:#fff\nstyle F1 fill:#2d5016,stroke:#4ec9b0,stroke-width:2px,color:#fff\nstyle F2 fill:#2d5016,stroke:#4ec9b0,stroke-width:2px,color:#fff\nstyle F3 fill:#2d5016,stroke:#4ec9b0,stroke-width:2px,color:#fff\nstyle F4 fill:#1e3a5f,stroke:#569cd6,stroke-width:2px,color:#fff\nstyle F5 fill:#1e3a5f,stroke:#569cd6,stroke-width:2px,color:#fff\nstyle F6 fill:#3d3d2a,stroke:#dcdcaa,stroke-width:2px,color:#fff\nstyle F23 fill:#3d3d2a,stroke:#dcdcaa,stroke-width:2px,color:#fff\n    end</code></pre> <p>Each frame is 24x24 pixels, arranged horizontally in one row.</p>"},{"location":"tutorials/animations/#frame-coordinates","title":"Frame Coordinates","text":"<pre><code>graph TD\n    subgraph COORDS[\"Frame Positions (X coordinates)\"]\n        C0[\"Frame 0&lt;br/&gt;X: 0\"]\n        C1[\"Frame 1&lt;br/&gt;X: 24\"]\n        C2[\"Frame 2&lt;br/&gt;X: 48\"]\n        C3[\"Frame 3&lt;br/&gt;X: 72\"]\n        C4[\"Frame 4&lt;br/&gt;X: 96\"]\n        C5[\"Frame 5&lt;br/&gt;X: 120\"]\n\n        C0 -.-&gt;|\"+24px\"| C1\n        C1 -.-&gt;|\"+24px\"| C2\n        C2 -.-&gt;|\"+24px\"| C3\n        C3 -.-&gt;|\"+24px\"| C4\n        C4 -.-&gt;|\"+24px\"| C5\n    end\n\n    style C0 fill:#2d5016,stroke:#4ec9b0,stroke-width:2px,color:#fff\n    style C1 fill:#2d5016,stroke:#4ec9b0,stroke-width:2px,color:#fff\n    style C2 fill:#2d5016,stroke:#4ec9b0,stroke-width:2px,color:#fff\n    style C3 fill:#2d5016,stroke:#4ec9b0,stroke-width:2px,color:#fff\n    style C4 fill:#1e3a5f,stroke:#569cd6,stroke-width:2px,color:#fff\n    style C5 fill:#1e3a5f,stroke:#569cd6,stroke-width:2px,color:#fff\n    style COORDS fill:#1a2332,stroke:#4ec9b0,stroke-width:2px,color:#fff</code></pre>"},{"location":"tutorials/animations/#frame-to-rectangle-mapping","title":"Frame to Rectangle Mapping","text":"Frame # X Position Y Position Code 0 0 0 <code>new Rectangle(0, 0, 24, 24)</code> 1 24 0 <code>new Rectangle(24, 0, 24, 24)</code> 2 48 0 <code>new Rectangle(48, 0, 24, 24)</code> 3 72 0 <code>new Rectangle(72, 0, 24, 24)</code> 4 96 0 <code>new Rectangle(96, 0, 24, 24)</code>"},{"location":"tutorials/animations/#why-use-sprite-sheets","title":"Why Use Sprite Sheets?","text":"<pre><code>graph LR\n    A[\"Single PNG File&lt;br/&gt;character.png\"] --&gt; B[\"\u2705 Faster Loading\"]\n    A --&gt; C[\"\u2705 Better Performance\"]\n    A --&gt; D[\"\u2705 Easier Organization\"]\n    A --&gt; E[\"\u2705 GPU-Friendly\"]\n\n    style A fill:#1e3a5f,stroke:#569cd6,stroke-width:2px,color:#fff\nstyle B fill:#2d5016,stroke:#4ec9b0,stroke-width:2px,color:#fff\nstyle C fill:#2d5016,stroke:#4ec9b0,stroke-width:2px,color:#fff\nstyle D fill:#2d5016,stroke:#4ec9b0,stroke-width:2px,color:#fff\nstyle E fill:#2d5016,stroke:#4ec9b0,stroke-width:2px,color:#fff</code></pre> <p>Key Points: - \u2705 One texture load instead of 24 separate files - \u2705 Fewer texture switches = better GPU performance - \u2705 All frames stay together = easier to manage - \u2705 Standard format used by game engines everywhere</p>"},{"location":"tutorials/animations/#example-file-structure","title":"Example File Structure","text":"<pre><code>YourProject/\n\u251c\u2500\u2500 assets/\n\u2502   \u2514\u2500\u2500 sprites/\n\u2502       \u2514\u2500\u2500 character.png    \u2190 ONE PNG file (576x24 pixels)\n\u2502                               Contains all 24 frames\n\u251c\u2500\u2500 Program.cs\n\u2514\u2500\u2500 BasicGame.csproj</code></pre> <p>Creating Sprite Sheets</p> <p>Need a sprite sheet? Here are some great resources:</p> <ul> <li>Free Assets: OpenGameArt.org, Kenney.nl, itch.io</li> <li>Pixel Art Tools: Aseprite, Piskel (free online)</li> <li>Sprite Sheet Packers: TexturePacker</li> </ul>"},{"location":"tutorials/animations/#in-code","title":"In Code","text":"<p>You load one PNG file and tell the system which rectangular section to display:</p> <pre><code>// Load the entire sprite sheet (one file)\n_spriteSheet = await _textureLoader.LoadTextureAsync(\n    \"assets/sprites/character.png\",  // \u2190 Your single PNG\n    TextureScaleMode.Nearest,\n    cancellationToken\n);\n\n// Access individual frames by specifying rectangles\nvar frame0 = new Rectangle(0, 0, 24, 24);    // First frame\nvar frame1 = new Rectangle(24, 0, 24, 24);   // Second frame\nvar frame2 = new Rectangle(48, 0, 24, 24);   // Third frame</code></pre>"},{"location":"tutorials/animations/#step-1-project-setup","title":"Step 1: Project Setup","text":"<p>We'll build on the Moving Sprites scene.</p>"},{"location":"tutorials/animations/#create-animatedspritescene","title":"Create AnimatedSpriteScene","text":"<p>Create <code>AnimatedSpriteScene.cs</code>:</p> <pre><code>using Brine2D.Core;\nusing Brine2D.Core.Animation;\nusing Brine2D.Input;\nusing Brine2D.Rendering;\nusing Microsoft.Extensions.Logging;\nusing System.Numerics;\n\nnamespace MyGame;\n\npublic class AnimatedSpriteScene : Scene\n{\n    private readonly IRenderer _renderer;\n    private readonly IInputService _input;\n    private readonly ITextureLoader _textureLoader;\n    private readonly IGameContext _gameContext;\n    private readonly ILoggerFactory _loggerFactory;\n\n    public AnimatedSpriteScene(\n        IRenderer renderer,\n        IInputService input,\n        ITextureLoader textureLoader,\n        IGameContext gameContext,\n        ILoggerFactory loggerFactory,\n        ILogger&lt;AnimatedSpriteScene&gt; logger\n    ) : base(logger)\n    {\n        _renderer = renderer;\n        _input = input;\n        _textureLoader = textureLoader;\n        _gameContext = gameContext;\n        _loggerFactory = loggerFactory;\n    }\n\n    protected override void OnInitialize()\n    {\n        Logger.LogInformation(\"Animated Sprite Scene initialized!\");\n    }\n}</code></pre>"},{"location":"tutorials/animations/#step-2-loading-a-sprite-sheet","title":"Step 2: Loading a Sprite Sheet","text":"<p>Add fields for texture and animator:</p> <pre><code>private ITexture? _spriteSheet;\nprivate SpriteAnimator? _animator;\nprivate Vector2 _position = new Vector2(640, 360);\nprivate float _speed = 200f;</code></pre> <p>Load the sprite sheet in <code>OnLoadAsync</code>:</p> <pre><code>protected override async Task OnLoadAsync(CancellationToken cancellationToken)\n{\n    Logger.LogInformation(\"Loading sprite sheet...\");\n\n    var spriteSheetPath = \"assets/sprites/character.png\";\n\n    if (File.Exists(spriteSheetPath))\n    {\n        _spriteSheet = await _textureLoader.LoadTextureAsync(\n            spriteSheetPath,\n            TextureScaleMode.Nearest, // Important for pixel art!\n            cancellationToken\n        );\n\n        Logger.LogInformation(\"Sprite sheet loaded: {Width}x{Height}\",\n            _spriteSheet.Width, _spriteSheet.Height);\n    }\n    else\n    {\n        Logger.LogWarning(\"Sprite sheet not found, using placeholder\");\n        // 576x24 = 24 frames at 24x24 each\n        _spriteSheet = _textureLoader.CreateTexture(576, 24, TextureScaleMode.Nearest);\n    }\n\n    // Create the animator (we'll add animations next)\n    _animator = new SpriteAnimator(_loggerFactory.CreateLogger&lt;SpriteAnimator&gt;());\n}</code></pre>"},{"location":"tutorials/animations/#step-3-creating-animation-clips","title":"Step 3: Creating Animation Clips","text":"<p>An <code>AnimationClip</code> is a collection of frames that play in sequence.</p>"},{"location":"tutorials/animations/#method-1-using-fromspritesheet-easy","title":"Method 1: Using FromSpriteSheet (Easy)","text":"<p>For uniform frame sizes:</p> <pre><code>// Add after creating _animator\nconst int frameWidth = 24;\nconst int frameHeight = 24;\nconst int columns = 24;  // Number of frames per row\n\n// Walk animation: frames 0-3 (first 4 frames)\nvar walkAnim = AnimationClip.FromSpriteSheet(\n    name: \"walk\",\n    frameWidth: frameWidth,\n    frameHeight: frameHeight,\n    frameCount: 4,           // Use 4 frames\n    columns: columns,         // 24 frames per row\n    frameDuration: 0.15f,    // Each frame lasts 0.15 seconds\n    loop: true               // Loop the animation\n);\n\n_animator.AddAnimation(walkAnim);</code></pre> <p>What's happening: - <code>FromSpriteSheet</code> automatically calculates frame positions - Frames are read left-to-right, top-to-bottom - Each frame displays for <code>frameDuration</code> seconds</p>"},{"location":"tutorials/animations/#method-2-manual-frame-definition-flexible","title":"Method 2: Manual Frame Definition (Flexible)","text":"<p>For non-uniform animations or precise control:</p> <pre><code>// Run animation: frames 4-9\nvar runAnim = new AnimationClip(\"run\") { Loop = true };\n\nfor (int i = 4; i &lt; 10; i++)\n{\n    var rect = new Rectangle(\n        x: i * frameWidth,\n        y: 0,\n        width: frameWidth,\n        height: frameHeight\n    );\n\n    runAnim.Frames.Add(new SpriteFrame(rect, duration: 0.08f));\n}\n\n_animator.AddAnimation(runAnim);</code></pre> <p>Use manual method when: - Frames have different sizes - You need variable frame durations - Animation frames aren't in a simple grid</p>"},{"location":"tutorials/animations/#step-4-creating-multiple-animations","title":"Step 4: Creating Multiple Animations","text":"<p>Let's add a full set of animations:</p> <pre><code>protected override async Task OnLoadAsync(CancellationToken cancellationToken)\n{\n    // ... sprite sheet loading code ...\n\n    _animator = new SpriteAnimator(_loggerFactory.CreateLogger&lt;SpriteAnimator&gt;());\n\n    const int frameWidth = 24;\n    const int frameHeight = 24;\n    const int columns = 24;\n\n    // Walk: frames 0-3\n    var walkAnim = AnimationClip.FromSpriteSheet(\n        \"walk\", frameWidth, frameHeight, 4, columns, 0.15f, true);\n\n    // Run: frames 4-9\n    var runAnim = new AnimationClip(\"run\") { Loop = true };\n    for (int i = 4; i &lt; 10; i++)\n    {\n        runAnim.Frames.Add(new SpriteFrame(\n            new Rectangle(i * frameWidth, 0, frameWidth, frameHeight),\n            0.08f));\n    }\n\n    // Jump: frames 10-12 (one-shot, doesn't loop)\n    var jumpAnim = new AnimationClip(\"jump\") { Loop = false };\n    for (int i = 10; i &lt; 13; i++)\n    {\n        jumpAnim.Frames.Add(new SpriteFrame(\n            new Rectangle(i * frameWidth, 0, frameWidth, frameHeight),\n            0.1f));\n    }\n\n    // Idle: single frame (frame 13)\n    var idleAnim = new AnimationClip(\"idle\") { Loop = true };\n    idleAnim.Frames.Add(new SpriteFrame(\n        new Rectangle(13 * frameWidth, 0, frameWidth, frameHeight),\n        1.0f)); // Hold for 1 second\n\n    // Add all animations to the animator\n    _animator.AddAnimation(walkAnim);\n    _animator.AddAnimation(runAnim);\n    _animator.AddAnimation(jumpAnim);\n    _animator.AddAnimation(idleAnim);\n\n    // Start with idle animation\n    _animator.Play(\"idle\");\n\n    Logger.LogInformation(\"Loaded {Count} animations\", 4);\n}</code></pre>"},{"location":"tutorials/animations/#step-5-playing-animations","title":"Step 5: Playing Animations","text":"<p>Use <code>_animator.Play()</code> to switch animations:</p> <pre><code>protected override void OnUpdate(GameTime gameTime)\n{\n    var deltaTime = (float)gameTime.DeltaTime;\n\n    if (_input.IsKeyPressed(Keys.Escape))\n    {\n        _gameContext.RequestExit();\n    }\n\n    // Animation switching\n    if (_input.IsKeyPressed(Keys.D1))\n    {\n        _animator?.Play(\"idle\");\n        Logger.LogInformation(\"Playing: idle\");\n    }\n    if (_input.IsKeyPressed(Keys.D2))\n    {\n        _animator?.Play(\"walk\");\n        Logger.LogInformation(\"Playing: walk\");\n    }\n    if (_input.IsKeyPressed(Keys.D3))\n    {\n        _animator?.Play(\"run\");\n        Logger.LogInformation(\"Playing: run\");\n    }\n    if (_input.IsKeyPressed(Keys.D4))\n    {\n        _animator?.Play(\"jump\");\n        Logger.LogInformation(\"Playing: jump\");\n    }\n\n    // Update the animator (CRITICAL!)\n    _animator?.Update(deltaTime);\n}</code></pre> <p>Key Point: You MUST call <code>_animator.Update(deltaTime)</code> every frame!</p>"},{"location":"tutorials/animations/#step-6-rendering-animated-sprites","title":"Step 6: Rendering Animated Sprites","text":"<p>Now we draw the current animation frame:</p> <pre><code>protected override void OnRender(GameTime gameTime)\n{\n    _renderer.Clear(new Color(40, 40, 40));\n    _renderer.BeginFrame();\n\n    if (_spriteSheet != null &amp;&amp; _animator?.CurrentFrame != null)\n    {\n        var frame = _animator.CurrentFrame;\n        var rect = frame.SourceRect;\n\n        // Scale up for visibility (optional)\n        var scale = 4.0f;\n        var destWidth = rect.Width * scale;\n        var destHeight = rect.Height * scale;\n\n        var drawX = _position.X - (destWidth / 2);\n        var drawY = _position.Y - (destHeight / 2);\n\n        // Draw the current frame\n        _renderer.DrawTexture(\n            _spriteSheet,\n            rect.X, rect.Y, rect.Width, rect.Height,  // Source rectangle\n            drawX, drawY, destWidth, destHeight       // Destination rectangle\n        );\n    }\n\n    _renderer.EndFrame();\n}</code></pre> <p>What's happening: - <code>_animator.CurrentFrame</code> gives us the current frame to display - <code>frame.SourceRect</code> tells us where in the sprite sheet to read from - We draw that portion of the texture to the screen</p>"},{"location":"tutorials/animations/#step-7-animation-controls","title":"Step 7: Animation Controls","text":"<p>Add pause/resume and speed controls:</p> <pre><code>protected override void OnUpdate(GameTime gameTime)\n{\n    var deltaTime = (float)gameTime.DeltaTime;\n\n    if (_input.IsKeyPressed(Keys.Escape))\n    {\n        _gameContext.RequestExit();\n    }\n\n    // Pause/Resume\n    if (_input.IsKeyPressed(Keys.Space))\n    {\n        if (_animator?.IsPlaying == true)\n        {\n            _animator.Pause();\n            Logger.LogInformation(\"Animation paused\");\n        }\n        else\n        {\n            _animator?.Resume();\n            Logger.LogInformation(\"Animation resumed\");\n        }\n    }\n\n    // Speed control\n    if (_animator != null)\n    {\n        if (_input.IsKeyDown(Keys.LeftShift))\n        {\n            _animator.Speed = 2.0f; // 2x faster\n        }\n        else if (_input.IsKeyDown(Keys.LeftControl))\n        {\n            _animator.Speed = 0.5f; // Half speed (slow-mo)\n        }\n        else\n        {\n            _animator.Speed = 1.0f; // Normal speed\n        }\n    }\n\n    // Animation switching (1-4 keys)\n    if (_input.IsKeyPressed(Keys.D1)) _animator?.Play(\"idle\");\n    if (_input.IsKeyPressed(Keys.D2)) _animator?.Play(\"walk\");\n    if (_input.IsKeyPressed(Keys.D3)) _animator?.Play(\"run\");\n    if (_input.IsKeyPressed(Keys.D4)) _animator?.Play(\"jump\");\n\n    _animator?.Update(deltaTime);\n}</code></pre>"},{"location":"tutorials/animations/#step-8-movement-with-animation","title":"Step 8: Movement with Animation","text":"<p>Let's make the character move AND animate:</p> <pre><code>protected override void OnUpdate(GameTime gameTime)\n{\n    var deltaTime = (float)gameTime.DeltaTime;\n\n    if (_input.IsKeyPressed(Keys.Escape))\n    {\n        _gameContext.RequestExit();\n    }\n\n    // Calculate movement\n    var movement = Vector2.Zero;\n    if (_input.IsKeyDown(Keys.W)) movement.Y -= 1;\n    if (_input.IsKeyDown(Keys.S)) movement.Y += 1;\n    if (_input.IsKeyDown(Keys.A)) movement.X -= 1;\n    if (_input.IsKeyDown(Keys.D)) movement.X += 1;\n\n    // Choose animation based on movement\n    if (movement != Vector2.Zero)\n    {\n        movement = Vector2.Normalize(movement);\n        _position += movement * _speed * deltaTime;\n\n        // Run if holding Shift, otherwise walk\n        if (_input.IsKeyDown(Keys.LeftShift))\n        {\n            _animator?.Play(\"run\");\n        }\n        else\n        {\n            _animator?.Play(\"walk\");\n        }\n    }\n    else\n    {\n        // Not moving, play idle\n        _animator?.Play(\"idle\");\n    }\n\n    // Jump animation (overrides movement)\n    if (_input.IsKeyPressed(Keys.Space))\n    {\n        _animator?.Play(\"jump\");\n    }\n\n    _animator?.Update(deltaTime);\n}</code></pre>"},{"location":"tutorials/animations/#complete-code","title":"Complete Code","text":"<p>Here's the full <code>AnimatedSpriteScene.cs</code>:</p> <pre><code>using Brine2D.Core;\nusing Brine2D.Core.Animation;\nusing Brine2D.Input;\nusing Brine2D.Rendering;\nusing Microsoft.Extensions.Logging;\nusing System.Numerics;\n\nnamespace MyGame;\n\npublic class AnimatedSpriteScene : Scene\n{\n    private readonly IRenderer _renderer;\n    private readonly IInputService _input;\n    private readonly ITextureLoader _textureLoader;\n    private readonly IGameContext _gameContext;\n    private readonly ILoggerFactory _loggerFactory;\n\n    private ITexture? _spriteSheet;\n    private SpriteAnimator? _animator;\n    private Vector2 _position = new Vector2(640, 360);\n    private float _speed = 200f;\n\n    public AnimatedSpriteScene(\n        IRenderer renderer,\n        IInputService input,\n        ITextureLoader textureLoader,\n        IGameContext gameContext,\n        ILoggerFactory loggerFactory,\n        ILogger&lt;AnimatedSpriteScene&gt; logger\n    ) : base(logger)\n    {\n        _renderer = renderer;\n        _input = input;\n        _textureLoader = textureLoader;\n        _gameContext = gameContext;\n        _loggerFactory = loggerFactory;\n    }\n\n    protected override void OnInitialize()\n    {\n        Logger.LogInformation(\"Animated Sprite Scene initialized!\");\n        Logger.LogInformation(\"Controls:\");\n        Logger.LogInformation(\"  WASD - Move\");\n        Logger.LogInformation(\"  Shift - Run\");\n        Logger.LogInformation(\"  Space - Jump\");\n        Logger.LogInformation(\"  1-4 - Manual animation select\");\n        Logger.LogInformation(\"  ESC - Exit\");\n    }\n\n    protected override async Task OnLoadAsync(CancellationToken cancellationToken)\n    {\n        Logger.LogInformation(\"Loading sprite sheet...\");\n\n        var spriteSheetPath = \"assets/sprites/character.png\";\n\n        if (File.Exists(spriteSheetPath))\n        {\n            _spriteSheet = await _textureLoader.LoadTextureAsync(\n                spriteSheetPath,\n                TextureScaleMode.Nearest,\n                cancellationToken\n            );\n\n            Logger.LogInformation(\"Sprite sheet loaded: {Width}x{Height}\",\n                _spriteSheet.Width, _spriteSheet.Height);\n        }\n        else\n        {\n            Logger.LogWarning(\"Sprite sheet not found, using placeholder\");\n            _spriteSheet = _textureLoader.CreateTexture(576, 24, TextureScaleMode.Nearest);\n        }\n\n        _animator = new SpriteAnimator(_loggerFactory.CreateLogger&lt;SpriteAnimator&gt;());\n\n        const int frameWidth = 24;\n        const int frameHeight = 24;\n        const int columns = 24;\n\n        // Walk: frames 0-3\n        var walkAnim = AnimationClip.FromSpriteSheet(\n            \"walk\", frameWidth, frameHeight, 4, columns, 0.15f, true);\n\n        // Run: frames 4-9\n        var runAnim = new AnimationClip(\"run\") { Loop = true };\n        for (int i = 4; i &lt; 10; i++)\n        {\n            runAnim.Frames.Add(new SpriteFrame(\n                new Rectangle(i * frameWidth, 0, frameWidth, frameHeight),\n                0.08f));\n        }\n\n        // Jump: frames 10-12\n        var jumpAnim = new AnimationClip(\"jump\") { Loop = false };\n        for (int i = 10; i &lt; 13; i++)\n        {\n            jumpAnim.Frames.Add(new SpriteFrame(\n                new Rectangle(i * frameWidth, 0, frameWidth, frameHeight),\n                0.1f));\n        }\n\n        // Idle: frame 13\n        var idleAnim = new AnimationClip(\"idle\") { Loop = true };\n        idleAnim.Frames.Add(new SpriteFrame(\n            new Rectangle(13 * frameWidth, 0, frameWidth, frameHeight),\n            1.0f));\n\n        _animator.AddAnimation(walkAnim);\n        _animator.AddAnimation(runAnim);\n        _animator.AddAnimation(jumpAnim);\n        _animator.AddAnimation(idleAnim);\n\n        _animator.Play(\"idle\");\n\n        Logger.LogInformation(\"Loaded {Count} animations\", 4);\n    }\n\n    protected override void OnUpdate(GameTime gameTime)\n    {\n        var deltaTime = (float)gameTime.DeltaTime;\n\n        if (_input.IsKeyPressed(Keys.Escape))\n        {\n            _gameContext.RequestExit();\n        }\n\n        // Manual animation selection (1-4 keys)\n        if (_input.IsKeyPressed(Keys.D1)) _animator?.Play(\"idle\");\n        if (_input.IsKeyPressed(Keys.D2)) _animator?.Play(\"walk\");\n        if (_input.IsKeyPressed(Keys.D3)) _animator?.Play(\"run\");\n        if (_input.IsKeyPressed(Keys.D4)) _animator?.Play(\"jump\");\n\n        // Movement-based animation\n        var movement = Vector2.Zero;\n        if (_input.IsKeyDown(Keys.W)) movement.Y -= 1;\n        if (_input.IsKeyDown(Keys.S)) movement.Y += 1;\n        if (_input.IsKeyDown(Keys.A)) movement.X -= 1;\n        if (_input.IsKeyDown(Keys.D)) movement.X += 1;\n\n        if (movement != Vector2.Zero)\n        {\n            movement = Vector2.Normalize(movement);\n            _position += movement * _speed * deltaTime;\n\n            // Only auto-play movement animations if not manually selected\n            if (!_input.IsKeyPressed(Keys.D1) &amp;&amp; \n                !_input.IsKeyPressed(Keys.D2) &amp;&amp; \n                !_input.IsKeyPressed(Keys.D3) &amp;&amp; \n                !_input.IsKeyPressed(Keys.D4))\n            {\n                if (_input.IsKeyDown(Keys.LeftShift))\n                {\n                    _animator?.Play(\"run\");\n                }\n                else\n                {\n                    _animator?.Play(\"walk\");\n                }\n            }\n        }\n        else if (!_input.IsKeyPressed(Keys.D1) &amp;&amp; \n                 !_input.IsKeyPressed(Keys.D2) &amp;&amp; \n                 !_input.IsKeyPressed(Keys.D3) &amp;&amp; \n                 !_input.IsKeyPressed(Keys.D4))\n        {\n            _animator?.Play(\"idle\");\n        }\n\n        // Jump overrides other animations\n        if (_input.IsKeyPressed(Keys.Space))\n        {\n            _animator?.Play(\"jump\");\n        }\n\n        _animator?.Update(deltaTime);\n    }\n\n    protected override void OnRender(GameTime gameTime)\n    {\n        _renderer.Clear(new Color(40, 40, 40));\n        _renderer.BeginFrame();\n\n        if (_spriteSheet != null &amp;&amp; _animator?.CurrentFrame != null)\n        {\n            var frame = _animator.CurrentFrame;\n            var rect = frame.SourceRect;\n\n            var scale = 4.0f;\n            var destWidth = rect.Width * scale;\n            var destHeight = rect.Height * scale;\n\n            var drawX = _position.X - (destWidth / 2);\n            var drawY = _position.Y - (destHeight / 2);\n\n            _renderer.DrawTexture(\n                _spriteSheet,\n                rect.X, rect.Y, rect.Width, rect.Height,\n                drawX, drawY, destWidth, destHeight);\n        }\n\n        _renderer.EndFrame();\n    }\n\n    protected override Task OnUnloadAsync(CancellationToken cancellationToken)\n    {\n        if (_spriteSheet != null)\n        {\n            _textureLoader.UnloadTexture(_spriteSheet);\n        }\n\n        return Task.CompletedTask;\n    }\n}</code></pre>"},{"location":"tutorials/animations/#animation-system-deep-dive","title":"Animation System Deep Dive","text":""},{"location":"tutorials/animations/#how-spriteanimator-works","title":"How SpriteAnimator Works","text":"<ol> <li>You add animations: <code>_animator.AddAnimation(clip)</code></li> <li>You play an animation: <code>_animator.Play(\"walk\")</code></li> <li>Update advances frames: <code>_animator.Update(deltaTime)</code></li> <li>You render the current frame: <code>_animator.CurrentFrame</code></li> </ol>"},{"location":"tutorials/animations/#frame-timing","title":"Frame Timing","text":"<pre><code>// Each frame displays for its duration\nframeTimer += deltaTime;\n\nif (frameTimer &gt;= currentFrame.Duration)\n{\n    frameTimer -= currentFrame.Duration;\n    currentFrameIndex++;\n}</code></pre>"},{"location":"tutorials/animations/#loop-vs-one-shot","title":"Loop vs One-Shot","text":"<pre><code>var loopingAnim = new AnimationClip(\"walk\") { Loop = true };   // Repeats\nvar oneShotAnim = new AnimationClip(\"jump\") { Loop = false };  // Plays once</code></pre> <p>When a one-shot animation finishes, <code>IsPlaying</code> becomes false.</p>"},{"location":"tutorials/animations/#challenges","title":"Challenges","text":""},{"location":"tutorials/animations/#easy","title":"Easy","text":"<ol> <li>More animations - Add crouch, hurt, or attack animations</li> <li>Animation speed - Experiment with different frame durations</li> <li>Direction flipping - Flip the sprite horizontally when moving left</li> </ol>"},{"location":"tutorials/animations/#medium","title":"Medium","text":"<ol> <li>Animation events - Trigger sound effects when certain frames play</li> <li>Blend animations - Smoothly transition between animations</li> <li>Animation queuing - Queue the next animation to play after current finishes</li> </ol>"},{"location":"tutorials/animations/#hard","title":"Hard","text":"<ol> <li>State machine - Build a proper animation state machine with transitions</li> <li>Multi-layer animation - Animate body and legs separately</li> <li>Procedural animation - Generate animations at runtime</li> </ol>"},{"location":"tutorials/animations/#what-you-learned","title":"What You Learned","text":"<p>\u2705 Sprite sheets - Organizing multiple frames in one texture \u2705 AnimationClip - Creating frame-based animations \u2705 SpriteAnimator - Managing and playing animations \u2705 Frame timing - Using delta time for smooth playback \u2705 Animation control - Play, pause, resume, speed control \u2705 State-driven animation - Choosing animations based on game state \u2705 Loop vs one-shot - Different animation behaviors</p>"},{"location":"tutorials/animations/#next-steps","title":"Next Steps","text":"<p>Ready for more? Check out:</p> <ul> <li>Collision Detection - Make your animated character interact with the world</li> <li>Building a Platformer - Combine movement, animation, and physics</li> <li>Animation Guide - Advanced animation techniques</li> <li>Sprite Guide - More sprite rendering tricks</li> </ul>"},{"location":"tutorials/animations/#common-issues","title":"Common Issues","text":""},{"location":"tutorials/animations/#animation-not-playing","title":"Animation not playing?","text":"<ul> <li>Did you call <code>_animator.Update(deltaTime)</code> in <code>OnUpdate</code>?</li> <li>Check if the animation name is correct</li> <li>Verify frames were added to the clip</li> </ul>"},{"location":"tutorials/animations/#animation-too-fastslow","title":"Animation too fast/slow?","text":"<ul> <li>Adjust <code>frameDuration</code> in each frame</li> <li>Or use <code>_animator.Speed</code> to change playback speed globally</li> </ul>"},{"location":"tutorials/animations/#wrong-frames-showing","title":"Wrong frames showing?","text":"<ul> <li>Double-check your frame indices and sprite sheet layout</li> <li>Verify <code>frameWidth</code>, <code>frameHeight</code>, and <code>columns</code> are correct</li> <li>Use a sprite sheet viewer tool to confirm frame positions</li> </ul>"},{"location":"tutorials/animations/#animation-stutters","title":"Animation stutters?","text":"<ul> <li>Make sure you're using <code>deltaTime</code> correctly</li> <li>Check frame rate is consistent (enable VSync)</li> <li>Verify frame durations add up correctly</li> </ul> <p>Great job! You've mastered sprite animation in Brine2D. Your characters are now ready to come alive!</p>"},{"location":"tutorials/moving-sprites/","title":"Moving Sprites","text":"<p>Difficulty: Beginner | Time: 15 minutes</p> <p>In this tutorial, you'll learn the fundamentals of rendering and moving sprites in Brine2D. By the end, you'll have a player character that smoothly moves across the screen using keyboard input.</p>"},{"location":"tutorials/moving-sprites/#what-youll-build","title":"What You'll Build","text":"<p>A simple game scene with: - A sprite loaded from an image file - Smooth keyboard-controlled movement - Frame-rate independent motion using delta time - Proper boundary checking</p>"},{"location":"tutorials/moving-sprites/#prerequisites","title":"Prerequisites","text":"<ul> <li>Completed Quick Start</li> <li>Basic understanding of C# and classes</li> <li>A sprite image (or use the included placeholder)</li> </ul>"},{"location":"tutorials/moving-sprites/#step-1-project-setup","title":"Step 1: Project Setup","text":"<p>First, create a new scene for your moving sprite demo.</p>"},{"location":"tutorials/moving-sprites/#create-the-scene-class","title":"Create the Scene Class","text":"<p>Create a new file <code>MovingSpriteScene.cs</code>:</p> <pre><code>using Brine2D.Core;\nusing Brine2D.Input;\nusing Brine2D.Rendering;\nusing Microsoft.Extensions.Logging;\nusing System.Numerics;\n\nnamespace MyGame;\n\npublic class MovingSpriteScene : Scene\n{\n    private readonly IRenderer _renderer;\n    private readonly IInputService _input;\n    private readonly ITextureLoader _textureLoader;\n    private readonly IGameContext _gameContext;\n\n    public MovingSpriteScene\n    (\n        IRenderer renderer,\n        IInputService input,\n        ITextureLoader textureLoader,\n        IGameContext gameContext,\n        ILogger&lt;MovingSpriteScene&gt; logger\n    ) : base(logger)\n    {\n        _renderer = renderer;\n        _input = input;\n        _textureLoader = textureLoader;\n        _gameContext = gameContext;\n    }\n\n    protected override void OnInitialize()\n    {\n        Logger.LogInformation(\"Moving Sprite Scene initialized!\");\n    }\n}</code></pre> <p>What's happening here:</p> <ul> <li>We're using constructor injection to get dependencies (just like ASP.NET!)</li> <li><code>IRenderer</code> - draws things on screen</li> <li><code>IInputService</code> - handles keyboard/mouse input</li> <li><code>ITextureLoader</code> - loads images from disk</li> <li><code>IGameContext</code> - controls game state (exit, pause, etc.)</li> </ul>"},{"location":"tutorials/moving-sprites/#step-2-loading-a-sprite","title":"Step 2: Loading a Sprite","text":"<p>Now let's load a texture (sprite image) when the scene loads.</p>"},{"location":"tutorials/moving-sprites/#add-texture-fields","title":"Add Texture Fields","text":"<p>Add these fields to your scene class:</p> <pre><code>private ITexture? _playerTexture;\nprivate Vector2 _playerPosition = new Vector2(400, 300);\nprivate float _speed = 200f; // pixels per second</code></pre>"},{"location":"tutorials/moving-sprites/#load-the-texture","title":"Load the Texture","text":"<p>Override <code>OnLoadAsync</code> to load your sprite:</p> <pre><code>protected override async Task OnLoadAsync(CancellationToken cancellationToken)\n{\n    Logger.LogInformation(\"Loading player sprite...\");\n\n    var spritePath = \"assets/sprites/player.png\";\n\n    if (File.Exists(spritePath))\n    {\n        _playerTexture = await _textureLoader.LoadTextureAsync\n        (\n            spritePath,\n            TextureScaleMode.Nearest, // Use Nearest for pixel art, Linear for smooth art\n            cancellationToken\n        );\n\n        Logger.LogInformation(\"Sprite loaded: {Width}x{Height}\",\n            _playerTexture.Width, _playerTexture.Height);\n    }\n    else\n    {\n        Logger.LogWarning(\"Sprite not found at: {Path}\", Path.GetFullPath(spritePath));\n\n        // Create a placeholder texture if file doesn't exist\n        _playerTexture = _textureLoader.CreateTexture(32, 32, TextureScaleMode.Nearest);\n    }\n}</code></pre> <p>Key Points:</p> <ul> <li><code>LoadTextureAsync</code> is async - it won't block your game while loading</li> <li><code>TextureScaleMode.Nearest</code> is perfect for pixel art (no blurring)</li> <li><code>TextureScaleMode.Linear</code> is better for high-res sprites (smooth scaling)</li> <li>We provide a fallback if the file doesn't exist</li> </ul>"},{"location":"tutorials/moving-sprites/#step-3-drawing-the-sprite","title":"Step 3: Drawing the Sprite","text":"<p>Now let's draw the sprite on screen.</p>"},{"location":"tutorials/moving-sprites/#implement-onrender","title":"Implement OnRender","text":"<pre><code>protected override void OnRender(GameTime gameTime)\n{\n    // Clear the screen with a background color\n    _renderer.Clear(new Color(40, 40, 40)); // Dark gray\n\n    _renderer.BeginFrame();\n\n    // Draw the player sprite if loaded\n    if (_playerTexture != null)\n    {\n        _renderer.DrawTexture\n        (\n            _playerTexture,\n            _playerPosition.X,\n            _playerPosition.Y\n        );\n    }\n\n    _renderer.EndFrame();\n}</code></pre> <p>What's happening:</p> <ol> <li><code>Clear()</code> fills the screen with a background color</li> <li><code>BeginFrame()</code> starts a new frame (required before drawing)</li> <li><code>DrawTexture()</code> draws the sprite at the specified position</li> <li><code>EndFrame()</code> finishes the frame and presents it to the screen</li> </ol>"},{"location":"tutorials/moving-sprites/#test-it","title":"Test It!","text":"<p>Run your game now. You should see your sprite on screen (or a placeholder square if the image didn't load).</p>"},{"location":"tutorials/moving-sprites/#step-4-adding-movement","title":"Step 4: Adding Movement","text":"<p>Let's make the sprite move with keyboard input.</p>"},{"location":"tutorials/moving-sprites/#implement-onupdate","title":"Implement OnUpdate","text":"<pre><code>protected override void OnUpdate(GameTime gameTime)\n{\n    var deltaTime = (float)gameTime.DeltaTime;\n\n    // Exit on Escape key\n    if (_input.IsKeyPressed(Keys.Escape))\n    {\n        _gameContext.RequestExit();\n    }\n\n    // Move with arrow keys\n    if (_input.IsKeyDown(Keys.Left))\n    {\n        _playerPosition.X -= _speed * deltaTime;\n    }\n\n    if (_input.IsKeyDown(Keys.Right))\n    {\n        _playerPosition.X += _speed * deltaTime;\n    }\n\n    if (_input.IsKeyDown(Keys.Up))\n    {\n        _playerPosition.Y -= _speed * deltaTime;\n    }\n\n    if (_input.IsKeyDown(Keys.Down))\n    {\n        _playerPosition.Y += _speed * deltaTime;\n    }\n}</code></pre> <p>Understanding Delta Time:</p> <pre><code>movement = _speed * deltaTime;</code></pre> <ul> <li><code>deltaTime</code> is the time (in seconds) since the last frame</li> <li>At 60 FPS, <code>deltaTime</code> \u2248 0.0166 seconds</li> <li>At 30 FPS, <code>deltaTime</code> \u2248 0.0333 seconds</li> </ul> <p>This ensures the sprite moves at the same real-world speed regardless of frame rate!</p> <p>Without delta time: - 60 FPS: moves 60 pixels/second - 30 FPS: moves 30 pixels/second (half as fast!)</p> <p>With delta time: - 60 FPS: moves 200 pixels/second - 30 FPS: moves 200 pixels/second (consistent!)</p>"},{"location":"tutorials/moving-sprites/#step-5-better-movement-8-directional","title":"Step 5: Better Movement (8-Directional)","text":"<p>Let's improve movement to support diagonal motion.</p>"},{"location":"tutorials/moving-sprites/#replace-movement-code","title":"Replace Movement Code","text":"<pre><code>protected override void OnUpdate(GameTime gameTime)\n{\n    var deltaTime = (float)gameTime.DeltaTime;\n\n    if (_input.IsKeyPressed(Keys.Escape))\n    {\n        _gameContext.RequestExit();\n    }\n\n    // Calculate movement direction\n    var movement = Vector2.Zero;\n\n    if (_input.IsKeyDown(Keys.Left))\n    {\n        movement.X -= 1;\n    }\n\n    if (_input.IsKeyDown(Keys.Right))\n    {\n        movement.X += 1;\n    }\n\n    if (_input.IsKeyDown(Keys.Up))\n    {\n        movement.Y -= 1;\n    }\n\n    if (_input.IsKeyDown(Keys.Down))\n    {\n        movement.Y += 1;\n    }\n\n    // Normalize for consistent diagonal speed\n    if (movement != Vector2.Zero)\n    {\n        movement = Vector2.Normalize(movement);\n        _playerPosition += movement * _speed * deltaTime;\n    }\n}</code></pre> <p>Why Normalize?</p> <p>Without normalization:</p> <ul> <li>Moving right: speed = 200 px/s</li> <li>Moving diagonally (right + up): speed = 282 px/s (\u221a2 faster!)</li> </ul> <p>With <code>Vector2.Normalize()</code>:</p> <ul> <li>All directions: speed = 200 px/s (consistent!)</li> </ul>"},{"location":"tutorials/moving-sprites/#step-6-boundary-checking","title":"Step 6: Boundary Checking","text":"<p>Keep the sprite on screen by clamping its position.</p>"},{"location":"tutorials/moving-sprites/#add-screen-bounds","title":"Add Screen Bounds","text":"<pre><code>protected override void OnUpdate(GameTime gameTime)\n{\n    var deltaTime = (float)gameTime.DeltaTime;\n\n    if (_input.IsKeyPressed(Keys.Escape))\n    {\n        _gameContext.RequestExit();\n    }\n\n    // Calculate movement\n    var movement = Vector2.Zero;\n    if (_input.IsKeyDown(Keys.Left))\n    {\n        movement.X -= 1;\n    }\n\n    if (_input.IsKeyDown(Keys.Right))\n    {\n        movement.X += 1;\n    }\n\n    if (_input.IsKeyDown(Keys.Up))\n    {\n        movement.Y -= 1;\n    }\n\n    if (_input.IsKeyDown(Keys.Down))\n    {\n        movement.Y += 1;\n    }\n\n    if (movement != Vector2.Zero)\n    {\n        movement = Vector2.Normalize(movement);\n        _playerPosition += movement * _speed * deltaTime;\n    }\n\n    // Keep player on screen (assuming 1280x720 window)\n    const float screenWidth = 1280f;\n    const float screenHeight = 720f;\n\n    var spriteWidth = _playerTexture?.Width ?? 32;\n    var spriteHeight = _playerTexture?.Height ?? 32;\n\n    _playerPosition.X = Math.Clamp(_playerPosition.X, 0, screenWidth - spriteWidth);\n    _playerPosition.Y = Math.Clamp(_playerPosition.Y, 0, screenHeight - spriteHeight);\n}</code></pre> <p><code>Math.Clamp()</code> keeps the value within a range:</p> <ul> <li>If <code>x &lt; min</code>, returns <code>min</code></li> <li>If <code>x &gt; max</code>, returns <code>max</code></li> <li>Otherwise, returns <code>x</code></li> </ul>"},{"location":"tutorials/moving-sprites/#step-7-center-the-sprite","title":"Step 7: Center the Sprite","text":"<p>Right now, the sprite's top-left corner is at the position. Let's center it.</p>"},{"location":"tutorials/moving-sprites/#update-onrender","title":"Update OnRender","text":"<pre><code>protected override void OnRender(GameTime gameTime)\n{\n    _renderer.Clear(new Color(40, 40, 40));\n    _renderer.BeginFrame();\n\n    if (_playerTexture != null)\n    {\n        // Center the sprite on its position\n        var drawX = _playerPosition.X - (_playerTexture.Width / 2f);\n        var drawY = _playerPosition.Y - (_playerTexture.Height / 2f);\n\n        _renderer.DrawTexture(_playerTexture, drawX, drawY);\n    }\n\n    _renderer.EndFrame();\n}</code></pre> <p>Now <code>_playerPosition</code> represents the center of the sprite, which feels more natural for game logic.</p>"},{"location":"tutorials/moving-sprites/#step-8-scaling-the-sprite","title":"Step 8: Scaling the Sprite","text":"<p>Want to draw the sprite larger or smaller? Use the overload with width and height.</p>"},{"location":"tutorials/moving-sprites/#drawing-at-custom-size","title":"Drawing at Custom Size","text":"<pre><code>protected override void OnRender(GameTime gameTime)\n{\n    _renderer.Clear(new Color(40, 40, 40));\n    _renderer.BeginFrame();\n\n    if (_playerTexture != null)\n    {\n        var scale = 2.0f; // Draw 2x larger\n        var width = _playerTexture.Width * scale;\n        var height = _playerTexture.Height * scale;\n\n        var drawX = _playerPosition.X - (width / 2f);\n        var drawY = _playerPosition.Y - (height / 2f);\n\n        // DrawTexture with custom size\n        _renderer.DrawTexture(\n            _playerTexture,\n            drawX, drawY,\n            width, height\n        );\n    }\n\n    _renderer.EndFrame();\n}</code></pre>"},{"location":"tutorials/moving-sprites/#complete-code","title":"Complete Code","text":"<p>Here's the full <code>MovingSpriteScene.cs</code>:</p> <pre><code>using System.Numerics;\nusing Brine2D.Core;\nusing Brine2D.Input;\nusing Brine2D.Rendering;\nusing Microsoft.Extensions.Logging;\n\nnamespace MyGame;\n\npublic class MovingSpriteScene : Scene\n{\n    private readonly IGameContext _gameContext;\n    private readonly IInputService _input;\n    private readonly IRenderer _renderer;\n    private readonly ITextureLoader _textureLoader;\n    private Vector2 _playerPosition = new(640, 360); // Center of 1280x720\n\n    private ITexture? _playerTexture;\n    private readonly float _speed = 200f;\n\n    public MovingSpriteScene(\n        IRenderer renderer,\n        IInputService input,\n        ITextureLoader textureLoader,\n        IGameContext gameContext,\n        ILogger&lt;MovingSpriteScene&gt; logger\n    ) : base(logger)\n    {\n        _renderer = renderer;\n        _input = input;\n        _textureLoader = textureLoader;\n        _gameContext = gameContext;\n    }\n\n    protected override void OnInitialize()\n    {\n        Logger.LogInformation(\"Moving Sprite Scene initialized!\");\n        Logger.LogInformation(\"Controls: Arrow Keys to move, Escape to exit\");\n    }\n\n    protected override async Task OnLoadAsync(CancellationToken cancellationToken)\n    {\n        Logger.LogInformation(\"Loading player sprite...\");\n\n        var spritePath = \"assets/sprites/player.png\";\n\n        if (File.Exists(spritePath))\n        {\n            _playerTexture = await _textureLoader.LoadTextureAsync(\n                spritePath,\n                TextureScaleMode.Nearest,\n                cancellationToken\n            );\n\n            Logger.LogInformation(\"Sprite loaded: {Width}x{Height}\",\n                _playerTexture.Width, _playerTexture.Height);\n        }\n        else\n        {\n            Logger.LogWarning(\"Sprite not found, using placeholder\");\n            _playerTexture = _textureLoader.CreateTexture(32, 32, TextureScaleMode.Nearest);\n        }\n    }\n\n    protected override void OnRender(GameTime gameTime)\n    {\n        _renderer.Clear(new Color(40, 40, 40));\n        _renderer.BeginFrame();\n\n        if (_playerTexture != null)\n        {\n            // Draw centered on position\n            var drawX = _playerPosition.X - _playerTexture.Width / 2f;\n            var drawY = _playerPosition.Y - _playerTexture.Height / 2f;\n\n            _renderer.DrawTexture(_playerTexture, drawX, drawY);\n        }\n\n        _renderer.EndFrame();\n    }\n\n    protected override Task OnUnloadAsync(CancellationToken cancellationToken)\n    {\n        // Clean up the texture when scene unloads\n        if (_playerTexture != null)\n        {\n            _textureLoader.UnloadTexture(_playerTexture);\n        }\n\n        return Task.CompletedTask;\n    }\n\n    protected override void OnUpdate(GameTime gameTime)\n    {\n        var deltaTime = (float)gameTime.DeltaTime;\n\n        if (_input.IsKeyPressed(Keys.Escape))\n        {\n            _gameContext.RequestExit();\n        }\n\n        // Calculate movement direction\n        var movement = Vector2.Zero;\n        if (_input.IsKeyDown(Keys.Left))\n        {\n            movement.X -= 1;\n        }\n\n        if (_input.IsKeyDown(Keys.Right))\n        {\n            movement.X += 1;\n        }\n\n        if (_input.IsKeyDown(Keys.Up))\n        {\n            movement.Y -= 1;\n        }\n\n        if (_input.IsKeyDown(Keys.Down))\n        {\n            movement.Y += 1;\n        }\n\n        // Apply movement\n        if (movement != Vector2.Zero)\n        {\n            movement = Vector2.Normalize(movement);\n            _playerPosition += movement * _speed * deltaTime;\n        }\n\n        // Keep player on screen\n        const float screenWidth = 1280f;\n        const float screenHeight = 720f;\n\n        var spriteWidth = _playerTexture?.Width ?? 32;\n        var spriteHeight = _playerTexture?.Height ?? 32;\n\n        _playerPosition.X = Math.Clamp(_playerPosition.X, spriteWidth / 2f, screenWidth - spriteWidth / 2f);\n        _playerPosition.Y = Math.Clamp(_playerPosition.Y, spriteHeight / 2f, screenHeight - spriteHeight / 2f);\n    }\n}</code></pre>"},{"location":"tutorials/moving-sprites/#register-the-scene-in-programcs","title":"Register the Scene in Program.cs","text":"<pre><code>using Brine2D.Hosting;\nusing Brine2D.Input.SDL;\nusing Brine2D.Rendering.SDL;\nusing MyGame;\n\nvar builder = GameApplication.CreateBuilder(args);\n\nbuilder.Services.AddSDL3Rendering(options =&gt;\n{\n    options.WindowTitle = \"Moving Sprites Tutorial\";\n    options.WindowWidth = 1280;\n    options.WindowHeight = 720;\n    options.VSync = true;\n});\n\nbuilder.Services.AddSDL3Input();\nbuilder.Services.AddScene&lt;MovingSpriteScene&gt;();\n\nvar game = builder.Build();\nawait game.RunAsync&lt;MovingSpriteScene&gt;();</code></pre>"},{"location":"tutorials/moving-sprites/#challenges","title":"Challenges","text":"<p>Now that you've completed the tutorial, try these extensions:</p>"},{"location":"tutorials/moving-sprites/#easy","title":"Easy","text":"<ol> <li>Change the speed - Make the sprite move faster or slower</li> <li>Different keys - Use WASD instead of arrow keys</li> <li>Background color - Try different clear colors</li> </ol>"},{"location":"tutorials/moving-sprites/#medium","title":"Medium","text":"<ol> <li>Multiple sprites - Load and move 2-3 sprites independently</li> <li>Wrap-around - When the sprite leaves one edge, appear on the opposite edge</li> <li>Speed boost - Hold Shift to move 2x faster</li> </ol>"},{"location":"tutorials/moving-sprites/#hard","title":"Hard","text":"<ol> <li>Smooth acceleration - Gradually speed up/slow down instead of instant movement</li> <li>Mouse follow - Make the sprite move toward the mouse cursor</li> <li>Rotation - Rotate the sprite to face the direction of movement</li> </ol>"},{"location":"tutorials/moving-sprites/#what-you-learned","title":"What You Learned","text":"<p>\u2705 Loading textures with <code>ITextureLoader.LoadTextureAsync()</code> \u2705 Drawing sprites with <code>IRenderer.DrawTexture()</code> \u2705 Keyboard input with <code>IInputService.IsKeyDown()</code> \u2705 Delta time for frame-rate independent movement \u2705 Vector math with <code>Vector2.Normalize()</code> \u2705 Boundary checking with <code>Math.Clamp()</code> \u2705 Scene lifecycle - Initialize, Load, Update, Render, Unload</p>"},{"location":"tutorials/moving-sprites/#next-steps","title":"Next Steps","text":"<p>Ready for more? Check out:</p> <ul> <li>Animation System - Make your sprite come alive with animations</li> <li>Collision Detection - Add walls and interactive objects</li> <li>Input Guide - Master all input types</li> <li>Rendering Guide - Advanced sprite rendering</li> </ul>"},{"location":"tutorials/moving-sprites/#common-issues","title":"Common Issues","text":""},{"location":"tutorials/moving-sprites/#sprite-not-showing","title":"Sprite not showing?","text":"<ul> <li>Check if the file path is correct (<code>File.Exists()</code> returns true)</li> <li>Make sure <code>assets/sprites/</code> folder is being copied to output (check <code>.csproj</code>)</li> <li>Verify you called <code>BeginFrame()</code> before and <code>EndFrame()</code> after drawing</li> </ul>"},{"location":"tutorials/moving-sprites/#movement-feels-sluggish","title":"Movement feels sluggish?","text":"<ul> <li>Check your <code>_speed</code> value (200 is a good default for pixels/second)</li> <li>Make sure you're multiplying by <code>deltaTime</code></li> <li>Verify VSync is enabled for consistent frame rate</li> </ul>"},{"location":"tutorials/moving-sprites/#sprite-is-blurry","title":"Sprite is blurry?","text":"<ul> <li>Use <code>TextureScaleMode.Nearest</code> for pixel art</li> <li>Make sure you're not scaling the sprite too much</li> </ul> <p>Great job! You've mastered the basics of sprite rendering and movement in Brine2D.</p>"},{"location":"whats-new/v-0.6.0-beta/","title":"What's New in v0.6.0-beta","text":"<p>Released: [Date TBD]</p> <p>Version 0.6.0-beta brings significant performance optimizations, enhanced query capabilities, and improved developer experience with zero-allocation systems and comprehensive profiling tools.</p>"},{"location":"whats-new/v-0.6.0-beta/#major-features","title":"Major Features","text":""},{"location":"whats-new/v-0.6.0-beta/#performance-monitoring-profiling","title":"Performance Monitoring &amp; Profiling","text":"<p>Built-in performance overlay with real-time metrics and detailed profiling:</p> <pre><code>// Enable performance monitoring\nbuilder.Services.AddPerformanceMonitoring(options =&gt;\n{\n    options.EnableOverlay = true;\n    options.ShowFPS = true;\n    options.ShowFrameTime = true;\n    options.ShowMemory = true;\n});</code></pre> <p>Features: - FPS Counter - Min/max/average tracking with 60-frame history - Frame Time Graph - Visual representation of frame timing - Memory Statistics - GC collection counts and managed memory usage - Rendering Stats - Sprites rendered, draw calls, batch efficiency - Per-System Profiling - Identify performance bottlenecks</p> <p>Hotkeys: - <code>F1</code> - Toggle overlay visibility - <code>F3</code> - Toggle detailed stats (includes frame time graph and memory)</p> <p>See Performance Monitoring Guide</p>"},{"location":"whats-new/v-0.6.0-beta/#zero-allocation-systems","title":"Zero-Allocation Systems","text":"<p>Optimized hot paths using <code>ArrayPool&lt;T&gt;</code> and custom object pools to minimize GC pressure:</p> <p>Entity Component Iteration: <pre><code>// Safe iteration without allocations\nprotected internal virtual void OnUpdate(GameTime gameTime)\n{\n    var count = _components.Count;\n    var array = ArrayPool&lt;Component&gt;.Shared.Rent(count);\n    try\n    {\n        _components.CopyTo(array, 0);\n\n        for (int i = 0; i &lt; count; i++)\n        {\n            array[i].OnUpdate(gameTime);\n        }\n    }\n    finally\n    {\n        ArrayPool&lt;Component&gt;.Shared.Return(array, clearArray: true);\n    }\n}</code></pre></p> <p>Particle System Pooling: <pre><code>private readonly ObjectPool&lt;Particle&gt; _particlePool;\n\n// Get from pool instead of 'new'\nvar particle = _particlePool.Get();\nparticle.Position = spawnPos;\nparticle.Velocity = velocity;\n\n// Return to pool when done\n_particlePool.Return(particle);</code></pre></p> <p>Query System Optimization: <pre><code>// Random entity selection uses ArrayPool\nvar randomEnemy = _world.Query()\n    .With&lt;EnemyComponent&gt;()\n    .Random(); // Zero allocation!</code></pre></p> <p>See Performance Optimization Guide</p>"},{"location":"whats-new/v-0.6.0-beta/#sprite-batching-culling","title":"Sprite Batching &amp; Culling","text":"<p>Automatic batching with intelligent layer sorting and frustum culling:</p> <pre><code>var sprite = entity.AddComponent&lt;SpriteComponent&gt;();\nsprite.TexturePath = \"assets/player.png\";\nsprite.Layer = 10; // Higher layers render on top\nsprite.Tint = Color.White;\n\n// Check batching efficiency\nvar (renderedCount, drawCalls) = spriteSystem.GetBatchStats();\nLogger.LogInfo($\"Rendered {renderedCount} sprites in {drawCalls} draw calls\");</code></pre> <p>Features: - Automatic Batching - Groups sprites by texture to minimize draw calls - Layer Sorting - Correct rendering order with configurable layers - Frustum Culling - Off-screen sprites automatically skipped - Batch Statistics - Real-time efficiency metrics</p> <p>Performance: - 10,000+ sprites at 60 FPS with proper batching - 10-50x reduction in draw calls vs naive rendering - Zero allocation during rendering</p>"},{"location":"whats-new/v-0.6.0-beta/#advanced-query-system","title":"Advanced Query System","text":"<p>Powerful spatial queries, component filtering, and sorting:</p> <p>Spatial Queries: <pre><code>// Find entities within radius\nvar nearbyEnemies = _world.Query()\n    .WithinRadius(playerPos, 200f)\n    .With&lt;EnemyComponent&gt;()\n    .Execute();\n\n// Find entities within bounds\nvar visibleEntities = _world.Query()\n    .WithinBounds(new Rectangle(0, 0, 1280, 720))\n    .Execute();</code></pre></p> <p>Component Filtering: <pre><code>// Filter by component properties\nvar lowHealthEnemies = _world.Query()\n    .With&lt;HealthComponent&gt;(h =&gt; h.CurrentHealth &lt; 50)\n    .With&lt;EnemyComponent&gt;()\n    .Execute();</code></pre></p> <p>Sorting &amp; Pagination: <pre><code>// Get 5 nearest enemies\nvar nearest = _world.Query()\n    .With&lt;EnemyComponent&gt;()\n    .OrderBy(e =&gt; Vector2.Distance(\n        e.GetComponent&lt;TransformComponent&gt;().Position, \n        playerPosition))\n    .Take(5)\n    .Execute();\n\n// Paginate results\nvar page2 = _world.Query()\n    .With&lt;ItemComponent&gt;()\n    .Skip(10)\n    .Take(10)\n    .Execute();</code></pre></p> <p>Multi-Tag Queries: <pre><code>// Must have ALL tags\nvar bosses = _world.Query()\n    .WithAllTags(\"Enemy\", \"Boss\", \"Elite\")\n    .Execute();\n\n// Must have ANY tag\nvar targets = _world.Query()\n    .WithAnyTag(\"Enemy\", \"NPC\", \"Breakable\")\n    .Execute();</code></pre></p> <p>Query Cloning: <pre><code>// Create base query\nvar enemyQuery = _world.Query()\n    .With&lt;EnemyComponent&gt;()\n    .Without&lt;DeadComponent&gt;();\n\n// Clone and customize\nvar weakEnemies = enemyQuery.Clone()\n    .With&lt;HealthComponent&gt;(h =&gt; h.CurrentHealth &lt; 30)\n    .Execute();\n\nvar strongEnemies = enemyQuery.Clone()\n    .With&lt;HealthComponent&gt;(h =&gt; h.CurrentHealth &gt; 80)\n    .OrderByDescending(e =&gt; e.GetComponent&lt;HealthComponent&gt;().CurrentHealth)\n    .Execute();</code></pre></p> <p>See Query System Guide</p>"},{"location":"whats-new/v-0.6.0-beta/#camera-follow-system","title":"Camera Follow System","text":"<p>Automatic camera tracking with smooth movement and constraints:</p> <pre><code>var cameraFollow = player.AddComponent&lt;CameraFollowComponent&gt;();\ncameraFollow.CameraName = \"Main\";\ncameraFollow.Smoothing = 5f; // Higher = slower, smoother follow\ncameraFollow.Offset = new Vector2(0, -50); // Camera offset from target\ncameraFollow.Deadzone = new Vector2(50, 30); // Don't move within deadzone\ncameraFollow.FollowX = true; // Follow horizontal movement\ncameraFollow.FollowY = true; // Follow vertical movement\ncameraFollow.Priority = 10; // Higher priority targets take precedence</code></pre> <p>Features: - Smooth Following - Configurable smoothing/lerp speed - Deadzone Support - Reduce camera jitter - Offset Control - Position camera relative to target - Priority System - Multiple targets with automatic switching - Axis Control - Enable/disable X or Y following independently</p> <p>See Camera System Guide</p>"},{"location":"whats-new/v-0.6.0-beta/#enhanced-particle-system","title":"Enhanced Particle System","text":"<p>Pooled particle effects with zero GC pressure:</p> <pre><code>var emitter = entity.AddComponent&lt;ParticleEmitterComponent&gt;();\nemitter.IsEmitting = true;\nemitter.EmissionRate = 50f; // Particles per second\nemitter.MaxParticles = 200;\nemitter.ParticleLifetime = 2f;\n\n// Appearance\nemitter.StartColor = new Color(255, 200, 0, 255);\nemitter.EndColor = new Color(255, 50, 0, 0); // Fade to transparent\nemitter.StartSize = 8f;\nemitter.EndSize = 2f;\n\n// Physics\nemitter.InitialVelocity = new Vector2(0, -50);\nemitter.VelocitySpread = 30f; // Random angle variance\nemitter.Gravity = new Vector2(0, 100);\nemitter.SpawnRadius = 10f; // Random spawn area\n\n// Statistics\nLogger.LogInfo($\"Active particles: {emitter.ParticleCount}\");</code></pre> <p>Features: - Object Pooling - Particles reused, zero GC allocations - Color Interpolation - Smooth color transitions - Size Interpolation - Shrink/grow over lifetime - Physics Simulation - Gravity and velocity - Configurable Emission - Rate, lifetime, and spawn area - Performance Stats - Track active particle count</p> <p>See Particle System Guide</p>"},{"location":"whats-new/v-0.6.0-beta/#api-improvements","title":"API Improvements","text":""},{"location":"whats-new/v-0.6.0-beta/#cached-entity-queries","title":"Cached Entity Queries","text":"<p>High-performance queries that automatically update:</p> <pre><code>// Create cached query (one-time setup)\nvar movingEntities = _world.CreateCachedQuery&lt;TransformComponent, VelocityComponent&gt;();\n\n// Use in systems (zero allocation!)\npublic void Update(GameTime gameTime)\n{\n    foreach (var entity in movingEntities.Execute())\n    {\n        var transform = entity.GetComponent&lt;TransformComponent&gt;();\n        var velocity = entity.GetComponent&lt;VelocityComponent&gt;();\n\n        transform.Position += velocity.Velocity * deltaTime;\n    }\n}</code></pre> <p>Benefits: - Results cached and automatically invalidated on entity/component changes - Zero allocation per frame - Supports up to 3 component types - Perfect for system hot paths</p>"},{"location":"whats-new/v-0.6.0-beta/#transform-hierarchy-improvements","title":"Transform Hierarchy Improvements","text":"<p>Better memory management for parent/child relationships:</p> <pre><code>// Clear all children efficiently (uses ArrayPool)\ntransform.ClearChildren();\n\n// Iterate children without allocation\nforeach (var child in transform.Children)\n{\n    // Process child\n}</code></pre>"},{"location":"whats-new/v-0.6.0-beta/#bug-fixes","title":"Bug Fixes","text":""},{"location":"whats-new/v-0.6.0-beta/#performance","title":"Performance","text":"<ul> <li>Fixed memory leak in particle system when particles expired</li> <li>Fixed unnecessary allocations in <code>Entity.OnUpdate()</code> component iteration</li> <li>Fixed allocation in <code>ParticleSystem.Render()</code> (removed <code>.ToList()</code>)</li> <li>Optimized <code>EntityQuery.Random()</code> to use <code>ArrayPool&lt;T&gt;</code></li> </ul>"},{"location":"whats-new/v-0.6.0-beta/#ecs","title":"ECS","text":"<ul> <li>Fixed entity component iteration thread safety issues</li> <li>Fixed transform hierarchy cleanup on entity destruction</li> <li>Fixed cached query invalidation edge cases</li> </ul>"},{"location":"whats-new/v-0.6.0-beta/#rendering","title":"Rendering","text":"<ul> <li>Fixed sprite batching layer sorting inconsistencies</li> <li>Fixed camera follow jitter with high smoothing values</li> <li>Fixed frustum culling boundary precision issues</li> </ul>"},{"location":"whats-new/v-0.6.0-beta/#input","title":"Input","text":"<ul> <li>Fixed text input handling for special keys (backspace, delete, enter)</li> <li>Fixed gamepad axis deadzone calculations</li> </ul>"},{"location":"whats-new/v-0.6.0-beta/#documentation","title":"Documentation","text":""},{"location":"whats-new/v-0.6.0-beta/#new-guides","title":"New Guides","text":"<ul> <li>Performance Monitoring - FPS counter, profiling, and metrics</li> <li>Performance Optimization - Zero-allocation patterns, pooling</li> <li>Particle System - Creating particle effects</li> <li>Advanced Queries - Updated with spatial queries and filtering</li> </ul>"},{"location":"whats-new/v-0.6.0-beta/#updated-guides","title":"Updated Guides","text":"<ul> <li>Camera System - Added camera follow component</li> <li>Drawing Primitives - Corrected hotkey documentation</li> <li>ECS Getting Started - Added pooling best practices</li> </ul>"},{"location":"whats-new/v-0.6.0-beta/#new-demo-scenes","title":"New Demo Scenes","text":""},{"location":"whats-new/v-0.6.0-beta/#performance-benchmark-scene","title":"Performance Benchmark Scene","text":"<p>Stress test sprite batching with 10,000+ sprites:</p> <pre><code>cd samples/FeatureDemos\ndotnet run\n# Select \"Performance Benchmark\" from menu</code></pre> <p>Features: - Add/remove sprites dynamically (UP/DOWN: \u00b1100, LEFT/RIGHT: \u00b11000) - Move camera to see frustum culling (WASD) - Zoom camera (Q/E) - Toggle culling visualization (C) - Real-time batching statistics</p>"},{"location":"whats-new/v-0.6.0-beta/#enhanced-query-demo","title":"Enhanced Query Demo","text":"<p>Interactive demonstration of all query features:</p> <ul> <li>Spatial queries (WithinRadius, WithinBounds)</li> <li>Component filtering with predicates</li> <li>Multi-tag queries (WithAllTags, WithAnyTag)</li> <li>Sorting and pagination</li> <li>Random selection</li> <li>Query cloning</li> </ul>"},{"location":"whats-new/v-0.6.0-beta/#enhanced-particle-demo","title":"Enhanced Particle Demo","text":"<p>5 pre-configured particle effects:</p> <ul> <li>Fire</li> <li>Explosion</li> <li>Smoke</li> <li>Sparkles</li> <li>Trail</li> </ul> <p>Toggle continuous/burst emission, adjust parameters in real-time.</p>"},{"location":"whats-new/v-0.6.0-beta/#performance-metrics","title":"Performance Metrics","text":""},{"location":"whats-new/v-0.6.0-beta/#sprite-rendering","title":"Sprite Rendering","text":"<ul> <li>Baseline: 1,000 sprites @ 60 FPS</li> <li>Stress Test: 10,000+ sprites @ 60 FPS with batching</li> <li>Draw Calls: 1-5 (depending on texture variety)</li> <li>Batch Efficiency: 10-50x reduction in draw calls</li> </ul>"},{"location":"whats-new/v-0.6.0-beta/#memory-management","title":"Memory Management","text":"<ul> <li>Entity Updates: Zero allocation (uses <code>ArrayPool&lt;T&gt;</code>)</li> <li>Query System: Zero allocation for cached queries</li> <li>Particle System: Zero allocation per frame (object pooling)</li> <li>GC Collections: Significantly reduced Gen 2 collections</li> </ul>"},{"location":"whats-new/v-0.6.0-beta/#breaking-changes","title":"Breaking Changes","text":"<p>None! </p> <p>Version 0.6.0-beta maintains full API compatibility with 0.5.0-beta. All existing code will continue to work without modifications.</p>"},{"location":"whats-new/v-0.6.0-beta/#updated-dependencies","title":"Updated Dependencies","text":"<ul> <li>.NET 10 SDK - Required</li> <li>SDL3-CS - Updated to latest version</li> <li>Microsoft.Extensions.* - Updated to .NET 10 versions</li> </ul>"},{"location":"whats-new/v-0.6.0-beta/#upgrade-guide","title":"Upgrade Guide","text":""},{"location":"whats-new/v-0.6.0-beta/#from-050-beta","title":"From 0.5.0-beta","text":"<p>Update your package references:</p> <pre><code>&lt;ItemGroup&gt;\n  &lt;PackageReference Include=\"Brine2D.Desktop\" Version=\"0.6.0-beta\" /&gt;\n&lt;/ItemGroup&gt;</code></pre> <p>Or via command line:</p> <pre><code>dotnet add package Brine2D.Desktop --version 0.6.0-beta</code></pre> <p>No code changes required! Your 0.5.0-beta code will work as-is.</p>"},{"location":"whats-new/v-0.6.0-beta/#optional-enable-performance-monitoring","title":"Optional: Enable Performance Monitoring","text":"<p>Add to your game builder:</p> <pre><code>builder.Services.AddPerformanceMonitoring(options =&gt;\n{\n    options.EnableOverlay = true;\n    options.ShowFPS = true;\n    options.ShowFrameTime = true;\n    options.ShowMemory = true;\n});</code></pre>"},{"location":"whats-new/v-0.6.0-beta/#whats-next-v070","title":"What's Next (v0.7.0)","text":"<ul> <li>GPU Renderer - Complete SDL3 GPU backend</li> <li>Texture Atlases - Automatic sprite sheet packing</li> <li>Post-Processing - Shaders and effects pipeline</li> <li>Spatial Audio - 3D sound positioning</li> <li>Multi-Threading - Parallel ECS system execution</li> <li>Enhanced Documentation - Video tutorials and advanced guides</li> </ul>"},{"location":"whats-new/v-0.6.0-beta/#contributors","title":"Contributors","text":"<p>Thank you to everyone who contributed to this release!</p> <ul> <li>Report bugs: GitHub Issues</li> <li>Suggest features: GitHub Discussions</li> <li>Contribute code: See CONTRIBUTING.md</li> </ul> <p>Full Changelog: v0.5.0-beta...v0.6.0-beta</p>"},{"location":"whats-new/v-0.7.0-beta/","title":"What's New in v0.7.0-beta","text":"<p>Version 0.7.0-beta introduces a modern GPU-accelerated renderer alongside major architectural improvements for better performance and flexibility.</p>"},{"location":"whats-new/v-0.7.0-beta/#release-highlights","title":"Release Highlights","text":"<ul> <li>SDL3 GPU Renderer - Modern shader-based rendering with Vulkan/Metal/D3D11/D3D12 support</li> <li>Rendering Backends - Choose between GPU and Legacy renderer at runtime</li> <li>EventBus Core Integration - Moved to <code>Brine2D.Core</code> for global event handling</li> <li>Window Events - Built-in support for window resize and lifecycle events</li> <li>GPU Driver Selection - Configure preferred graphics API</li> </ul>"},{"location":"whats-new/v-0.7.0-beta/#major-features","title":"Major Features","text":""},{"location":"whats-new/v-0.7.0-beta/#1-sdl3-gpu-renderer","title":"1. SDL3 GPU Renderer","text":"<p>The new <code>SDL3GPURenderer</code> provides modern, shader-based rendering with cross-platform GPU API support.</p> <p>Key Features: - Modern GPU APIs: Vulkan, Metal, D3D11, D3D12 - Shader-based rendering: Custom shader pipeline - 10,000+ vertex batching: High-performance sprite rendering - Cross-platform: Automatic API selection per platform</p> <p>Example:</p> <pre><code>builder.Services.AddSDL3Rendering(options =&gt;\n{\n    options.Backend = GraphicsBackend.GPU;  // New GPU renderer (default)\n    options.PreferredGPUDriver = \"Vulkan\"; // Optional: force Vulkan\n});</code></pre> <p>Benefits: - Faster rendering for complex scenes - Better texture management - Modern GPU features - Future-proof architecture</p>"},{"location":"whats-new/v-0.7.0-beta/#2-rendering-backend-selection","title":"2. Rendering Backend Selection","text":"<p>New <code>GraphicsBackend</code> enum allows runtime renderer selection.</p> <p>Available Backends:</p> Backend Description When to Use <code>GPU</code> Modern shader-based renderer (default) Most games, best performance <code>LegacyRenderer</code> Classic SDL_Renderer API Compatibility, older systems <code>Auto</code> Automatically selects GPU Recommended for new projects <p>Configuration:</p> <pre><code>{\n  \"Rendering\": {\n    \"Backend\": \"GPU\",\n    \"WindowTitle\": \"My Game\",\n    \"WindowWidth\": 1280,\n    \"WindowHeight\": 720,\n    \"PreferredGPUDriver\": null  // Auto-select, or \"Vulkan\"/\"Metal\"/\"D3D11\"/\"D3D12\"\n  }\n}</code></pre> <pre><code>builder.Services.AddSDL3Rendering(options =&gt;\n{\n    builder.Configuration.GetSection(\"Rendering\").Bind(options);\n});</code></pre> <p>Switching Backends:</p> <pre><code>// GPU renderer (recommended)\noptions.Backend = GraphicsBackend.GPU;\n\n// Legacy renderer (compatibility)\noptions.Backend = GraphicsBackend.LegacyRenderer;\n\n// Auto-select (defaults to GPU)\noptions.Backend = GraphicsBackend.Auto;</code></pre>"},{"location":"whats-new/v-0.7.0-beta/#3-eventbus-moved-to-core","title":"3. EventBus Moved to Core","text":"<p><code>EventBus</code> relocated from <code>Brine2D.ECS</code> to <code>Brine2D.Core</code> for global accessibility.</p> <p>Before (v0.6.0):</p> <pre><code>using Brine2D.ECS; // Old location\n\npublic class MyScene : Scene\n{\n    private readonly EventBus _eventBus;\n\n    public MyScene(EventBus eventBus) // Only available with ECS\n    {\n        _eventBus = eventBus;\n    }\n}</code></pre> <p>After (v0.7.0):</p> <pre><code>using Brine2D.Core; // New location\n\npublic class MyScene : Scene\n{\n    private readonly EventBus? _eventBus; // Optional, available globally\n\n    public MyScene(EventBus? eventBus) // Works without ECS\n    {\n        _eventBus = eventBus;\n    }\n}</code></pre> <p>Registration:</p> <pre><code>// EventBus is now optional\nbuilder.Services.AddSingleton&lt;EventBus&gt;();</code></pre> <p>Benefits: - Use events without ECS dependency - Available in all scenes and systems - Cleaner architecture</p>"},{"location":"whats-new/v-0.7.0-beta/#4-window-lifecycle-events","title":"4. Window Lifecycle Events","text":"<p>Built-in window events for responsive rendering.</p> <p>New Events:</p> <pre><code>// Window resized event\npublic record WindowResizedEvent(int Width, int Height);\n\n// Available in Brine2D.SDL.Common.Events namespace</code></pre> <p>Example Usage:</p> <pre><code>using Brine2D.Core;\nusing Brine2D.SDL.Common.Events;\n\npublic class ResponsiveScene : Scene\n{\n    private readonly EventBus? _eventBus;\n    private readonly IRenderer _renderer;\n\n    public ResponsiveScene(\n        EventBus? eventBus,\n        IRenderer renderer,\n        ILogger&lt;ResponsiveScene&gt; logger) : base(logger)\n    {\n        _eventBus = eventBus;\n        _renderer = renderer;\n    }\n\n    protected override void OnInitialize()\n    {\n        // Subscribe to window resize\n        _eventBus?.Subscribe&lt;WindowResizedEvent&gt;(OnWindowResized);\n    }\n\n    private void OnWindowResized(WindowResizedEvent evt)\n    {\n        Logger.LogInformation(\"Window resized to {Width}x{Height}\", \n            evt.Width, evt.Height);\n\n        // Update camera, UI layout, etc.\n        UpdateUILayout(evt.Width, evt.Height);\n    }\n\n    protected override void OnDispose()\n    {\n        // Clean up subscription\n        _eventBus?.Unsubscribe&lt;WindowResizedEvent&gt;(OnWindowResized);\n    }\n}</code></pre> <p>Renderer Integration:</p> <p>Both renderers now automatically subscribe to <code>WindowResizedEvent</code> for viewport updates.</p>"},{"location":"whats-new/v-0.7.0-beta/#5-gpu-driver-selection","title":"5. GPU Driver Selection","text":"<p>Configure preferred graphics API for the GPU renderer.</p> <p>Options:</p> <pre><code>builder.Services.AddSDL3Rendering(options =&gt;\n{\n    options.Backend = GraphicsBackend.GPU;\n\n    // Force specific GPU API\n    options.PreferredGPUDriver = \"Vulkan\";  // Vulkan\n    // OR\n    options.PreferredGPUDriver = \"Metal\";   // Metal (macOS/iOS)\n    // OR\n    options.PreferredGPUDriver = \"D3D11\";   // Direct3D 11 (Windows)\n    // OR\n    options.PreferredGPUDriver = \"D3D12\";   // Direct3D 12 (Windows)\n    // OR\n    options.PreferredGPUDriver = null;      // Auto-select (recommended)\n});</code></pre> <p>Platform Defaults: - Windows: D3D11 or D3D12 - macOS/iOS: Metal - Linux: Vulkan - Android: Vulkan</p> <p>When to Override: - Testing specific GPU APIs - Performance comparison - Known driver issues - Development debugging</p>"},{"location":"whats-new/v-0.7.0-beta/#breaking-changes","title":"Breaking Changes","text":""},{"location":"whats-new/v-0.7.0-beta/#eventbus-namespace-change","title":"EventBus Namespace Change","text":"<p>Action Required: Update <code>using</code> statements if using <code>EventBus</code>.</p> <pre><code>// Old (v0.6.0)\nusing Brine2D.ECS;\n\n// New (v0.7.0)\nusing Brine2D.Core;</code></pre> <p>Migration:</p> <ol> <li>Find and replace: <code>using Brine2D.ECS;</code> \u2192 <code>using Brine2D.Core;</code> (where EventBus is used)</li> <li>Make EventBus optional: <code>EventBus eventBus</code> \u2192 <code>EventBus? eventBus</code></li> <li>Register EventBus if needed: <code>builder.Services.AddSingleton&lt;EventBus&gt;();</code></li> </ol>"},{"location":"whats-new/v-0.7.0-beta/#renderer-constructor-signature","title":"Renderer Constructor Signature","text":"<p>Renderers now accept optional <code>EventBus</code> parameter.</p> <p>If you manually instantiate renderers (rare):</p> <pre><code>// Old (v0.6.0)\nvar renderer = new SDL3Renderer(\n    logger,\n    loggerFactory,\n    options,\n    fontLoader);\n\n// New (v0.7.0)\nvar renderer = new SDL3Renderer(\n    logger,\n    loggerFactory,\n    options,\n    fontLoader,\n    eventBus);  // New optional parameter\n\n// Or with GPU renderer\nvar gpuRenderer = new SDL3GPURenderer(\n    logger,\n    loggerFactory,\n    options,\n    fontLoader,\n    eventBus);  // New optional parameter</code></pre> <p>Most users won't need changes - DI handles this automatically.</p>"},{"location":"whats-new/v-0.7.0-beta/#upgrade-guide","title":"Upgrade Guide","text":""},{"location":"whats-new/v-0.7.0-beta/#step-1-update-configuration","title":"Step 1: Update Configuration","text":"<p>Add <code>Backend</code> option to <code>gamesettings.json</code>:</p> <pre><code>{\n  \"Rendering\": {\n    \"Backend\": \"GPU\",\n    \"WindowTitle\": \"My Game\",\n    \"WindowWidth\": 1280,\n    \"WindowHeight\": 720\n  }\n}</code></pre>"},{"location":"whats-new/v-0.7.0-beta/#step-2-update-eventbus-imports","title":"Step 2: Update EventBus Imports","text":"<p>Replace old namespace:</p> <pre><code>// Find this:\nusing Brine2D.ECS;\n\n// Replace with (only where EventBus is used):\nusing Brine2D.Core;</code></pre>"},{"location":"whats-new/v-0.7.0-beta/#step-3-optional-register-eventbus","title":"Step 3: Optional - Register EventBus","text":"<p>If using custom events:</p> <pre><code>builder.Services.AddSingleton&lt;EventBus&gt;();</code></pre>"},{"location":"whats-new/v-0.7.0-beta/#step-4-test-your-game","title":"Step 4: Test Your Game","text":"<ol> <li>Run with GPU renderer (default)</li> <li>Test window resizing</li> <li>Verify graphics display correctly</li> </ol>"},{"location":"whats-new/v-0.7.0-beta/#performance-improvements","title":"Performance Improvements","text":""},{"location":"whats-new/v-0.7.0-beta/#gpu-renderer-benchmarks","title":"GPU Renderer Benchmarks","text":"<p>Comparison vs Legacy Renderer (same hardware):</p> Scenario Legacy Renderer GPU Renderer Improvement 1,000 sprites 60 FPS 60 FPS - 5,000 sprites 45 FPS 60 FPS 33% faster 10,000 sprites 25 FPS 60 FPS 140% faster Texture switches Expensive Optimized Reduced overhead <p>GPU Renderer is recommended for: - Games with 1,000+ sprites - Complex particle systems - Dynamic lighting/effects - Modern hardware</p> <p>Legacy Renderer is suitable for: - Simple 2D games - Older hardware - Compatibility requirements</p>"},{"location":"whats-new/v-0.7.0-beta/#migration-checklist","title":"Migration Checklist","text":"<ul> <li>[ ] Update <code>gamesettings.json</code> with <code>Backend</code> option</li> <li>[ ] Change <code>using Brine2D.ECS;</code> to <code>using Brine2D.Core;</code> (for EventBus)</li> <li>[ ] Optional: Register <code>EventBus</code> if using custom events</li> <li>[ ] Test with GPU renderer (default)</li> <li>[ ] Verify window resizing works correctly</li> <li>[ ] Check sprite rendering performance</li> <li>[ ] Test on target platforms</li> </ul>"},{"location":"whats-new/v-0.7.0-beta/#documentation-updates","title":"Documentation Updates","text":"<p>Updated guides for v0.7.0:</p> <ul> <li>Dependency Injection - Renderer selection, EventBus</li> <li>Configuration - Backend options</li> <li>Quick Start - GPU renderer setup</li> </ul>"},{"location":"whats-new/v-0.7.0-beta/#known-issues","title":"Known Issues","text":"<ol> <li>GPU Renderer on very old hardware - May fall back to software rendering</li> <li> <p>Solution: Use <code>Backend = \"LegacyRenderer\"</code></p> </li> <li> <p>Metal support on macOS - Requires macOS 10.15+</p> </li> <li> <p>Solution: System requirement, or use Legacy renderer</p> </li> <li> <p>Vulkan on Windows 7 - Not supported</p> </li> <li>Solution: Upgrade to Windows 10+, or use <code>PreferredGPUDriver = \"D3D11\"</code></li> </ol>"},{"location":"whats-new/v-0.7.0-beta/#future-plans","title":"Future Plans","text":"<p>Coming in future versions:</p> <ul> <li>Custom shaders - User-defined rendering effects</li> <li>Render-to-texture - Off-screen rendering</li> <li>Post-processing - Screen effects, filters</li> <li>3D rendering support - Basic 3D primitives</li> </ul>"},{"location":"whats-new/v-0.7.0-beta/#feedback","title":"Feedback","text":"<p>We'd love to hear about your experience with v0.7.0-beta!</p> <ul> <li>Report bugs: GitHub Issues</li> <li>Feature requests: GitHub Discussions</li> <li>Discord: Join our community server</li> </ul>"},{"location":"whats-new/v-0.7.0-beta/#summary","title":"Summary","text":"<p>Version 0.7.0-beta focuses on modern rendering architecture:</p> <ul> <li>SDL3 GPU Renderer - High-performance, shader-based rendering</li> <li>Backend selection - GPU vs Legacy, configurable</li> <li>EventBus improvements - Global accessibility</li> <li>Window events - Responsive rendering</li> <li>GPU driver control - Fine-tune graphics API</li> </ul> <p>Upgrade today for better performance and modern rendering capabilities!</p>"},{"location":"whats-new/v-0.7.0-beta/#changelog","title":"Changelog","text":""},{"location":"whats-new/v-0.7.0-beta/#added","title":"Added","text":"<ul> <li><code>SDL3GPURenderer</code> - Modern GPU-accelerated renderer</li> <li><code>GraphicsBackend</code> enum - Runtime backend selection (GPU/Legacy/Auto)</li> <li><code>WindowResizedEvent</code> - Window resize event handling</li> <li><code>PreferredGPUDriver</code> configuration option</li> <li>EventBus in <code>Brine2D.Core</code> namespace</li> </ul>"},{"location":"whats-new/v-0.7.0-beta/#changed","title":"Changed","text":"<ul> <li>EventBus moved from <code>Brine2D.ECS</code> to <code>Brine2D.Core</code></li> <li>Renderer constructors accept optional <code>EventBus</code> parameter</li> <li>GPU renderer is now the default backend</li> <li>Both renderers subscribe to window events</li> </ul>"},{"location":"whats-new/v-0.7.0-beta/#fixed","title":"Fixed","text":"<ul> <li>Window resize viewport updates</li> <li>Texture memory management improvements</li> <li>Shader compilation error handling</li> </ul>"},{"location":"whats-new/v-0.7.0-beta/#deprecated","title":"Deprecated","text":"<ul> <li>None</li> </ul>"},{"location":"whats-new/v-0.7.0-beta/#removed","title":"Removed","text":"<ul> <li>None</li> </ul> <p>\u2190 Back to What's New | Installation Guide \u2192</p>"},{"location":"whats-new/v-0.8.0-beta/","title":"What's New in v0.8.0-beta","text":"<p>Version 0.8.0-beta delivers production-ready audio and visual effects systems with runtime texture packing, 2D spatial audio, and a massively enhanced particle system.</p>"},{"location":"whats-new/v-0.8.0-beta/#release-highlights","title":"Release Highlights","text":"<ul> <li>Texture Atlasing - Runtime sprite packing with intelligent bin packing</li> <li>2D Spatial Audio - Distance attenuation and stereo panning</li> <li>Advanced Particle System - Textures, rotation, trails, blend modes, 7 emitter shapes</li> <li>Audio Callbacks - Proper track lifecycle management via SDL3_mixer</li> <li>Rotation Support - SpriteBatcher now respects rotation transforms</li> </ul>"},{"location":"whats-new/v-0.8.0-beta/#major-features","title":"Major Features","text":""},{"location":"whats-new/v-0.8.0-beta/#1-texture-atlasing","title":"1. Texture Atlasing","text":"<p>Runtime texture packing dramatically reduces draw calls by combining multiple sprites into single textures.</p> <p>Key Features: - Intelligent bin packing: Automatic sprite layout optimization - Runtime generation: No prebuild step required - Automatic batching: Renderer uses atlases transparently - Memory efficient: Shared texture memory across sprites</p> <p>Creating an Atlas:</p> <pre><code>using Brine2D.Rendering;\n\n// Load individual textures\nvar texture1 = await _textureLoader.LoadTextureAsync(\"assets/sprite1.png\");\nvar texture2 = await _textureLoader.LoadTextureAsync(\"assets/sprite2.png\");\nvar texture3 = await _textureLoader.LoadTextureAsync(\"assets/sprite3.png\");\n\n// Build atlas\nvar atlas = await AtlasBuilder.BuildAtlasAsync(\n    _renderer,\n    _textureLoader,\n    new[] { texture1, texture2, texture3 },\n    padding: 2,  // Pixels between sprites\n    maxSize: 2048  // Max atlas dimension\n);\n\n// Use packed sprites\nvar region1 = atlas.GetRegion(texture1);\n_renderer.DrawTexture(\n    atlas.AtlasTexture,\n    region1.SourceRect.X, region1.SourceRect.Y,\n    region1.SourceRect.Width, region1.SourceRect.Height,\n    x, y, width, height\n);</code></pre> <p>ECS Integration:</p> <pre><code>// Components automatically use atlas if available\nvar sprite = entity.AddComponent&lt;SpriteComponent&gt;();\nsprite.TexturePath = \"assets/player.png\";  // Will use atlas if packed\nsprite.Layer = 10;\n\n// SpriteRenderingSystem handles atlas lookup automatically</code></pre> <p>Performance Benefits:</p> Sprites Without Atlas With Atlas Improvement 100 unique textures 100 draw calls 1 draw call 99% reduction 1,000 sprites (10 textures) 10 draw calls 1 draw call 90% reduction Texture switches Expensive Eliminated Major performance gain <p>Best Practices: - Pack sprites that render together (same layer, similar lifecycle) - Use 2-4px padding to prevent bleeding - Limit atlas size to 2048x2048 for compatibility - Pack UI elements separately from game sprites</p>"},{"location":"whats-new/v-0.8.0-beta/#2-2d-spatial-audio","title":"2. 2D Spatial Audio","text":"<p>Positional audio with distance attenuation and stereo panning brings your game world to life.</p> <p>Key Features: - Distance attenuation: Sounds fade based on distance from listener - Stereo panning: Left/right audio positioning - Configurable falloff: Linear, quadratic, or custom curves - ECS integration: Component-based audio sources and listeners</p> <p>Basic Setup:</p> <pre><code>using Brine2D.Audio.ECS;\n\n// Create audio listener (usually on player/camera)\nvar player = _world.CreateEntity(\"Player\");\nvar listener = player.AddComponent&lt;AudioListenerComponent&gt;();\nlistener.GlobalSpatialVolume = 1.0f;  // Master spatial audio volume\n\n// Create audio source\nvar enemy = _world.CreateEntity(\"Enemy\");\nvar audioSource = enemy.AddComponent&lt;AudioSourceComponent&gt;();\naudioSource.SoundEffect = enemySound;\naudioSource.EnableSpatialAudio = true;\n\n// Configure distance attenuation\naudioSource.MinDistance = 100f;  // Full volume within this range\naudioSource.MaxDistance = 500f;  // Silent beyond this range\naudioSource.RolloffFactor = 1.0f;  // 1.0 = linear, 2.0 = quadratic\n\n// Configure stereo panning\naudioSource.SpatialBlend = 1.0f;  // 0.0 = mono (center), 1.0 = full stereo\n\n// Start playing\naudioSource.Loop = true;\naudioSource.LoopCount = -1;  // Infinite loop\naudioSource.PlayOnEnable = true;</code></pre> <p>Distance Attenuation Curves:</p> <pre><code>// Linear falloff (smooth, natural)\naudioSource.RolloffFactor = 1.0f;\n\n// Quadratic falloff (faster dropoff, more dramatic)\naudioSource.RolloffFactor = 2.0f;\n\n// Custom falloff (exponential)\naudioSource.RolloffFactor = 1.5f;\n\n// No falloff (constant volume within range)\naudioSource.RolloffFactor = 0f;</code></pre> <p>Runtime Position Updates:</p> <pre><code>// AudioSystem automatically updates spatial audio every frame\n// based on TransformComponent positions\n\n// Move player\nplayerTransform.Position = new Vector2(500, 300);\n\n// Move sound source\nenemyTransform.Position = new Vector2(200, 300);\n\n// Distance and panning calculated automatically!\n// Sounds adjust in real-time as entities move</code></pre> <p>Manual Control:</p> <pre><code>// Trigger one-shot sound\naudioSource.TriggerPlay = true;\n\n// Stop playing\naudioSource.TriggerStop = true;\n\n// Toggle on/off\naudioSource.IsEnabled = !audioSource.IsEnabled;\n\n// Check state\nif (audioSource.IsPlaying)\n{\n    Logger.LogInfo($\"Volume: {audioSource.SpatialVolume}, Pan: {audioSource.SpatialPan}\");\n}</code></pre> <p>System Configuration:</p> <pre><code>// AudioSystem runs automatically in ECS pipeline\nbuilder.Services.ConfigureSystemPipelines(pipelines =&gt;\n{\n    pipelines.AddSystem&lt;AudioSystem&gt;();  // Update order: 300\n});</code></pre>"},{"location":"whats-new/v-0.8.0-beta/#3-advanced-particle-system","title":"3. Advanced Particle System","text":"<p>The particle system now supports textures, rotation, trails, and multiple blend modes.</p> <p>New Features:</p>"},{"location":"whats-new/v-0.8.0-beta/#particle-textures","title":"Particle Textures","text":"<pre><code>var emitter = entity.AddComponent&lt;ParticleEmitterComponent&gt;();\nemitter.TexturePath = \"assets/particle.png\";  // Use custom texture\nemitter.TextureScaleMode = TextureScaleMode.Nearest;  // Pixel-perfect scaling</code></pre>"},{"location":"whats-new/v-0.8.0-beta/#rotation","title":"Rotation","text":"<pre><code>// Particle rotation\nemitter.StartRotation = 0f;  // Starting angle (radians)\nemitter.EndRotation = MathF.PI * 2;  // End angle (full rotation)\nemitter.RotationSpeed = 2f;  // Radians per second (overrides lerp)\n\n// Random rotation variance\nemitter.RotationSpread = MathF.PI / 4;  // \u00b145 degrees</code></pre>"},{"location":"whats-new/v-0.8.0-beta/#trail-effects","title":"Trail Effects","text":"<pre><code>// Enable particle trails\nemitter.TrailEnabled = true;\nemitter.TrailLength = 10;  // Number of trail segments\nemitter.TrailColor = new Color(255, 100, 0, 128);  // Semi-transparent orange</code></pre>"},{"location":"whats-new/v-0.8.0-beta/#blend-modes","title":"Blend Modes","text":"<pre><code>// Additive blending (fire, explosions)\nemitter.BlendMode = BlendMode.Additive;\n\n// Alpha blending (smoke, fog)\nemitter.BlendMode = BlendMode.AlphaBlend;\n\n// No blending (solid particles)\nemitter.BlendMode = BlendMode.None;</code></pre>"},{"location":"whats-new/v-0.8.0-beta/#7-emitter-shapes","title":"7 Emitter Shapes","text":"<pre><code>// Point emitter (single spawn point)\nemitter.EmitterShape = EmitterShape.Point;\n\n// Circle emitter (spawn anywhere in circle)\nemitter.EmitterShape = EmitterShape.Circle;\nemitter.SpawnRadius = 20f;\n\n// Ring emitter (spawn on circle edge)\nemitter.EmitterShape = EmitterShape.Ring;\nemitter.SpawnRadius = 30f;\n\n// Box emitter (rectangular spawn area)\nemitter.EmitterShape = EmitterShape.Box;\nemitter.SpawnRadius = 50f;  // Half-width/height\n\n// Cone emitter (directional spray)\nemitter.EmitterShape = EmitterShape.Cone;\nemitter.ConeAngle = MathF.PI / 4;  // 45 degree cone\n\n// Line emitter (spawn along line)\nemitter.EmitterShape = EmitterShape.Line;\nemitter.LineLength = 100f;\n\n// Burst emitter (radial explosion)\nemitter.EmitterShape = EmitterShape.Burst;\nemitter.BurstCount = 50;  // Particles per burst</code></pre> <p>Complete Example - Fire Effect:</p> <pre><code>var fire = _world.CreateEntity(\"FireEffect\");\nvar transform = fire.AddComponent&lt;TransformComponent&gt;();\ntransform.Position = new Vector2(640, 500);\n\nvar emitter = fire.AddComponent&lt;ParticleEmitterComponent&gt;();\n\n// Appearance\nemitter.TexturePath = \"assets/particles/fire.png\";\nemitter.BlendMode = BlendMode.Additive;\nemitter.StartColor = new Color(255, 200, 0, 255);  // Bright yellow\nemitter.EndColor = new Color(255, 50, 0, 0);  // Fade to transparent red\nemitter.StartSize = 8f;\nemitter.EndSize = 2f;\n\n// Rotation\nemitter.StartRotation = 0f;\nemitter.RotationSpeed = 2f;\nemitter.RotationSpread = MathF.PI / 2;\n\n// Physics\nemitter.InitialVelocity = new Vector2(0, -100);  // Rise upward\nemitter.VelocitySpread = 30f;\nemitter.Gravity = new Vector2(0, -20);  // Slight upward pull\n\n// Emission\nemitter.EmitterShape = EmitterShape.Circle;\nemitter.SpawnRadius = 15f;\nemitter.EmissionRate = 100f;  // Particles per second\nemitter.ParticleLifetime = 1.5f;\nemitter.MaxParticles = 200;\n\n// Trails\nemitter.TrailEnabled = true;\nemitter.TrailLength = 5;\nemitter.TrailColor = new Color(255, 100, 0, 100);\n\nemitter.IsEmitting = true;</code></pre>"},{"location":"whats-new/v-0.8.0-beta/#4-audio-track-callbacks","title":"4. Audio Track Callbacks","text":"<p>SDL3_mixer callbacks now properly notify when tracks finish playing.</p> <p>What Changed: - Tracks automatically clean up when finished - <code>IsPlaying</code> state accurately reflects playback - No more orphaned track handles - Thread-safe callback handling</p> <p>Benefits: - One-shot sounds properly complete - Looping sounds restart seamlessly - Memory management improved - Better debugging with accurate state</p> <p>Implementation Details:</p> <pre><code>// AudioSystem automatically handles callbacks\n// You don't need to do anything special\n\n// But you can observe state:\nif (audioSource.IsPlaying)\n{\n    // Sound is actively playing\n}\nelse\n{\n    // Sound finished or was stopped\n}</code></pre>"},{"location":"whats-new/v-0.8.0-beta/#5-spritebatcher-rotation-support","title":"5. SpriteBatcher Rotation Support","text":"<p>SpriteBatcher now properly applies rotation transforms.</p> <p>Before (v0.7.0): <pre><code>// Rotation was ignored\nsprite.Rotation = MathF.PI / 4;  // Had no effect</code></pre></p> <p>After (v0.8.0): <pre><code>// Rotation works correctly\nsprite.Rotation = MathF.PI / 4;  // Sprite rotates 45 degrees\nsprite.Origin = new Vector2(0.5f, 0.5f);  // Rotate around center</code></pre></p>"},{"location":"whats-new/v-0.8.0-beta/#breaking-changes","title":"Breaking Changes","text":"<p>None! Version 0.8.0-beta is fully backward compatible with 0.7.0-beta.</p> <p>All new features are additive - existing code continues to work without changes.</p>"},{"location":"whats-new/v-0.8.0-beta/#upgrade-guide","title":"Upgrade Guide","text":""},{"location":"whats-new/v-0.8.0-beta/#step-1-update-nuget-packages","title":"Step 1: Update NuGet Packages","text":"<pre><code>dotnet add package Brine2D.Desktop --version 0.8.0-beta</code></pre> <p>Or update your <code>.csproj</code>:</p> <pre><code>&lt;PackageReference Include=\"Brine2D.Desktop\" Version=\"0.8.0-beta\" /&gt;</code></pre>"},{"location":"whats-new/v-0.8.0-beta/#step-2-optional-enable-spatial-audio","title":"Step 2: Optional - Enable Spatial Audio","text":"<p>If using audio, add <code>AudioSystem</code> to your pipeline:</p> <pre><code>builder.Services.ConfigureSystemPipelines(pipelines =&gt;\n{\n    pipelines.AddSystem&lt;AudioSystem&gt;();  // Add this line\n});</code></pre>"},{"location":"whats-new/v-0.8.0-beta/#step-3-optional-use-texture-atlasing","title":"Step 3: Optional - Use Texture Atlasing","text":"<p>For games with many sprites, consider packing textures:</p> <pre><code>// At startup, pack your sprites\nvar atlas = await AtlasBuilder.BuildAtlasAsync(\n    _renderer,\n    _textureLoader,\n    myTextures,\n    padding: 2,\n    maxSize: 2048\n);\n\n// Store atlas for use in rendering\n_atlasCache.Add(\"ui\", atlas);</code></pre>"},{"location":"whats-new/v-0.8.0-beta/#step-4-optional-upgrade-particles","title":"Step 4: Optional - Upgrade Particles","text":"<p>Update particle emitters with new features:</p> <pre><code>// Add texture\nemitter.TexturePath = \"assets/particle.png\";\n\n// Add rotation\nemitter.RotationSpeed = 1f;\n\n// Add trails\nemitter.TrailEnabled = true;\nemitter.TrailLength = 8;\n\n// Set blend mode\nemitter.BlendMode = BlendMode.Additive;</code></pre>"},{"location":"whats-new/v-0.8.0-beta/#step-5-test-your-game","title":"Step 5: Test Your Game","text":"<ol> <li>Verify existing functionality works</li> <li>Test new features (audio, atlasing, particles)</li> <li>Check performance improvements</li> </ol>"},{"location":"whats-new/v-0.8.0-beta/#performance-improvements","title":"Performance Improvements","text":""},{"location":"whats-new/v-0.8.0-beta/#texture-atlasing-impact","title":"Texture Atlasing Impact","text":"<p>Real-world performance gains from texture packing:</p> Game Type Draw Calls (Before) Draw Calls (After) Improvement Platformer (50 sprites) 15 2 87% reduction Top-down shooter (200 sprites) 40 3 92% reduction UI-heavy game (100 buttons) 50 1 98% reduction <p>When to Use Atlasing: - Games with 10+ unique sprites rendered frequently - UI systems with many icons/buttons - Particle effects using sprite textures - Any game targeting lower-end hardware</p>"},{"location":"whats-new/v-0.8.0-beta/#spatial-audio-overhead","title":"Spatial Audio Overhead","text":"<p>Spatial audio calculations are highly optimized:</p> Entities Audio Update Time Impact on 60 FPS 10 sources 0.05ms Negligible 50 sources 0.2ms &lt; 2% 100 sources 0.4ms &lt; 3% <p>Optimization Tips: - Disable <code>EnableSpatialAudio</code> for non-positional sounds (music, UI) - Use larger <code>MinDistance</code> values to reduce calculations - Set <code>SpatialBlend = 0</code> for center-only sounds</p>"},{"location":"whats-new/v-0.8.0-beta/#migration-checklist","title":"Migration Checklist","text":"<ul> <li>[ ] Update NuGet packages to 0.8.0-beta</li> <li>[ ] Optional: Add <code>AudioSystem</code> to ECS pipeline</li> <li>[ ] Optional: Implement texture atlasing for sprites</li> <li>[ ] Optional: Add spatial audio to game entities</li> <li>[ ] Optional: Upgrade particle emitters with new features</li> <li>[ ] Test all existing functionality</li> <li>[ ] Verify performance improvements</li> </ul>"},{"location":"whats-new/v-0.8.0-beta/#documentation-updates","title":"Documentation Updates","text":"<p>New and updated guides for v0.8.0:</p> <ul> <li>Texture Atlasing - Runtime sprite packing</li> <li>Spatial Audio - 2D positional audio</li> <li>Particles - Updated with new features</li> <li>Samples - New demo scenes for atlasing and audio</li> </ul>"},{"location":"whats-new/v-0.8.0-beta/#known-issues","title":"Known Issues","text":"<ol> <li>Texture atlas max size - Limited to 2048x2048 on some hardware</li> <li> <p>Solution: Use multiple atlases or reduce texture count</p> </li> <li> <p>Spatial audio updates every frame - May impact performance with 100+ sources</p> </li> <li> <p>Solution: Disable spatial audio for distant/off-screen sources</p> </li> <li> <p>Particle trails with very short lifetimes - May flicker</p> </li> <li>Solution: Increase <code>ParticleLifetime</code> to at least 0.5s</li> </ol>"},{"location":"whats-new/v-0.8.0-beta/#future-plans","title":"Future Plans","text":"<p>Coming in v0.9.0-beta:</p> <ul> <li>Post-processing effects - Bloom, blur, color grading</li> <li>Multi-threaded ECS - Parallel system execution</li> <li>Render-to-texture - Off-screen rendering for effects</li> <li>Audio zones - Trigger sounds when entering areas</li> </ul>"},{"location":"whats-new/v-0.8.0-beta/#feedback","title":"Feedback","text":"<p>Share your experience with v0.8.0-beta:</p> <ul> <li>Report bugs: GitHub Issues</li> <li>Feature requests: GitHub Discussions</li> <li>Show your games: Share what you're building!</li> </ul>"},{"location":"whats-new/v-0.8.0-beta/#summary","title":"Summary","text":"<p>Version 0.8.0-beta focuses on audio and visual effects:</p> <ul> <li>Texture atlasing - Massive draw call reduction</li> <li>2D spatial audio - Immersive positional sound</li> <li>Advanced particles - Textures, rotation, trails, blend modes</li> <li>Track callbacks - Proper audio lifecycle</li> <li>Rotation support - SpriteBatcher now rotates correctly</li> </ul> <p>Perfect for building production-quality 2D games!</p>"},{"location":"whats-new/v-0.8.0-beta/#changelog","title":"Changelog","text":""},{"location":"whats-new/v-0.8.0-beta/#added","title":"Added","text":"<ul> <li><code>TextureAtlas</code> - Runtime texture packing system</li> <li><code>AtlasBuilder</code> - Intelligent bin packing algorithm</li> <li><code>AudioListenerComponent</code> - Spatial audio listener (ECS)</li> <li><code>AudioSourceComponent</code> - Spatial audio source (ECS)</li> <li><code>AudioSystem</code> - Updates spatial audio every frame</li> <li>Particle textures - <code>TexturePath</code> property on emitters</li> <li>Particle rotation - <code>StartRotation</code>, <code>EndRotation</code>, <code>RotationSpeed</code></li> <li>Particle trails - <code>TrailEnabled</code>, <code>TrailLength</code>, <code>TrailColor</code></li> <li>Blend modes - <code>BlendMode</code> enum (None, AlphaBlend, Additive)</li> <li>7 emitter shapes - Point, Circle, Ring, Box, Cone, Line, Burst</li> <li>SDL3_mixer callbacks - <code>OnTrackStopped</code> event with proper cleanup</li> <li>SpriteBatcher rotation - Now respects rotation transforms</li> </ul>"},{"location":"whats-new/v-0.8.0-beta/#changed","title":"Changed","text":"<ul> <li><code>ParticleEmitterComponent</code> - New properties for textures, rotation, trails</li> <li><code>SpriteRenderingSystem</code> - Uses texture atlases when available</li> <li><code>SDL3AudioService</code> - Registers native callbacks for track lifecycle</li> <li><code>SpriteBatcher</code> - Applies rotation and tint to sprites</li> </ul>"},{"location":"whats-new/v-0.8.0-beta/#fixed","title":"Fixed","text":"<ul> <li>Audio track cleanup - Tracks now properly destroyed when finished</li> <li>Particle lifetime edge cases - Better handling of very short lifetimes</li> <li>SpriteBatcher rotation - Was ignored, now applied correctly</li> <li>Spatial audio panning - More accurate left/right calculation</li> </ul>"},{"location":"whats-new/v-0.8.0-beta/#deprecated","title":"Deprecated","text":"<ul> <li>None</li> </ul>"},{"location":"whats-new/v-0.8.0-beta/#removed","title":"Removed","text":"<ul> <li>None</li> </ul> <p>\u2190 Back to What's New | Installation Guide \u2192</p>"}]}